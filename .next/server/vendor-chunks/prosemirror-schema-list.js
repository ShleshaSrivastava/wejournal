"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-schema-list";
exports.ids = ["vendor-chunks/prosemirror-schema-list"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* binding */ addListNodes),\n/* harmony export */   bulletList: () => (/* binding */ bulletList),\n/* harmony export */   liftListItem: () => (/* binding */ liftListItem),\n/* harmony export */   listItem: () => (/* binding */ listItem),\n/* harmony export */   orderedList: () => (/* binding */ orderedList),\n/* harmony export */   sinkListItem: () => (/* binding */ sinkListItem),\n/* harmony export */   splitListItem: () => (/* binding */ splitListItem),\n/* harmony export */   wrapInList: () => (/* binding */ wrapInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst olDOM = [\n    \"ol\",\n    0\n], ulDOM = [\n    \"ul\",\n    0\n], liDOM = [\n    \"li\",\n    0\n];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/ const orderedList = {\n    attrs: {\n        order: {\n            default: 1\n        }\n    },\n    parseDOM: [\n        {\n            tag: \"ol\",\n            getAttrs (dom) {\n                return {\n                    order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n                };\n            }\n        }\n    ],\n    toDOM (node) {\n        return node.attrs.order == 1 ? olDOM : [\n            \"ol\",\n            {\n                start: node.attrs.order\n            },\n            0\n        ];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/ const bulletList = {\n    parseDOM: [\n        {\n            tag: \"ul\"\n        }\n    ],\n    toDOM () {\n        return ulDOM;\n    }\n};\n/**\nA list item (`<li>`) spec.\n*/ const listItem = {\n    parseDOM: [\n        {\n            tag: \"li\"\n        }\n    ],\n    toDOM () {\n        return liDOM;\n    },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for(let prop in obj)copy[prop] = obj[prop];\n    for(let prop in props)copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/ function addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, {\n            content: \"list_item+\",\n            group: listGroup\n        }),\n        bullet_list: add(bulletList, {\n            content: \"list_item+\",\n            group: listGroup\n        }),\n        list_item: add(listItem, {\n            content: itemContent\n        })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/ function wrapInList(listType, attrs = null) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\n        if (!range) return false;\n        // This is at the top of an existing list item\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n            // Don't do anything if this is the top of the list\n            if ($from.index(range.depth - 1) == 0) return false;\n            let $insert = state.doc.resolve(range.start - 2);\n            outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);\n            if (range.endIndex < range.parent.childCount) range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n            doJoin = true;\n        }\n        let wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);\n        if (!wrap) return false;\n        if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n        return true;\n    };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for(let i = wrappers.length - 1; i >= 0; i--)content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for(let i = 0; i < wrappers.length; i++)if (wrappers[i].type == listType) found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for(let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false){\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/ function splitListItem(itemType, itemAttrs) {\n    return function(state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType) return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n            if (dispatch) {\n                let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for(let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos)=>{\n                    if (sel > -1) return false;\n                    if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n                });\n                if (sel > -1) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [\n            itemAttrs ? {\n                type: itemType,\n                attrs: itemAttrs\n            } : null,\n            {\n                type: nextType\n            }\n        ] : undefined;\n        if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types)) return false;\n        if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/ function liftListItem(itemType) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, (node)=>node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range) return false;\n        if (!dispatch) return true;\n        if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);\n        else return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);\n    if (target == null) return false;\n    tr.lift(range, target);\n    let after = tr.mapping.map(end, -1) - 1;\n    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, after)) tr.join(after);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for(let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--){\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list)))) return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/ function sinkListItem(itemType) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, (node)=>node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range) return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0) return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType) return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n        }\n        return true;\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RztBQUN4QztBQUNqQjtBQUU5QyxNQUFNUyxRQUFRO0lBQUM7SUFBTTtDQUFFLEVBQUVDLFFBQVE7SUFBQztJQUFNO0NBQUUsRUFBRUMsUUFBUTtJQUFDO0lBQU07Q0FBRTtBQUM3RDs7Ozs7QUFLQSxHQUNBLE1BQU1DLGNBQWM7SUFDaEJDLE9BQU87UUFBRUMsT0FBTztZQUFFQyxTQUFTO1FBQUU7SUFBRTtJQUMvQkMsVUFBVTtRQUFDO1lBQUVDLEtBQUs7WUFBTUMsVUFBU0MsR0FBRztnQkFDeEIsT0FBTztvQkFBRUwsT0FBT0ssSUFBSUMsWUFBWSxDQUFDLFdBQVcsQ0FBQ0QsSUFBSUUsWUFBWSxDQUFDLFdBQVc7Z0JBQUU7WUFDL0U7UUFBRTtLQUFFO0lBQ1pDLE9BQU1DLElBQUk7UUFDTixPQUFPQSxLQUFLVixLQUFLLENBQUNDLEtBQUssSUFBSSxJQUFJTCxRQUFRO1lBQUM7WUFBTTtnQkFBRWUsT0FBT0QsS0FBS1YsS0FBSyxDQUFDQyxLQUFLO1lBQUM7WUFBRztTQUFFO0lBQ2pGO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1XLGFBQWE7SUFDZlQsVUFBVTtRQUFDO1lBQUVDLEtBQUs7UUFBSztLQUFFO0lBQ3pCSztRQUFVLE9BQU9aO0lBQU87QUFDNUI7QUFDQTs7QUFFQSxHQUNBLE1BQU1nQixXQUFXO0lBQ2JWLFVBQVU7UUFBQztZQUFFQyxLQUFLO1FBQUs7S0FBRTtJQUN6Qks7UUFBVSxPQUFPWDtJQUFPO0lBQ3hCZ0IsVUFBVTtBQUNkO0FBQ0EsU0FBU0MsSUFBSUMsR0FBRyxFQUFFQyxLQUFLO0lBQ25CLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSUMsUUFBUUgsSUFDYkUsSUFBSSxDQUFDQyxLQUFLLEdBQUdILEdBQUcsQ0FBQ0csS0FBSztJQUMxQixJQUFLLElBQUlBLFFB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QUNpRyxTQUFVbUMsQ0FBQUEsZUFBZSxJQUFJLElBQUlqQyxPQUFPRixRQUFRRSxPQUFPb0MsT0FBTyxHQUFHLE9BQ3pHbkUsY0FBYztRQUN2QjtRQUNBLE9BQU87SUFDWDtBQUNKO0FBRWtIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2Utam91cm5hbC8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzPzVlNmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmluZFdyYXBwaW5nLCBSZXBsYWNlQXJvdW5kU3RlcCwgY2FuU3BsaXQsIGxpZnRUYXJnZXQsIGNhbkpvaW4gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgTm9kZVJhbmdlLCBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG9sRE9NID0gW1wib2xcIiwgMF0sIHVsRE9NID0gW1widWxcIiwgMF0sIGxpRE9NID0gW1wibGlcIiwgMF07XG4vKipcbkFuIG9yZGVyZWQgbGlzdCBbbm9kZSBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMpLiBIYXMgYSBzaW5nbGVcbmF0dHJpYnV0ZSwgYG9yZGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIGF0IHdoaWNoIHRoZSBsaXN0XG5zdGFydHMgY291bnRpbmcsIGFuZCBkZWZhdWx0cyB0byAxLiBSZXByZXNlbnRlZCBhcyBhbiBgPG9sPmBcbmVsZW1lbnQuXG4qL1xuY29uc3Qgb3JkZXJlZExpc3QgPSB7XG4gICAgYXR0cnM6IHsgb3JkZXI6IHsgZGVmYXVsdDogMSB9IH0sXG4gICAgcGFyc2VET006IFt7IHRhZzogXCJvbFwiLCBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDEgfTtcbiAgICAgICAgICAgIH0gfV0sXG4gICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7IHN0YXJ0OiBub2RlLmF0dHJzLm9yZGVyIH0sIDBdO1xuICAgIH1cbn07XG4vKipcbkEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbiovXG5jb25zdCBidWxsZXRMaXN0ID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidWxcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NOyB9XG59O1xuLyoqXG5BIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxuKi9cbmNvbnN0IGxpc3RJdGVtID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwibGlcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGxpRE9NOyB9LFxuICAgIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpXG4gICAgICAgIGNvcHlbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG5bYG9yZGVyZWRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG5bYGJ1bGxldExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuW2BsaXN0SXRlbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuXG5gaXRlbUNvbnRlbnRgIGRldGVybWluZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGxpc3QgaXRlbXMuXG5JZiB5b3Ugd2FudCB0aGUgY29tbWFuZHMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB0byBhcHBseSB0byB5b3VyXG5saXN0IHN0cnVjdHVyZSwgaXQgc2hvdWxkIGhhdmUgYSBzaGFwZSBsaWtlIGBcInBhcmFncmFwaCBibG9jaypcImAgb3JcbmBcInBhcmFncmFwaCAob3JkZXJlZF9saXN0IHwgYnVsbGV0X2xpc3QpKlwiYC4gYGxpc3RHcm91cGAgY2FuIGJlXG5naXZlbiB0byBhc3NpZ24gYSBncm91cCBuYW1lIHRvIHRoZSBsaXN0IG5vZGUgdHlwZXMsIGZvciBleGFtcGxlXG5gXCJibG9ja1wiYC5cbiovXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgICByZXR1cm4gbm9kZXMuYXBwZW5kKHtcbiAgICAgICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHsgY29udGVudDogaXRlbUNvbnRlbnQgfSlcbiAgICB9KTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG50aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbnZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG5wZXJmb3JtIHRoZSBjaGFuZ2UuXG4qL1xuZnVuY3Rpb24gd3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIGRvSm9pbiA9IGZhbHNlLCBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBpcyB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkaW5zZXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQgLSAyKTtcbiAgICAgICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSgkZnJvbSwgc3RhdGUuZG9jLnJlc29sdmUoJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgICAgICAgICBkb0pvaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwID0gZmluZFdyYXBwaW5nKG91dGVyUmFuZ2UsIGxpc3RUeXBlLCBhdHRycywgcmFuZ2UpO1xuICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKGRvV3JhcEluTGlzdChzdGF0ZS50ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIGxldCBmb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT0gbGlzdFR5cGUpXG4gICAgICAgICAgICBmb3VuZCA9IGkgKyAxO1xuICAgIGxldCBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG4gICAgbGV0IHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSA8IGU7IGkrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG5vZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvLCBub2RlIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGxldCB0eXBlcyA9IG5leHRUeXBlID8gW2l0ZW1BdHRycyA/IHsgdHlwZTogaXRlbVR5cGUsIGF0dHJzOiBpdGVtQXR0cnMgfSA6IG51bGwsIHsgdHlwZTogbmV4dFR5cGUgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG9cbmEgd3JhcHBpbmcgbGlzdC5cbiovXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRpc3BhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgICAgICAgIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO1xuICAgICAgICBlbHNlIC8vIE91dGVyIGxpc3Qgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBlbmQgPSByYW5nZS5lbmQsIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHJhbmdlLnBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHIubGlmdChyYW5nZSwgdGFyZ2V0KTtcbiAgICBsZXQgYWZ0ZXIgPSB0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDE7XG4gICAgaWYgKGNhbkpvaW4odHIuZG9jLCBhZnRlcikpXG4gICAgICAgIHRyLmpvaW4oYWZ0ZXIpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmVuZCwgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgZSA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBlOyBpLS0pIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSwgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICAgIGxldCBwYXJlbnQgPSAkc3RhcnQubm9kZSgtMSksIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0ID0gJHN0YXJ0LnBvcywgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG5pbnRvIGFuIGlubmVyIGxpc3QuXG4qL1xuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSByYW5nZS5zdGFydCwgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhZGRMaXN0Tm9kZXMsIGJ1bGxldExpc3QsIGxpZnRMaXN0SXRlbSwgbGlzdEl0ZW0sIG9yZGVyZWRMaXN0LCBzaW5rTGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW0sIHdyYXBJbkxpc3QgfTtcbiJdLCJuYW1lcyI6WyJmaW5kV3JhcHBpbmciLCJSZXBsYWNlQXJvdW5kU3RlcCIsImNhblNwbGl0IiwibGlmdFRhcmdldCIsImNhbkpvaW4iLCJOb2RlUmFuZ2UiLCJGcmFnbWVudCIsIlNsaWNlIiwiU2VsZWN0aW9uIiwib2xET00iLCJ1bERPTSIsImxpRE9NIiwib3JkZXJlZExpc3QiLCJhdHRycyIsIm9yZGVyIiwiZGVmYXVsdCIsInBhcnNlRE9NIiwidGFnIiwiZ2V0QXR0cnMiLCJkb20iLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJ0b0RPTSIsIm5vZGUiLCJzdGFydCIsImJ1bGxldExpc3QiLCJsaXN0SXRlbSIsImRlZmluaW5nIiwiYWRkIiwib2JqIiwicHJvcHMiLCJjb3B5IiwicHJvcCIsImFkZExpc3ROb2RlcyIsIm5vZGVzIiwiaXRlbUNvbnRlbnQiLCJsaXN0R3JvdXAiLCJhcHBlbmQiLCJvcmRlcmVkX2xpc3QiLCJjb250ZW50IiwiZ3JvdXAiLCJidWxsZXRfbGlzdCIsImxpc3RfaXRlbSIsIndyYXBJbkxpc3QiLCJsaXN0VHlwZSIsInN0YXRlIiwiZGlzcGF0Y2giLCIkZnJvbSIsIiR0byIsInNlbGVjdGlvbiIsInJhbmdlIiwiYmxvY2tSYW5nZSIsImRvSm9pbiIsIm91dGVyUmFuZ2UiLCJkZXB0aCIsInR5cGUiLCJjb21wYXRpYmxlQ29udGVudCIsInN0YXJ0SW5kZXgiLCJpbmRleCIsIiRpbnNlcnQiLCJkb2MiLCJyZXNvbHZlIiwiZW5kSW5kZXgiLCJwYXJlbnQiLCJjaGlsZENvdW50IiwiZW5kIiwid3JhcCIsImRvV3JhcEluTGlzdCIsInRyIiwic2Nyb2xsSW50b1ZpZXciLCJ3cmFwcGVycyIsImpvaW5CZWZvcmUiLCJlbXB0eSIsImkiLCJsZW5ndGgiLCJmcm9tIiwiY3JlYXRlIiwic3RlcCIsImZvdW5kIiwic3BsaXREZXB0aCIsInNwbGl0UG9zIiwiZSIsImZpcnN0Iiwic3BsaXQiLCJjaGlsZCIsIm5vZGVTaXplIiwic3BsaXRMaXN0SXRlbSIsIml0ZW1UeXBlIiwiaXRlbUF0dHJzIiwiaXNCbG9jayIsInNhbWVQYXJlbnQiLCJncmFuZFBhcmVudCIsInNpemUiLCJpbmRleEFmdGVyIiwiZGVwdGhCZWZvcmUiLCJkIiwiZGVwdGhBZnRlciIsImNyZWF0ZUFuZEZpbGwiLCJiZWZvcmUiLCJyZXBsYWNlIiwiYWZ0ZXIiLCJzZWwiLCJub2Rlc0JldHdlZW4iLCJwb3MiLCJpc1RleHRibG9jayIsInNldFNlbGVjdGlvbiIsIm5lYXIiLCJuZXh0VHlwZSIsImNvbnRlbnRNYXRjaEF0IiwiZGVmYXVsdFR5cGUiLCJkZWxldGUiLCJ0eXBlcyIsInVuZGVmaW5lZCIsImxpZnRMaXN0SXRlbSIsImZpcnN0Q2hpbGQiLCJsaWZ0VG9PdXRlckxpc3QiLCJsaWZ0T3V0T2ZMaXN0IiwiZW5kT2ZMaXN0IiwidGFyZ2V0IiwibGlmdCIsIm1hcHBpbmciLCJtYXAiLCJqb2luIiwibGlzdCIsIiRzdGFydCIsIml0ZW0iLCJub2RlQWZ0ZXIiLCJhdFN0YXJ0IiwiYXRFbmQiLCJpbmRleEJlZm9yZSIsImNhblJlcGxhY2UiLCJzaW5rTGlzdEl0ZW0iLCJub2RlQmVmb3JlIiwibmVzdGVkQmVmb3JlIiwibGFzdENoaWxkIiwiaW5uZXIiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\n");

/***/ })

};
;