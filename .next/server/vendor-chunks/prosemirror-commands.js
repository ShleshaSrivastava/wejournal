"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-commands";
exports.ids = ["vendor-chunks/prosemirror-commands"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* binding */ autoJoin),\n/* harmony export */   baseKeymap: () => (/* binding */ baseKeymap),\n/* harmony export */   chainCommands: () => (/* binding */ chainCommands),\n/* harmony export */   createParagraphNear: () => (/* binding */ createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* binding */ deleteSelection),\n/* harmony export */   exitCode: () => (/* binding */ exitCode),\n/* harmony export */   joinBackward: () => (/* binding */ joinBackward),\n/* harmony export */   joinDown: () => (/* binding */ joinDown),\n/* harmony export */   joinForward: () => (/* binding */ joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* binding */ joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* binding */ joinTextblockForward),\n/* harmony export */   joinUp: () => (/* binding */ joinUp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftEmptyBlock: () => (/* binding */ liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* binding */ macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* binding */ newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* binding */ pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectNodeBackward: () => (/* binding */ selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* binding */ selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* binding */ selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* binding */ selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* binding */ selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* binding */ setBlockType),\n/* harmony export */   splitBlock: () => (/* binding */ splitBlock),\n/* harmony export */   splitBlockAs: () => (/* binding */ splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark),\n/* harmony export */   wrapIn: () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n/**\nDelete the selection, if there is one.\n*/ const deleteSelection = (state, dispatch)=>{\n    if (state.selection.empty) return false;\n    if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before itâ€”if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/ const joinBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null) return false;\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(before, \"end\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/ const joinTextblockBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/ const joinTextblockForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for(; !beforeText.isTextblock; beforePos--){\n        if (beforeText.type.spec.isolating) return false;\n        let child = beforeText.lastChild;\n        if (!child) return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for(; !afterText.isTextblock; afterPos++){\n        if (afterText.type.spec.isolating) return false;\n        let child = afterText.firstChild;\n        if (!child) return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for(let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild){\n        if (scan.isTextblock) return true;\n        if (only && scan.childCount != 1) return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/ const selectNodeBackward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n        if ($pos.node(i).type.spec.isolating) break;\n    }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/ const joinForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut) return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch)) return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/ const selectNodeForward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        let parent = $pos.node(i);\n        if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n        if (parent.type.spec.isolating) break;\n    }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/ const joinUp = (state, dispatch)=>{\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) return false;\n        point = sel.from;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null) return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/ const joinDown = (state, dispatch)=>{\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) return false;\n        point = sel.to;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null) return false;\n    }\n    if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/ const lift = (state, dispatch)=>{\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/ const newlineInCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i++){\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/ const exitCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type)) return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/ const createParagraphNear = (state, dispatch)=>{\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock) return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/ const liftEmptyBlock = (state, dispatch)=>{\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size) return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/ function splitBlockAs(splitNode) {\n    return (state, dispatch)=>{\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) return false;\n            if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.parent.isBlock) return false;\n        if (dispatch) {\n            let atEnd = $to.parentOffset == $to.parent.content.size;\n            let tr = state.tr;\n            if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection) tr.deleteSelection();\n            let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let splitType = splitNode && splitNode($to.parent, atEnd);\n            let types = splitType ? [\n                splitType\n            ] : atEnd && deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined;\n            let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined)) {\n                if (deflt) types = [\n                    {\n                        type: deflt\n                    }\n                ];\n                can = true;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n                    let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n                    if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/ const splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/ const splitBlockKeepMarks = (state, dispatch)=>{\n    return splitBlock(state, dispatch && ((tr)=>{\n        let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n        if (marks) tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/ const selectParentNode = (state, dispatch)=>{\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0) return false;\n    pos = $from.before(same);\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/ const selectAll = (state, dispatch)=>{\n    if (dispatch) dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos))) return false;\n    if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    if (before.type.spec.isolating || after.type.spec.isolating) return false;\n    if (joinMaybeClear(state, $cut, dispatch)) return true;\n    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for(let i = conn.length - 1; i >= 0; i--)wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let joinAt = end + 2 * conn.length;\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) tr.join(joinAt);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for(;;){\n            wrap.push(at);\n            if (at.isTextblock) break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for(; !afterText.isTextblock; afterText = afterText.firstChild)afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for(let i = wrap.length - 1; i >= 0; i--)end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function(state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while($pos.node(depth).isInline){\n            if (!depth) return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock) return false;\n        if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/ const selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/ const selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/ function wrapIn(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping) return false;\n        if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/ function setBlockType(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let applicable = false;\n        for(let i = 0; i < state.selection.ranges.length && !applicable; i++){\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos)=>{\n                if (applicable) return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                } else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable) return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for(let i = 0; i < state.selection.ranges.length; i++){\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type) {\n    for(let i = 0; i < ranges.length; i++){\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node)=>{\n            if (can) return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can) return true;\n    }\n    return false;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/ function toggleMark(markType, attrs = null) {\n    return function(state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));\n                else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            } else {\n                let has = false, tr = state.tr;\n                for(let i = 0; !has && i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n                }\n                for(let i = 0; i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    if (has) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    } else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr)=>{\n        if (!tr.isGeneric) return dispatch(tr);\n        let ranges = [];\n        for(let i = 0; i < tr.mapping.maps.length; i++){\n            let map = tr.mapping.maps[i];\n            for(let j = 0; j < ranges.length; j++)ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to)=>ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for(let i = 0; i < ranges.length; i += 2){\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for(let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index){\n                let after = parent.maybeChild(index);\n                if (!after) break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b)=>a - b);\n        for(let i = joinable.length - 1; i >= 0; i--){\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i])) tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/ function autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node)=>isJoinable.indexOf(node.type.name) > -1 : isJoinable;\n    return (state, dispatch, view)=>command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/ function chainCommands(...commands) {\n    return function(state, dispatch, view) {\n        for(let i = 0; i < commands.length; i++)if (commands[i](state, dispatch, view)) return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/ const pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/ const macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor(let key in pcBaseKeymap)macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/ const baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0STtBQUN4RjtBQUNzQztBQUUxRjs7QUFFQSxHQUNBLE1BQU1jLGtCQUFrQixDQUFDQyxPQUFPQztJQUM1QixJQUFJRCxNQUFNRSxTQUFTLENBQUNDLEtBQUssRUFDckIsT0FBTztJQUNYLElBQUlGLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ0wsZUFBZSxHQUFHTSxjQUFjO0lBQ3RELE9BQU87QUFDWDtBQUNBLFNBQVNDLGFBQWFOLEtBQUssRUFBRU8sSUFBSTtJQUM3QixJQUFJLEVBQUVDLE9BQU8sRUFBRSxHQUFHUixNQUFNRSxTQUFTO0lBQ2pDLElBQUksQ0FBQ00sV0FBWUQsQ0FBQUEsT0FBTyxDQUFDQSxLQUFLRSxjQUFjLENBQUMsWUFBWVQsU0FDbkRRLFFBQVFFLFlBQVksR0FBRyxJQUN6QixPQUFPO0lBQ1gsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTUcsZUFBZSxDQUFDWCxPQUFPQyxVQUFVTTtJQUNuQyxJQUFJQyxVQUFVRixhQUFhTixPQUFPTztJQUNsQyxJQUFJLENBQUNDLFNBQ0QsT0FBTztJQUNYLElBQUlJLE9BQU9DLGNBQWNMO0lBQ3pCLCtDQUErQztJQUMvQyxJQUFJLENBQUNJLE1BQU07UUFDUCxJQUFJRSxRQUFRTixRQUFRTyxVQUFVLElBQUlDLFNBQVNGLFNBQVM3QixpRUFBVUEsQ0FBQzZCO1FBQy9ELElBQUlFLFVBQVUsTUFDVixPQUFPO1FBQ1gsSUFBSWYsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7UUFDeEQsT0FBTztJQUNYO0lBQ0EsSUFBSWEsU0FBU04sS0FBS08sVUFBVTtJQUM1Qiw4QkFBOEI7SUFDOUIsSUFBSSxDQUFDRCxPQUFPRSxJQUFJLENB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LE1BQU0sV0FBVztBQUM1RTs7OztBQUlBLEdBQ0EsTUFBTUUsYUFBYUwsTUFBTUYsZ0JBQWdCRDtBQUVpWiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlLWpvdXJuYWwvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcz8yOGY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwLCBSZXBsYWNlU3RlcCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuKi9cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCB0cnkgdG9cbnJlZHVjZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGJsb2NrIGFuZCB0aGUgb25lIGJlZm9yZSBpdOKAlGlmXG50aGVyZSdzIGEgYmxvY2sgZGlyZWN0bHkgYmVmb3JlIGl0IHRoYXQgY2FuIGJlIGpvaW5lZCwgam9pbiB0aGVtLlxuSWYgbm90LCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0ZWQgYmxvY2sgY2xvc2VyIHRvIHRoZSBuZXh0IG9uZSBpblxudGhlIGRvY3VtZW50IHN0cnVjdHVyZSBieSBsaWZ0aW5nIGl0IG91dCBvZiBpdHMgcGFyZW50IG9yIG1vdmluZyBpdFxuaW50byBhIHBhcmVudCBvZiB0aGUgcHJldmlvdXMgYmxvY2suIFdpbGwgdXNlIHRoZSB2aWV3IGZvciBhY2N1cmF0ZVxuKGJpZGktYXdhcmUpIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgdGhpcywgdHJ5IHRvIGxpZnRcbiAgICBpZiAoISRjdXQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAgIC8vIEFwcGx5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmICghYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBiZWxvdyBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYWJvdmUgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYmVsb3cgYW5kIHNlbGVjdCB0aGUgb25lIGFib3ZlLlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShiZWZvcmUpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5CYWNrd2FyZGBdKCRjb21tYW5kcy5qb2luQmFja3dhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBiZWZvcmVcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luRm9yd2FyZGBdKCRjb21tYW5kcy5qb2luRm9yd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGFmdGVyXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYmVmb3JlVGV4dCA9IGJlZm9yZSwgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICAgIGZvciAoOyAhYmVmb3JlVGV4dC5pc1RleHRibG9jazsgYmVmb3JlUG9zLS0pIHtcbiAgICAgICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYmVmb3JlVGV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJlZm9yZVRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlclBvcyA9ICRjdXQucG9zICsgMTtcbiAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJQb3MrKykge1xuICAgICAgICBpZiAoYWZ0ZXJUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhZnRlclRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsIGJlZm9yZVBvcywgYWZ0ZXJQb3MsIFNsaWNlLmVtcHR5KTtcbiAgICBpZiAoIXN0ZXAgfHwgc3RlcC5mcm9tICE9IGJlZm9yZVBvcyB8fFxuICAgICAgICBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgJiYgc3RlcC5zbGljZS5zaXplID49IGFmdGVyUG9zIC0gYmVmb3JlUG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoc3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGJlZm9yZVBvcykpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlLCBvbmx5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IChzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSkge1xuICAgICAgICBpZiAoc2Nhbi5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob25seSAmJiBzY2FuLmNoaWxkQ291bnQgIT0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG5ib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuW2Bqb2luQmFja3dhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG5kZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUJlZm9yZTtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcyAtIG5vZGUubm9kZVNpemUpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QmVmb3JlKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmJlZm9yZShpICsgMSkpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxudGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG5hbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG5ibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGFmdGVyIHRoaXMsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICAgIGlmICghJGN1dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAgIC8vIFRyeSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBhYm92ZSBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYmVsb3cgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYWZ0ZXIpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGFmdGVyLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcywgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgY29taW5nIGFmdGVyIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZFxudG8gYmUgYm91bmQgdG8ga2V5cyBsaWtlIGRlbGV0ZSwgYWZ0ZXJcbltgam9pbkZvcndhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkZvcndhcmQpIGFuZCBzaW1pbGFyIGRlbGV0aW5nXG5jb21tYW5kcywgdG8gcHJvdmlkZSBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndFxuYWxsb3cgZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRBZnRlcigkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVBZnRlcjtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRBZnRlcigkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGkpO1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrIG9yLCBpZiB0aGVyZSBpcyBhIHRleHQgc2VsZWN0aW9uLCB0aGVcbmNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQsIHdpdGhcbnRoZSBzaWJsaW5nIGFib3ZlIGl0LlxuKi9cbmNvbnN0IGpvaW5VcCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBub2RlU2VsID0gc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKG5vZGVTZWwpIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC5mcm9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmpvaW4ocG9pbnQpO1xuICAgICAgICBpZiAobm9kZVNlbClcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvaW50IC0gc3RhdGUuZG9jLnJlc29sdmUocG9pbnQpLm5vZGVCZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoZSBzZWxlY3Rpb25cbnRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhZnRlciBpdC5cbiovXG5jb25zdCBqb2luRG93biA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC50bztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLnRvLCAxKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuam9pbihwb2ludCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5MaWZ0IHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlXG5zZWxlY3Rpb24gdGhhdCBjYW4gYmUgbGlmdGVkLCBvdXQgb2YgaXRzIHBhcmVudCBub2RlLlxuKi9cbmNvbnN0IGxpZnQgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2hvc2UgdHlwZSBoYXMgYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgcmVwbGFjZSB0aGVcbnNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBjaGFyYWN0ZXIuXG4qL1xuY29uc3QgbmV3bGluZUluQ29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbiovXG5jb25zdCBleGl0Q29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFib3ZlID0gJGhlYWQubm9kZSgtMSksIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksIHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpO1xuICAgIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgcG9zID0gJGhlYWQuYWZ0ZXIoKSwgdHIgPSBzdGF0ZS50ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUocG9zKSwgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiBhIGJsb2NrIG5vZGUgaXMgc2VsZWN0ZWQsIGNyZWF0ZSBhbiBlbXB0eSBwYXJhZ3JhcGggYmVmb3JlIChpZlxuaXQgaXMgaXRzIHBhcmVudCdzIGZpcnN0IGNoaWxkKSBvciBhZnRlciBpdC5cbiovXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gfHwgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgICBpZiAoIXR5cGUgfHwgIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoISRmcm9tLnBhcmVudE9mZnNldCAmJiAkdG8uaW5kZXgoKSA8ICR0by5wYXJlbnQuY2hpbGRDb3VudCA/ICRmcm9tIDogJHRvKS5wb3M7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHNpZGUgKyAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbmJsb2NrLlxuKi9cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgICAgIGlmIChjYW5TcGxpdChzdGF0ZS5kb2MsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNyZWF0ZSBhIHZhcmlhbnQgb2YgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spIHRoYXQgdXNlc1xuYSBjdXN0b20gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBuZXdseSBzcGxpdCBvZmYgYmxvY2suXG4qL1xuZnVuY3Rpb24gc3BsaXRCbG9ja0FzKHNwbGl0Tm9kZSkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KHN0YXRlLmRvYywgJGZyb20ucG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gfHwgc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGZyb20uZGVwdGggPT0gMCA/IG51bGwgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICAgICAgICAgICAgbGV0IHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQpO1xuICAgICAgICAgICAgbGV0IHR5cGVzID0gc3BsaXRUeXBlID8gW3NwbGl0VHlwZV0gOiBhdEVuZCAmJiBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgaWYgKCF0eXBlcyAmJiAhY2FuICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQpXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzID0gW3sgdHlwZTogZGVmbHQgfV07XG4gICAgICAgICAgICAgICAgY2FuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5TcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG5zZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuKi9cbmNvbnN0IHNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrQXMoKTtcbi8qKlxuQWN0cyBsaWtlIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSwgYnV0IHdpdGhvdXRcbnJlc2V0dGluZyB0aGUgc2V0IG9mIGFjdGl2ZSBtYXJrcyBhdCB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IHNwbGl0QmxvY2tLZWVwTWFya3MgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHNwbGl0QmxvY2soc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pKTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbm9kZSB3cmFwcGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGlmXG5hbnkuIChXaWxsIG5vdCBzZWxlY3QgdGhlIGRvY3VtZW50IG5vZGUuKVxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIHBvcztcbiAgICBsZXQgc2FtZSA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICBpZiAoc2FtZSA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYmVmb3JlLmNvbnRlbnQuc2l6ZSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4IC0gMSwgaW5kZXgpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkcG9zLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpIHx8ICEoYWZ0ZXIuaXNUZXh0YmxvY2sgfHwgY2FuSm9pbihzdGF0ZS5kb2MsICRwb3MucG9zKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyXG4gICAgICAgICAgICAuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKVxuICAgICAgICAgICAgLmpvaW4oJHBvcy5wb3MpXG4gICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGNvbm4sIG1hdGNoO1xuICAgIGlmIChiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiZcbiAgICAgICAgKGNvbm4gPSAobWF0Y2ggPSBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5maW5kV3JhcHBpbmcoYWZ0ZXIudHlwZSkpICYmXG4gICAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9ICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsIHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGJlZm9yZS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gMSwgZW5kLCAkY3V0LnBvcywgZW5kLCBuZXcgU2xpY2Uod3JhcCwgMSwgMCksIGNvbm4ubGVuZ3RoLCB0cnVlKSk7XG4gICAgICAgICAgICBsZXQgam9pbkF0ID0gZW5kICsgMiAqIGNvbm4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luQXQpKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbkF0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2VsQWZ0ZXIgPSBTZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gICAgbGV0IHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgICAgIGxldCBhdCA9IGJlZm9yZSwgd3JhcCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB3cmFwLnB1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlckRlcHRoID0gMTtcbiAgICAgICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gRnJhZ21lbnQuZnJvbSh3cmFwW2ldLmNvcHkoZW5kKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwLmxlbmd0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgJGN1dC5wb3MgKyBhZnRlckRlcHRoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplIC0gYWZ0ZXJEZXB0aCwgbmV3IFNsaWNlKGVuZCwgd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCAkcG9zID0gc2lkZSA8IDAgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgICAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgICAgICB3aGlsZSAoJHBvcy5ub2RlKGRlcHRoKS5pc0lubGluZSkge1xuICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgtMSk7XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgxKTtcbi8vIFBhcmFtZXRlcml6ZWQgY29tbWFuZHNcbi8qKlxuV3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBnaXZlblxuYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IHRyaWVzIHRvIHNldCB0aGUgc2VsZWN0ZWQgdGV4dGJsb2NrcyB0byB0aGVcbmdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCAmJiAhYXBwbGljYWJsZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcHBsaWNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy5pbmxpbmVDb250ZW50ICYmIGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdG9nZ2xlcyB0aGUgZ2l2ZW4gbWFyayB3aXRoIHRoZVxuZ2l2ZW4gYXR0cmlidXRlcy4gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZG9lc24ndCBzdXBwb3J0IHRoYXQgbWFyay4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgbWFyayBpZiBhbnkgbWFya3Ncbm9mIHRoYXQgdHlwZSBleGlzdCBpbiB0aGUgc2VsZWN0aW9uLCBvciBhZGQgaXQgb3RoZXJ3aXNlLiBJZiB0aGVcbnNlbGVjdGlvbiBpcyBlbXB0eSwgdGhpcyBhcHBsaWVzIHRvIHRoZSBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKSBpbnN0ZWFkIG9mIGEgcmFuZ2Ugb2YgdGhlXG5kb2N1bWVudC5cbiovXG5mdW5jdGlvbiB0b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyBlbXB0eSwgJGN1cnNvciwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgoZW1wdHkgJiYgISRjdXJzb3IpIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGN1cnNvci5tYXJrcygpKSlcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzID0gZmFsc2UsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7ICFoYXMgJiYgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhcyA9IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gJGZyb20ucG9zLCB0byA9ICR0by5wb3MsIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLCBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZVN0YXJ0ID0gc3RhcnQgJiYgc3RhcnQuaXNUZXh0ID8gL15cXHMqLy5leGVjKHN0YXJ0LnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VFbmQgPSBlbmQgJiYgZW5kLmlzVGV4dCA/IC9cXHMqJC8uZXhlYyhlbmQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICsgc3BhY2VTdGFydCA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIC09IHNwYWNlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgbWFya1R5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGlzSm9pbmFibGUpIHtcbiAgICByZXR1cm4gKHRyKSA9PiB7XG4gICAgICAgIGlmICghdHIuaXNHZW5lcmljKVxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IG1hcC5tYXAocmFuZ2VzW2pdKTtcbiAgICAgICAgICAgIG1hcC5mb3JFYWNoKChfcywgX2UsIGZyb20sIHRvKSA9PiByYW5nZXMucHVzaChmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgICAgIC8vIGJ5IGNoZWNraW5nIGFsbCBub2RlIGJvdW5kYXJpZXMgaW4gdGhlaXIgcGFyZW50IG5vZGVzLlxuICAgICAgICBsZXQgam9pbmFibGUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2ldLCB0byA9IHJhbmdlc1tpICsgMV07XG4gICAgICAgICAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT0gYWZ0ZXIudHlwZSAmJiBpc0pvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gYWZ0ZXIubm9kZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgICAgIGpvaW5hYmxlLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5hYmxlW2ldKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5hYmxlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCBhIGNvbW1hbmQgc28gdGhhdCwgd2hlbiBpdCBwcm9kdWNlcyBhIHRyYW5zZm9ybSB0aGF0IGNhdXNlc1xudHdvIGpvaW5hYmxlIG5vZGVzIHRvIGVuZCB1cCBuZXh0IHRvIGVhY2ggb3RoZXIsIHRob3NlIGFyZSBqb2luZWQuXG5Ob2RlcyBhcmUgY29uc2lkZXJlZCBqb2luYWJsZSB3aGVuIHRoZXkgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kXG53aGVuIHRoZSBgaXNKb2luYWJsZWAgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSBmb3IgdGhlbSBvciwgaWYgYW5cbmFycmF5IG9mIHN0cmluZ3Mgd2FzIHBhc3NlZCwgaWYgdGhlaXIgbm9kZSB0eXBlIG5hbWUgaXMgaW4gdGhhdFxuYXJyYXkuXG4qL1xuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICAgIGxldCBjYW5Kb2luID0gQXJyYXkuaXNBcnJheShpc0pvaW5hYmxlKSA/IChub2RlKSA9PiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTFcbiAgICAgICAgOiBpc0pvaW5hYmxlO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG59XG4vKipcbkNvbWJpbmUgYSBudW1iZXIgb2YgY29tbWFuZCBmdW5jdGlvbnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiAod2hpY2hcbmNhbGxzIHRoZW0gb25lIGJ5IG9uZSB1bnRpbCBvbmUgcmV0dXJucyB0cnVlKS5cbiovXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKC4uLmNvbW1hbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmxldCBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xubGV0IGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuLyoqXG5BIGJhc2ljIGtleW1hcCBjb250YWluaW5nIGJpbmRpbmdzIG5vdCBzcGVjaWZpYyB0byBhbnkgc2NoZW1hLlxuQmluZHMgdGhlIGZvbGxvd2luZyBrZXlzICh3aGVuIG11bHRpcGxlIGNvbW1hbmRzIGFyZSBsaXN0ZWQsIHRoZXlcbmFyZSBjaGFpbmVkIHdpdGggW2BjaGFpbkNvbW1hbmRzYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmNoYWluQ29tbWFuZHMpKTpcblxuKiAqKkVudGVyKiogdG8gYG5ld2xpbmVJbkNvZGVgLCBgY3JlYXRlUGFyYWdyYXBoTmVhcmAsIGBsaWZ0RW1wdHlCbG9ja2AsIGBzcGxpdEJsb2NrYFxuKiAqKk1vZC1FbnRlcioqIHRvIGBleGl0Q29kZWBcbiogKipCYWNrc3BhY2UqKiBhbmQgKipNb2QtQmFja3NwYWNlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luQmFja3dhcmRgLCBgc2VsZWN0Tm9kZUJhY2t3YXJkYFxuKiAqKkRlbGV0ZSoqIGFuZCAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1hKiogdG8gYHNlbGVjdEFsbGBcbiovXG5jb25zdCBwY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJFbnRlclwiOiBjaGFpbkNvbW1hbmRzKG5ld2xpbmVJbkNvZGUsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGxpZnRFbXB0eUJsb2NrLCBzcGxpdEJsb2NrKSxcbiAgICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgICBcIkJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJNb2QtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJEZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLURlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG4vKipcbkEgY29weSBvZiBgcGNCYXNlS2V5bWFwYCB0aGF0IGFsc28gYmluZHMgKipDdHJsLWgqKiBsaWtlIEJhY2tzcGFjZSxcbioqQ3RybC1kKiogbGlrZSBEZWxldGUsICoqQWx0LUJhY2tzcGFjZSoqIGxpa2UgQ3RybC1CYWNrc3BhY2UsIGFuZFxuKipDdHJsLUFsdC1CYWNrc3BhY2UqKiwgKipBbHQtRGVsZXRlKiosIGFuZCAqKkFsdC1kKiogbGlrZVxuQ3RybC1EZWxldGUuXG4qL1xuY29uc3QgbWFjQmFzZUtleW1hcCA9IHtcbiAgICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gICAgXCJBbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1CYWNrc3BhY2VcIl0sXG4gICAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtRGVsZXRlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1hXCI6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICAgIFwiQ3RybC1lXCI6IHNlbGVjdFRleHRibG9ja0VuZFxufTtcbmZvciAobGV0IGtleSBpbiBwY0Jhc2VLZXltYXApXG4gICAgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcy5wbGF0Zm9ybSA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuLyoqXG5EZXBlbmRpbmcgb24gdGhlIGRldGVjdGVkIHBsYXRmb3JtLCB0aGlzIHdpbGwgaG9sZFxuW2BwY0Jhc2VrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMucGNCYXNlS2V5bWFwKSBvclxuW2BtYWNCYXNlS2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLm1hY0Jhc2VLZXltYXApLlxuKi9cbmNvbnN0IGJhc2VLZXltYXAgPSBtYWMgPyBtYWNCYXNlS2V5bWFwIDogcGNCYXNlS2V5bWFwO1xuXG5leHBvcnQgeyBhdXRvSm9pbiwgYmFzZUtleW1hcCwgY2hhaW5Db21tYW5kcywgY3JlYXRlUGFyYWdyYXBoTmVhciwgZGVsZXRlU2VsZWN0aW9uLCBleGl0Q29kZSwgam9pbkJhY2t3YXJkLCBqb2luRG93biwgam9pbkZvcndhcmQsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCwgam9pblRleHRibG9ja0ZvcndhcmQsIGpvaW5VcCwgbGlmdCwgbGlmdEVtcHR5QmxvY2ssIG1hY0Jhc2VLZXltYXAsIG5ld2xpbmVJbkNvZGUsIHBjQmFzZUtleW1hcCwgc2VsZWN0QWxsLCBzZWxlY3ROb2RlQmFja3dhcmQsIHNlbGVjdE5vZGVGb3J3YXJkLCBzZWxlY3RQYXJlbnROb2RlLCBzZWxlY3RUZXh0YmxvY2tFbmQsIHNlbGVjdFRleHRibG9ja1N0YXJ0LCBzZXRCbG9ja1R5cGUsIHNwbGl0QmxvY2ssIHNwbGl0QmxvY2tBcywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4iXSwibmFtZXMiOlsibGlmdFRhcmdldCIsInJlcGxhY2VTdGVwIiwiUmVwbGFjZVN0ZXAiLCJjYW5Kb2luIiwiam9pblBvaW50IiwiY2FuU3BsaXQiLCJSZXBsYWNlQXJvdW5kU3RlcCIsImZpbmRXcmFwcGluZyIsIlNsaWNlIiwiRnJhZ21lbnQiLCJOb2RlU2VsZWN0aW9uIiwiU2VsZWN0aW9uIiwiVGV4dFNlbGVjdGlvbiIsIkFsbFNlbGVjdGlvbiIsImRlbGV0ZVNlbGVjdGlvbiIsInN0YXRlIiwiZGlzcGF0Y2giLCJzZWxlY3Rpb24iLCJlbXB0eSIsInRyIiwic2Nyb2xsSW50b1ZpZXciLCJhdEJsb2NrU3RhcnQiLCJ2aWV3IiwiJGN1cnNvciIsImVuZE9mVGV4dGJsb2NrIiwicGFyZW50T2Zmc2V0Iiwiam9pbkJhY2t3YXJkIiwiJGN1dCIsImZpbmRDdXRCZWZvcmUiLCJyYW5nZSIsImJsb2NrUmFuZ2UiLCJ0YXJnZXQiLCJsaWZ0IiwiYmVmb3JlIiwibm9kZUJlZm9yZSIsInR5cGUiLCJzcGVjIiwiaXNvbGF0aW5nIiwiZGVsZXRlQmFycmllciIsInBhcmVudCIsImNvbnRlbnQiLCJzaXplIiwidGV4dGJsb2NrQXQiLCJpc1NlbGVjdGFibGUiLCJkZWxTdGVwIiwiZG9jIiwiYWZ0ZXIiLCJzbGljZSIsInRvIiwiZnJvbSIsInN0ZXAiLCJzZXRTZWxlY3Rpb24iLCJmaW5kRnJvbSIsInJlc29sdmUiLCJtYXBwaW5nIiwibWFwIiwicG9zIiwiY3JlYXRlIiwibm9kZVNpemUiLCJpc0F0b20iLCJkZXB0aCIsImRlbGV0ZSIsImpvaW5UZXh0YmxvY2tCYWNrd2FyZCIsImpvaW5UZXh0YmxvY2tzQXJvdW5kIiwiam9pblRleHRibG9ja0ZvcndhcmQiLCJhdEJsb2NrRW5kIiwiZmluZEN1dEFmdGVyIiwiYmVmb3JlVGV4dCIsImJlZm9yZVBvcyIsImlzVGV4dGJsb2NrIiwiY2hpbGQiLCJsYXN0Q2hpbGQiLCJub2RlQWZ0ZXIiLCJhZnRlclRleHQiLCJhZnRlclBvcyIsImZpcnN0Q2hpbGQiLCJub2RlIiwic2lkZSIsIm9ubHkiLCJzY2FuIiwiY2hpbGRDb3VudCIsInNlbGVjdE5vZGVCYWNrd2FyZCIsIiRoZWFkIiwiJHBvcyIsImkiLCJpbmRleCIsImpvaW5Gb3J3YXJkIiwic2VsZWN0Tm9kZUZvcndhcmQiLCJqb2luVXAiLCJzZWwiLCJub2RlU2VsIiwicG9pbnQiLCJqb2luIiwiam9pbkRvd24iLCIkZnJvbSIsIiR0byIsIm5ld2xpbmVJbkNvZGUiLCIkYW5jaG9yIiwiY29kZSIsInNhbWVQYXJlbnQiLCJpbnNlcnRUZXh0IiwiZGVmYXVsdEJsb2NrQXQiLCJtYXRjaCIsImVkZ2VDb3VudCIsImVkZ2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiZXhpdENvZGUiLCJhYm92ZSIsImluZGV4QWZ0ZXIiLCJjb250ZW50TWF0Y2hBdCIsImNhblJlcGxhY2VXaXRoIiwicmVwbGFjZVdpdGgiLCJjcmVhdGVBbmRGaWxsIiwibmVhciIsImNyZWF0ZVBhcmFncmFwaE5lYXIiLCJpbmxpbmVDb250ZW50IiwiaW5zZXJ0IiwibGlmdEVtcHR5QmxvY2siLCJlbmQiLCJzcGxpdCIsInNwbGl0QmxvY2tBcyIsInNwbGl0Tm9kZSIsImlzQmxvY2siLCJhdEVuZCIsImRlZmx0Iiwic3BsaXRUeXBlIiwidHlwZXMiLCJ1bmRlZmluZWQiLCJjYW4iLCJmaXJzdCIsIiRmaXJzdCIsInNldE5vZGVNYXJrdXAiLCJzcGxpdEJsb2NrIiwic3BsaXRCbG9ja0tlZXBNYXJrcyIsIm1hcmtzIiwic3RvcmVkTWFya3MiLCJlbnN1cmVNYXJrcyIsInNlbGVjdFBhcmVudE5vZGUiLCJzYW1lIiwic2hhcmVkRGVwdGgiLCJzZWxlY3RBbGwiLCJqb2luTWF5YmVDbGVhciIsImNvbXBhdGlibGVDb250ZW50IiwiY2FuUmVwbGFjZSIsImNsZWFySW5jb21wYXRpYmxlIiwiY29ubiIsImNhbkRlbEFmdGVyIiwibWF0Y2hUeXBlIiwidmFsaWRFbmQiLCJ3cmFwIiwibGVuZ3RoIiwiY29weSIsImpvaW5BdCIsInNlbEFmdGVyIiwiYXQiLCJwdXNoIiwiYWZ0ZXJEZXB0aCIsInNlbGVjdFRleHRibG9ja1NpZGUiLCJpc0lubGluZSIsInN0YXJ0Iiwic2VsZWN0VGV4dGJsb2NrU3RhcnQiLCJzZWxlY3RUZXh0YmxvY2tFbmQiLCJ3cmFwSW4iLCJub2RlVHlwZSIsImF0dHJzIiwid3JhcHBpbmciLCJzZXRCbG9ja1R5cGUiLCJhcHBsaWNhYmxlIiwicmFuZ2VzIiwibm9kZXNCZXR3ZWVuIiwiaGFzTWFya3VwIiwibWFya0FwcGxpZXMiLCJhbGxvd3NNYXJrVHlwZSIsInRvZ2dsZU1hcmsiLCJtYXJrVHlwZSIsImlzSW5TZXQiLCJyZW1vdmVTdG9yZWRNYXJrIiwiYWRkU3RvcmVkTWFyayIsImhhcyIsInJhbmdlSGFzTWFyayIsInJlbW92ZU1hcmsiLCJzcGFjZVN0YXJ0IiwiaXNUZXh0IiwiZXhlYyIsInRleHQiLCJzcGFjZUVuZCIsImFkZE1hcmsiLCJ3cmFwRGlzcGF0Y2hGb3JKb2luIiwiaXNKb2luYWJsZSIsImlzR2VuZXJpYyIsIm1hcHMiLCJqIiwiZm9yRWFjaCIsIl9zIiwiX2UiLCJqb2luYWJsZSIsIm1heWJlQ2hpbGQiLCJpbmRleE9mIiwic29ydCIsImEiLCJiIiwiYXV0b0pvaW4iLCJjb21tYW5kIiwiQXJyYXkiLCJpc0FycmF5IiwibmFtZSIsImNoYWluQ29tbWFuZHMiLCJjb21tYW5kcyIsImJhY2tzcGFjZSIsImRlbCIsInBjQmFzZUtleW1hcCIsIm1hY0Jhc2VLZXltYXAiLCJrZXkiLCJtYWMiLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwicGxhdGZvcm0iLCJvcyIsImJhc2VLZXltYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-commands/dist/index.js\n");

/***/ })

};
;