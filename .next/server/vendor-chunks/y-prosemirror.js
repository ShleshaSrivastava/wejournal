"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/y-prosemirror";
exports.ids = ["vendor-chunks/y-prosemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/y-prosemirror/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/y-prosemirror/src/lib.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutePositionToRelativePosition: () => (/* binding */ absolutePositionToRelativePosition),\n/* harmony export */   prosemirrorJSONToYDoc: () => (/* binding */ prosemirrorJSONToYDoc),\n/* harmony export */   prosemirrorJSONToYXmlFragment: () => (/* binding */ prosemirrorJSONToYXmlFragment),\n/* harmony export */   prosemirrorToYDoc: () => (/* binding */ prosemirrorToYDoc),\n/* harmony export */   prosemirrorToYXmlFragment: () => (/* binding */ prosemirrorToYXmlFragment),\n/* harmony export */   relativePositionToAbsolutePosition: () => (/* binding */ relativePositionToAbsolutePosition),\n/* harmony export */   setMeta: () => (/* binding */ setMeta),\n/* harmony export */   yDocToProsemirror: () => (/* binding */ yDocToProsemirror),\n/* harmony export */   yDocToProsemirrorJSON: () => (/* binding */ yDocToProsemirrorJSON),\n/* harmony export */   yXmlFragmentToProsemirror: () => (/* binding */ yXmlFragmentToProsemirror),\n/* harmony export */   yXmlFragmentToProsemirrorJSON: () => (/* binding */ yXmlFragmentToProsemirrorJSON)\n/* harmony export */ });\n/* harmony import */ var _plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n // eslint-disable-line\n\n\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */ /**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */ let viewsToUpdate = null;\nconst updateMetas = ()=>{\n    const ups = /** @type {Map<EditorView, Map<any, any>>} */ viewsToUpdate;\n    viewsToUpdate = null;\n    ups.forEach((metas, view)=>{\n        const tr = view.state.tr;\n        const syncState = _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state);\n        if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n            metas.forEach((val, key)=>{\n                tr.setMeta(key, val);\n            });\n            view.dispatch(tr);\n        }\n    });\n};\nconst setMeta = (view, key, value)=>{\n    if (!viewsToUpdate) {\n        viewsToUpdate = new Map();\n        lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__.timeout(0, updateMetas);\n    }\n    lib0_map__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(viewsToUpdate, view, lib0_map__WEBPACK_IMPORTED_MODULE_2__.create).set(key, value);\n};\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */ const absolutePositionToRelativePosition = (pos, type, mapping)=>{\n    if (pos === 0) {\n        return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, 0);\n    }\n    /**\n   * @type {any}\n   */ let n = type._first === null ? null : /** @type {Y.ContentType} */ type._first.content.type;\n    while(n !== null && type !== n){\n        if (n instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            if (n._length >= pos) {\n                return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(n, pos);\n            } else {\n                pos -= n._length;\n            }\n            if (n._item !== null && n._item.next !== null) {\n                n = /** @type {Y.ContentType} */ n._item.next.content.type;\n            } else {\n                do {\n                    n = n._item === null ? null : n._item.parent;\n                    pos--;\n                }while (n !== type && n !== null && n._item !== null && n._item.next === null);\n                if (n !== null && n !== type) {\n                    // @ts-gnore we know that n.next !== null because of above loop conditition\n                    n = n._item === null ? null : /** @type {Y.ContentType} */ /** @type Y.Item */ n._item.next.content.type;\n                }\n            }\n        } else {\n            const pNodeSize = /** @type {any} */ (mapping.get(n) || {\n                nodeSize: 0\n            }).nodeSize;\n            if (n._first !== null && pos < pNodeSize) {\n                n = /** @type {Y.ContentType} */ n._first.content.type;\n                pos--;\n            } else {\n                if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n                    // edge case, should end in this paragraph\n                    return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null);\n                }\n                pos -= pNodeSize;\n                if (n._item !== null && n._item.next !== null) {\n                    n = /** @type {Y.ContentType} */ n._item.next.content.type;\n                } else {\n                    if (pos === 0) {\n                        // set to end of n.parent\n                        n = n._item === null ? n : n._item.parent;\n                        return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null);\n                    }\n                    do {\n                        n = /** @type {Y.Item} */ n._item.parent;\n                        pos--;\n                    }while (n !== type && /** @type {Y.Item} */ n._item.next === null);\n                    // if n is null at this point, we have an unexpected case\n                    if (n !== type) {\n                        // We know that n._item.next is defined because of above loop condition\n                        n = /** @type {Y.ContentType} */ /** @type {Y.Item} */ /** @type {Y.Item} */ n._item.next.content.type;\n                    }\n                }\n            }\n        }\n        if (n === null) {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase();\n        }\n        if (pos === 0 && n.constructor !== yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText && n !== type) {\n            return createRelativePosition(n._item.parent, n._item);\n        }\n    }\n    return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, type._length);\n};\nconst createRelativePosition = (type, item)=>{\n    let typeid = null;\n    let tname = null;\n    if (type._item === null) {\n        tname = yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(type);\n    } else {\n        typeid = yjs__WEBPACK_IMPORTED_MODULE_3__.createID(type._item.id.client, type._item.id.clock);\n    }\n    return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(typeid, tname, item.id);\n};\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */ const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping)=>{\n    const decodedPos = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(relPos, y);\n    if (decodedPos === null || decodedPos.type !== documentType && !yjs__WEBPACK_IMPORTED_MODULE_3__.isParentOf(documentType, decodedPos.type._item)) {\n        return null;\n    }\n    let type = decodedPos.type;\n    let pos = 0;\n    if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n        pos = decodedPos.index;\n    } else if (type._item === null || !type._item.deleted) {\n        let n = type._first;\n        let i = 0;\n        while(i < type._length && i < decodedPos.index && n !== null){\n            if (!n.deleted) {\n                const t = /** @type {Y.ContentType} */ n.content.type;\n                i++;\n                if (t instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n                    pos += t._length;\n                } else {\n                    pos += /** @type {any} */ mapping.get(t).nodeSize;\n                }\n            }\n            n = /** @type {Y.Item} */ n.right;\n        }\n        pos += 1 // increase because we go out of n\n        ;\n    }\n    while(type !== documentType && type._item !== null){\n        // @ts-ignore\n        const parent = type._item.parent;\n        // @ts-ignore\n        if (parent._item === null || !parent._item.deleted) {\n            pos += 1 // the start tag\n            ;\n            let n = /** @type {Y.AbstractType} */ parent._first;\n            // now iterate until we found type\n            while(n !== null){\n                const contentType = /** @type {Y.ContentType} */ n.content.type;\n                if (contentType === type) {\n                    break;\n                }\n                if (!n.deleted) {\n                    if (contentType instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n                        pos += contentType._length;\n                    } else {\n                        pos += /** @type {any} */ mapping.get(contentType).nodeSize;\n                    }\n                }\n                n = n.right;\n            }\n        }\n        type = /** @type {Y.AbstractType} */ parent;\n    }\n    return pos - 1 // we don't count the most outer tag, because it is a fragment\n    ;\n};\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */ function prosemirrorToYDoc(doc, xmlFragment = \"prosemirror\") {\n    const ydoc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();\n    const type = /** @type {Y.XmlFragment} */ ydoc.get(xmlFragment, yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment);\n    if (!type.doc) {\n        return ydoc;\n    }\n    prosemirrorToYXmlFragment(doc, type);\n    return type.doc;\n}\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */ function prosemirrorToYXmlFragment(doc, xmlFragment) {\n    const type = xmlFragment || new yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment();\n    const ydoc = type.doc ? type.doc : {\n        transact: (transaction)=>transaction(undefined)\n    };\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.updateYFragment)(ydoc, type, doc, new Map());\n    return type;\n}\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */ function prosemirrorJSONToYDoc(schema, state, xmlFragment = \"prosemirror\") {\n    const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n    return prosemirrorToYDoc(doc, xmlFragment);\n}\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */ function prosemirrorJSONToYXmlFragment(schema, state, xmlFragment) {\n    const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n    return prosemirrorToYXmlFragment(doc, xmlFragment);\n}\n/**\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */ function yDocToProsemirror(schema, ydoc) {\n    const state = yDocToProsemirrorJSON(ydoc);\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n}\n/**\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */ function yXmlFragmentToProsemirror(schema, xmlFragment) {\n    const state = yXmlFragmentToProsemirrorJSON(xmlFragment);\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n}\n/**\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */ function yDocToProsemirrorJSON(ydoc, xmlFragment = \"prosemirror\") {\n    return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment));\n}\n/**\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */ function yXmlFragmentToProsemirrorJSON(xmlFragment) {\n    const items = xmlFragment.toArray();\n    function serialize(item) {\n        /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */ let response;\n        // TODO: Must be a better way to detect text nodes than this\n        if (!item.nodeName) {\n            const delta = item.toDelta();\n            response = delta.map((d)=>{\n                const text = {\n                    type: \"text\",\n                    text: d.insert\n                };\n                if (d.attributes) {\n                    text.marks = Object.keys(d.attributes).map((type)=>{\n                        const attrs = d.attributes[type];\n                        const mark = {\n                            type\n                        };\n                        if (Object.keys(attrs)) {\n                            mark.attrs = attrs;\n                        }\n                        return mark;\n                    });\n                }\n                return text;\n            });\n        } else {\n            response = {\n                type: item.nodeName\n            };\n            const attrs = item.getAttributes();\n            if (Object.keys(attrs).length) {\n                response.attrs = attrs;\n            }\n            const children = item.toArray();\n            if (children.length) {\n                response.content = children.map(serialize).flat();\n            }\n        }\n        return response;\n    }\n    return {\n        type: \"doc\",\n        content: items.map(serialize)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRCxDQUFDLHNCQUFzQjtBQUMvQjtBQUMxQjtBQUNxQixDQUFDLHNCQUFzQjtBQUNwQixDQUFDLHNCQUFzQjtBQUNwQztBQUNKO0FBQ1k7QUFFM0M7OztDQUdDLEdBRUQ7Ozs7O0NBS0MsR0FDRCxJQUFJUyxnQkFBZ0I7QUFFcEIsTUFBTUMsY0FBYztJQUNsQixNQUFNQyxNQUFNLDJDQUEyQyxHQUFJRjtJQUMzREEsZ0JBQWdCO0lBQ2hCRSxJQUFJQyxPQUFPLENBQUMsQ0FBQ0MsT0FBT0M7UUFDbEIsTUFBTUMsS0FBS0QsS0FBS0UsS0FBSyxDQUFDRCxFQUFFO1FBQ3hCLE1BQU1FLFlBQVloQiw0REFBY0EsQ0FBQ2lCLFFBQVEsQ0FBQ0osS0FBS0UsS0FBSztRQUNwRCxJQUFJQyxhQUFhQSxVQUFVRSxPQUFPLElBQUksQ0FBQ0YsVUFBVUUsT0FBTyxDQUFDQyxXQUFXLEVBQUU7WUFDcEVQLE1BQU1ELE9BQU8sQ0FBQyxDQUFDUyxLQUFLQztnQkFDbEJQLEdBQUdRLE9BQU8sQ0FBQ0QsS0FBS0Q7WUFDbEI7WUFDQVAsS0FBS1UsUUFBUSxDQUFDVDtRQUNoQjtJQUNGO0FBQ0Y7QUFFTyxNQUFNUSxVQUFVLENBQUNULE1BQU1RLEtBQUtHO0lBQ2pDLElBQUksQ0FBQ2hCLGVBQWU7UUFDbEJBLGdCQUFnQixJQUFJaUI7UUFDcEJsQixtREFBaUIsQ0FBQyxHQUFHRTtJQUN2QjtJQUNBSCxvREFBa0IsQ0FBQ0UsZUFBZUssTUFBTVAsNENBQVUsRUFBRXVCLEdBQUcsQ0FBQ1IsS0FBS0c7QUFDL0QsRUFBQztBQUVEOzs7Ozs7O0NBT0MsR0FDTSxNQUFNTSxxQ0FBcUMsQ0FBQ0MsS0FBS0MsTUFBTUM7SUFDNUQsSUFBSUYsUUFBUSxHQUFHO1FBQ2IsT0FBTzlCLG9FQUFxQyxDQUFDK0IsTUFBTTtJQUNyRDtJQUNBOztHQUVD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VSxFQUFFO29CQUNoQkYsS0FBS0csS0FBSyxHQUFHQyxPQUFPQyxJQUFJLENBQUNOLEVBQUVHLFVBQVUsRUFBRTlGLEdBQUcsQ0FBQyxDQUFDMEI7d0JBQzFDLE1BQU13RSxRQUFRUCxFQUFFRyxVQUFVLENBQUNwRSxLQUFLO3dCQUNoQyxNQUFNeUUsT0FBTzs0QkFDWHpFO3dCQUNGO3dCQUVBLElBQUlzRSxPQUFPQyxJQUFJLENBQUNDLFFBQVE7NEJBQ3RCQyxLQUFLRCxLQUFLLEdBQUdBO3dCQUNmO3dCQUVBLE9BQU9DO29CQUNUO2dCQUNGO2dCQUNBLE9BQU9QO1lBQ1Q7UUFDRixPQUFPO1lBQ0xMLFdBQVc7Z0JBQ1Q3RCxNQUFNb0IsS0FBSzBDLFFBQVE7WUFDckI7WUFFQSxNQUFNVSxRQUFRcEQsS0FBS3NELGFBQWE7WUFDaEMsSUFBSUosT0FBT0MsSUFBSSxDQUFDQyxPQUFPRyxNQUFNLEVBQUU7Z0JBQzdCZCxTQUFTVyxLQUFLLEdBQUdBO1lBQ25CO1lBRUEsTUFBTUksV0FBV3hELEtBQUt1QyxPQUFPO1lBQzdCLElBQUlpQixTQUFTRCxNQUFNLEVBQUU7Z0JBQ25CZCxTQUFTeEQsT0FBTyxHQUFHdUUsU0FBU3RHLEdBQUcsQ0FBQ3NGLFdBQVdpQixJQUFJO1lBQ2pEO1FBQ0Y7UUFFQSxPQUFPaEI7SUFDVDtJQUVBLE9BQU87UUFDTDdELE1BQU07UUFDTkssU0FBU3FELE1BQU1wRixHQUFHLENBQUNzRjtJQUNyQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2Utam91cm5hbC8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9saWIuanM/MzRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cGRhdGVZRnJhZ21lbnQgfSBmcm9tICcuL3BsdWdpbnMvc3luYy1wbHVnaW4uanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9wbHVnaW5zL2tleXMuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBOb2RlLCBTY2hlbWEgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCcgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcblxuLyoqXG4gKiBFaXRoZXIgYSBub2RlIGlmIHR5cGUgaXMgWVhtbEVsZW1lbnQgb3IgYW4gQXJyYXkgb2YgdGV4dCBub2RlcyBpZiBZWG1sVGV4dFxuICogQHR5cGVkZWYge01hcDxZLkFic3RyYWN0VHlwZSwgTm9kZSB8IEFycmF5PE5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBJcyBudWxsIGlmIG5vIHRpbWVvdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBJcyBkZWZpbmVkIGlmIGEgdGltZW91dCBpcyBpbiBwcm9ncmVzcy5cbiAqIE1hcHMgZnJvbSB2aWV3XG4gKiBAdHlwZSB7TWFwPEVkaXRvclZpZXcsIE1hcDxhbnksIGFueT4+fG51bGx9XG4gKi9cbmxldCB2aWV3c1RvVXBkYXRlID0gbnVsbFxuXG5jb25zdCB1cGRhdGVNZXRhcyA9ICgpID0+IHtcbiAgY29uc3QgdXBzID0gLyoqIEB0eXBlIHtNYXA8RWRpdG9yVmlldywgTWFwPGFueSwgYW55Pj59ICovICh2aWV3c1RvVXBkYXRlKVxuICB2aWV3c1RvVXBkYXRlID0gbnVsbFxuICB1cHMuZm9yRWFjaCgobWV0YXMsIHZpZXcpID0+IHtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHJcbiAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgIGlmIChzeW5jU3RhdGUgJiYgc3luY1N0YXRlLmJpbmRpbmcgJiYgIXN5bmNTdGF0ZS5iaW5kaW5nLmlzRGVzdHJveWVkKSB7XG4gICAgICBtZXRhcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgICAgICB0ci5zZXRNZXRhKGtleSwgdmFsKVxuICAgICAgfSlcbiAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgc2V0TWV0YSA9ICh2aWV3LCBrZXksIHZhbHVlKSA9PiB7XG4gIGlmICghdmlld3NUb1VwZGF0ZSkge1xuICAgIHZpZXdzVG9VcGRhdGUgPSBuZXcgTWFwKClcbiAgICBldmVudGxvb3AudGltZW91dCgwLCB1cGRhdGVNZXRhcylcbiAgfVxuICBtYXAuc2V0SWZVbmRlZmluZWQodmlld3NUb1VwZGF0ZSwgdmlldywgbWFwLmNyZWF0ZSkuc2V0KGtleSwgdmFsdWUpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIFByb3NlbWlycm9yIGJhc2VkIGFic29sdXRlIHBvc2l0aW9uIHRvIGEgWWpzIEN1cnNvciAocmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIFlqcyBtb2RlbCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB0eXBlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7YW55fSByZWxhdGl2ZSBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3QgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiA9IChwb3MsIHR5cGUsIG1hcHBpbmcpID0+IHtcbiAgaWYgKHBvcyA9PT0gMCkge1xuICAgIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIDApXG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgbiA9IHR5cGUuX2ZpcnN0ID09PSBudWxsID8gbnVsbCA6IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKHR5cGUuX2ZpcnN0LmNvbnRlbnQpLnR5cGVcbiAgd2hpbGUgKG4gIT09IG51bGwgJiYgdHlwZSAhPT0gbikge1xuICAgIGlmIChuIGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICBpZiAobi5fbGVuZ3RoID49IHBvcykge1xuICAgICAgICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleChuLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgLT0gbi5fbGVuZ3RoXG4gICAgICB9XG4gICAgICBpZiAobi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2l0ZW0ubmV4dC5jb250ZW50KS50eXBlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbiA9IG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogbi5faXRlbS5wYXJlbnRcbiAgICAgICAgICBwb3MtLVxuICAgICAgICB9IHdoaWxlIChuICE9PSB0eXBlICYmIG4gIT09IG51bGwgJiYgbi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgPT09IG51bGwpXG4gICAgICAgIGlmIChuICE9PSBudWxsICYmIG4gIT09IHR5cGUpIHtcbiAgICAgICAgICAvLyBAdHMtZ25vcmUgd2Uga25vdyB0aGF0IG4ubmV4dCAhPT0gbnVsbCBiZWNhdXNlIG9mIGFib3ZlIGxvb3AgY29uZGl0aXRpb25cbiAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUgWS5JdGVtICovIChuLl9pdGVtLm5leHQpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwTm9kZVNpemUgPSAvKiogQHR5cGUge2FueX0gKi8gKG1hcHBpbmcuZ2V0KG4pIHx8IHsgbm9kZVNpemU6IDAgfSkubm9kZVNpemVcbiAgICAgIGlmIChuLl9maXJzdCAhPT0gbnVsbCAmJiBwb3MgPCBwTm9kZVNpemUpIHtcbiAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2ZpcnN0LmNvbnRlbnQpLnR5cGVcbiAgICAgICAgcG9zLS1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwb3MgPT09IDEgJiYgbi5fbGVuZ3RoID09PSAwICYmIHBOb2RlU2l6ZSA+IDEpIHtcbiAgICAgICAgICAvLyBlZGdlIGNhc2UsIHNob3VsZCBlbmQgaW4gdGhpcyBwYXJhZ3JhcGhcbiAgICAgICAgICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IG4uX2l0ZW0uaWQsIG4uX2l0ZW0gPT09IG51bGwgPyBZLmZpbmRSb290VHlwZUtleShuKSA6IG51bGwsIG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgcG9zIC09IHBOb2RlU2l6ZVxuICAgICAgICBpZiAobi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5faXRlbS5uZXh0LmNvbnRlbnQpLnR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzZXQgdG8gZW5kIG9mIG4ucGFyZW50XG4gICAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG4gOiBuLl9pdGVtLnBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24obi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiBuLl9pdGVtLmlkLCBuLl9pdGVtID09PSBudWxsID8gWS5maW5kUm9vdFR5cGVLZXkobikgOiBudWxsLCBudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLl9pdGVtKS5wYXJlbnRcbiAgICAgICAgICAgIHBvcy0tXG4gICAgICAgICAgfSB3aGlsZSAobiAhPT0gdHlwZSAmJiAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLm5leHQgPT09IG51bGwpXG4gICAgICAgICAgLy8gaWYgbiBpcyBudWxsIGF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgYW4gdW5leHBlY3RlZCBjYXNlXG4gICAgICAgICAgaWYgKG4gIT09IHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCBuLl9pdGVtLm5leHQgaXMgZGVmaW5lZCBiZWNhdXNlIG9mIGFib3ZlIGxvb3AgY29uZGl0aW9uXG4gICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLm5leHQpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKHBvcyA9PT0gMCAmJiBuLmNvbnN0cnVjdG9yICE9PSBZLlhtbFRleHQgJiYgbiAhPT0gdHlwZSkgeyAvLyBUT0RPOiBzZXQgdG8gPD0gMFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24obi5faXRlbS5wYXJlbnQsIG4uX2l0ZW0pXG4gICAgfVxuICB9XG4gIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIHR5cGUuX2xlbmd0aClcbn1cblxuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtKSA9PiB7XG4gIGxldCB0eXBlaWQgPSBudWxsXG4gIGxldCB0bmFtZSA9IG51bGxcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IFkuZmluZFJvb3RUeXBlS2V5KHR5cGUpXG4gIH0gZWxzZSB7XG4gICAgdHlwZWlkID0gWS5jcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jaylcbiAgfVxuICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbih0eXBlaWQsIHRuYW1lLCBpdGVtLmlkKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5Eb2N9IHlcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gZG9jdW1lbnRUeXBlIFRvcCBsZXZlbCB0eXBlIHRoYXQgaXMgYm91bmQgdG8gcFZpZXdcbiAqIEBwYXJhbSB7YW55fSByZWxQb3MgRW5jb2RlZCBZanMgYmFzZWQgcmVsYXRpdmUgcG9zaXRpb25cbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtudWxsfG51bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24gPSAoeSwgZG9jdW1lbnRUeXBlLCByZWxQb3MsIG1hcHBpbmcpID0+IHtcbiAgY29uc3QgZGVjb2RlZFBvcyA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKHJlbFBvcywgeSlcbiAgaWYgKGRlY29kZWRQb3MgPT09IG51bGwgfHwgKGRlY29kZWRQb3MudHlwZSAhPT0gZG9jdW1lbnRUeXBlICYmICFZLmlzUGFyZW50T2YoZG9jdW1lbnRUeXBlLCBkZWNvZGVkUG9zLnR5cGUuX2l0ZW0pKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbGV0IHR5cGUgPSBkZWNvZGVkUG9zLnR5cGVcbiAgbGV0IHBvcyA9IDBcbiAgaWYgKHR5cGUuY29uc3RydWN0b3IgPT09IFkuWG1sVGV4dCkge1xuICAgIHBvcyA9IGRlY29kZWRQb3MuaW5kZXhcbiAgfSBlbHNlIGlmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICBsZXQgbiA9IHR5cGUuX2ZpcnN0XG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGkgPCB0eXBlLl9sZW5ndGggJiYgaSA8IGRlY29kZWRQb3MuaW5kZXggJiYgbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdCA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpKytcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgICAgICBwb3MgKz0gdC5fbGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQodCkpLm5vZGVTaXplXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4ucmlnaHQpXG4gICAgfVxuICAgIHBvcyArPSAxIC8vIGluY3JlYXNlIGJlY2F1c2Ugd2UgZ28gb3V0IG9mIG5cbiAgfVxuICB3aGlsZSAodHlwZSAhPT0gZG9jdW1lbnRUeXBlICYmIHR5cGUuX2l0ZW0gIT09IG51bGwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcGFyZW50ID0gdHlwZS5faXRlbS5wYXJlbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHBhcmVudC5faXRlbSA9PT0gbnVsbCB8fCAhcGFyZW50Ll9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgIHBvcyArPSAxIC8vIHRoZSBzdGFydCB0YWdcbiAgICAgIGxldCBuID0gLyoqIEB0eXBlIHtZLkFic3RyYWN0VHlwZX0gKi8gKHBhcmVudCkuX2ZpcnN0XG4gICAgICAvLyBub3cgaXRlcmF0ZSB1bnRpbCB3ZSBmb3VuZCB0eXBlXG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlIGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICAgICAgICBwb3MgKz0gY29udGVudFR5cGUuX2xlbmd0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gLyoqIEB0eXBlIHthbnl9ICovIChtYXBwaW5nLmdldChjb250ZW50VHlwZSkpLm5vZGVTaXplXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4gPSBuLnJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge1kuQWJzdHJhY3RUeXBlfSAqLyAocGFyZW50KVxuICB9XG4gIHJldHVybiBwb3MgLSAxIC8vIHdlIGRvbid0IGNvdW50IHRoZSBtb3N0IG91dGVyIHRhZywgYmVjYXVzZSBpdCBpcyBhIGZyYWdtZW50XG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFByb3NlbWlycm9yIERvYyBOb2RlIGludG8gYSBZLkRvYy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBAcGFyYW0ge05vZGV9IGRvY1xuICogQHBhcmFtIHtzdHJpbmd9IHhtbEZyYWdtZW50XG4gKiBAcmV0dXJuIHtZLkRvY31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3NlbWlycm9yVG9ZRG9jIChkb2MsIHhtbEZyYWdtZW50ID0gJ3Byb3NlbWlycm9yJykge1xuICBjb25zdCB5ZG9jID0gbmV3IFkuRG9jKClcbiAgY29uc3QgdHlwZSA9IC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKHlkb2MuZ2V0KHhtbEZyYWdtZW50LCBZLlhtbEZyYWdtZW50KSlcbiAgaWYgKCF0eXBlLmRvYykge1xuICAgIHJldHVybiB5ZG9jXG4gIH1cblxuICBwcm9zZW1pcnJvclRvWVhtbEZyYWdtZW50KGRvYywgdHlwZSlcbiAgcmV0dXJuIHR5cGUuZG9jXG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gdXBkYXRlIGFuIGVtcHR5IFkuWG1sRnJhZ21lbnQgd2l0aCBjb250ZW50IGZyb20gYSBQcm9zZW1pcnJvciBEb2MgTm9kZS5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBOb3RlOiBUaGUgWS5YbWxGcmFnbWVudCBkb2VzIG5vdCBuZWVkIHRvIGJlIHBhcnQgb2YgYSBZLkRvYyBkb2N1bWVudCBhdCB0aGUgdGltZSB0aGF0IHRoaXNcbiAqIG1ldGhvZCBpcyBjYWxsZWQsIGJ1dCBpdCBtdXN0IGJlIGFkZGVkIGJlZm9yZSBhbnkgb3RoZXIgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIG9uIGl0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZG9jIHByb3NlbWlycm9yIGRvY3VtZW50LlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSBbeG1sRnJhZ21lbnRdIElmIHN1cHBsaWVkLCBhbiB4bWwgZnJhZ21lbnQgdG8gYmVcbiAqICAgcG9wdWxhdGVkIGZyb20gdGhlIHByb3NlbWlycm9yIHN0YXRlOyBvdGhlcndpc2UgYSBuZXcgWG1sRnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybiB7WS5YbWxGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3NlbWlycm9yVG9ZWG1sRnJhZ21lbnQgKGRvYywgeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgdHlwZSA9IHhtbEZyYWdtZW50IHx8IG5ldyBZLlhtbEZyYWdtZW50KClcbiAgY29uc3QgeWRvYyA9IHR5cGUuZG9jID8gdHlwZS5kb2MgOiB7IHRyYW5zYWN0OiAodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uKHVuZGVmaW5lZCkgfVxuICB1cGRhdGVZRnJhZ21lbnQoeWRvYywgdHlwZSwgZG9jLCBuZXcgTWFwKCkpXG4gIHJldHVybiB0eXBlXG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBQcm9zZW1pcnJvciBjb21wYXRpYmxlIEpTT04gaW50byBhIFkuRG9jLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7YW55fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHhtbEZyYWdtZW50XG4gKiBAcmV0dXJuIHtZLkRvY31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3NlbWlycm9ySlNPTlRvWURvYyAoc2NoZW1hLCBzdGF0ZSwgeG1sRnJhZ21lbnQgPSAncHJvc2VtaXJyb3InKSB7XG4gIGNvbnN0IGRvYyA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbiAgcmV0dXJuIHByb3NlbWlycm9yVG9ZRG9jKGRvYywgeG1sRnJhZ21lbnQpXG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBQcm9zZW1pcnJvciBjb21wYXRpYmxlIEpTT04gdG8gYSBZLlhtbEZyYWdtZW50XG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IFt4bWxGcmFnbWVudF0gSWYgc3VwcGxpZWQsIGFuIHhtbCBmcmFnbWVudCB0byBiZVxuICogICBwb3B1bGF0ZWQgZnJvbSB0aGUgcHJvc2VtaXJyb3Igc3RhdGU7IG90aGVyd2lzZSBhIG5ldyBYbWxGcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtZLlhtbEZyYWdtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JKU09OVG9ZWG1sRnJhZ21lbnQgKHNjaGVtYSwgc3RhdGUsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IGRvYyA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbiAgcmV0dXJuIHByb3NlbWlycm9yVG9ZWG1sRnJhZ21lbnQoZG9jLCB4bWxGcmFnbWVudClcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gYSBQcm9zZW1pcnJvciBEb2Mgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1kuRG9jfSB5ZG9jXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24geURvY1RvUHJvc2VtaXJyb3IgKHNjaGVtYSwgeWRvYykge1xuICBjb25zdCBzdGF0ZSA9IHlEb2NUb1Byb3NlbWlycm9ySlNPTih5ZG9jKVxuICByZXR1cm4gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgYSBZLlhtbEZyYWdtZW50IHRvIGEgUHJvc2VtaXJyb3IgRG9jIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlYbWxGcmFnbWVudFRvUHJvc2VtaXJyb3IgKHNjaGVtYSwgeG1sRnJhZ21lbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTih4bWxGcmFnbWVudClcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OLlxuICpcbiAqIEBwYXJhbSB7WS5Eb2N9IHlkb2NcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlEb2NUb1Byb3NlbWlycm9ySlNPTiAoXG4gIHlkb2MsXG4gIHhtbEZyYWdtZW50ID0gJ3Byb3NlbWlycm9yJ1xuKSB7XG4gIHJldHVybiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTih5ZG9jLmdldFhtbEZyYWdtZW50KHhtbEZyYWdtZW50KSlcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnQgVGhlIGZyYWdtZW50LCB3aGljaCBtdXN0IGJlIHBhcnQgb2YgYSBZLkRvYy5cbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTiAoeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgaXRlbXMgPSB4bWxGcmFnbWVudC50b0FycmF5KClcblxuICBmdW5jdGlvbiBzZXJpYWxpemUgKGl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fSBOb2RlT2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IE5vZGVPYmplY3QudHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPj19IE5vZGVPYmplY3QuYXR0cnNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5PE5vZGVPYmplY3Q+PX0gTm9kZU9iamVjdC5jb250ZW50XG4gICAgICovXG4gICAgbGV0IHJlc3BvbnNlXG5cbiAgICAvLyBUT0RPOiBNdXN0IGJlIGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGV4dCBub2RlcyB0aGFuIHRoaXNcbiAgICBpZiAoIWl0ZW0ubm9kZU5hbWUpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXRlbS50b0RlbHRhKClcbiAgICAgIHJlc3BvbnNlID0gZGVsdGEubWFwKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHRleHQ6IGQuaW5zZXJ0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdGV4dC5tYXJrcyA9IE9iamVjdC5rZXlzKGQuYXR0cmlidXRlcykubWFwKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGQuYXR0cmlidXRlc1t0eXBlXVxuICAgICAgICAgICAgY29uc3QgbWFyayA9IHtcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpKSB7XG4gICAgICAgICAgICAgIG1hcmsuYXR0cnMgPSBhdHRyc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFya1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICB0eXBlOiBpdGVtLm5vZGVOYW1lXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJzID0gaXRlbS5nZXRBdHRyaWJ1dGVzKClcbiAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgICAgIHJlc3BvbnNlLmF0dHJzID0gYXR0cnNcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBpdGVtLnRvQXJyYXkoKVxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXNwb25zZS5jb250ZW50ID0gY2hpbGRyZW4ubWFwKHNlcmlhbGl6ZSkuZmxhdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdkb2MnLFxuICAgIGNvbnRlbnQ6IGl0ZW1zLm1hcChzZXJpYWxpemUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1cGRhdGVZRnJhZ21lbnQiLCJ5U3luY1BsdWdpbktleSIsIlkiLCJFZGl0b3JWaWV3IiwiTm9kZSIsIlNjaGVtYSIsImVycm9yIiwibWFwIiwiZXZlbnRsb29wIiwidmlld3NUb1VwZGF0ZSIsInVwZGF0ZU1ldGFzIiwidXBzIiwiZm9yRWFjaCIsIm1ldGFzIiwidmlldyIsInRyIiwic3RhdGUiLCJzeW5jU3RhdGUiLCJnZXRTdGF0ZSIsImJpbmRpbmciLCJpc0Rlc3Ryb3llZCIsInZhbCIsImtleSIsInNldE1ldGEiLCJkaXNwYXRjaCIsInZhbHVlIiwiTWFwIiwidGltZW91dCIsInNldElmVW5kZWZpbmVkIiwiY3JlYXRlIiwic2V0IiwiYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiIsInBvcyIsInR5cGUiLCJtYXBwaW5nIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgiLCJuIiwiX2ZpcnN0IiwiY29udGVudCIsIlhtbFRleHQiLCJfbGVuZ3RoIiwiX2l0ZW0iLCJuZXh0IiwicGFyZW50IiwicE5vZGVTaXplIiwiZ2V0Iiwibm9kZVNpemUiLCJSZWxhdGl2ZVBvc2l0aW9uIiwiaWQiLCJmaW5kUm9vdFR5cGVLZXkiLCJ1bmV4cGVjdGVkQ2FzZSIsImNvbnN0cnVjdG9yIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiIsIml0ZW0iLCJ0eXBlaWQiLCJ0bmFtZSIsImNyZWF0ZUlEIiwiY2xpZW50IiwiY2xvY2siLCJyZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uIiwieSIsImRvY3VtZW50VHlwZSIsInJlbFBvcyIsImRlY29kZWRQb3MiLCJjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24iLCJpc1BhcmVudE9mIiwiaW5kZXgiLCJkZWxldGVkIiwiaSIsInQiLCJyaWdodCIsImNvbnRlbnRUeXBlIiwicHJvc2VtaXJyb3JUb1lEb2MiLCJkb2MiLCJ4bWxGcmFnbWVudCIsInlkb2MiLCJEb2MiLCJYbWxGcmFnbWVudCIsInByb3NlbWlycm9yVG9ZWG1sRnJhZ21lbnQiLCJ0cmFuc2FjdCIsInRyYW5zYWN0aW9uIiwidW5kZWZpbmVkIiwicHJvc2VtaXJyb3JKU09OVG9ZRG9jIiwic2NoZW1hIiwiZnJvbUpTT04iLCJwcm9zZW1pcnJvckpTT05Ub1lYbWxGcmFnbWVudCIsInlEb2NUb1Byb3NlbWlycm9yIiwieURvY1RvUHJvc2VtaXJyb3JKU09OIiwieVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvciIsInlYbWxGcmFnbWVudFRvUHJvc2VtaXJyb3JKU09OIiwiZ2V0WG1sRnJhZ21lbnQiLCJpdGVtcyIsInRvQXJyYXkiLCJzZXJpYWxpemUiLCJyZXNwb25zZSIsIm5vZGVOYW1lIiwiZGVsdGEiLCJ0b0RlbHRhIiwiZCIsInRleHQiLCJpbnNlcnQiLCJhdHRyaWJ1dGVzIiwibWFya3MiLCJPYmplY3QiLCJrZXlzIiwiYXR0cnMiLCJtYXJrIiwiZ2V0QXR0cmlidXRlcyIsImxlbmd0aCIsImNoaWxkcmVuIiwiZmxhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/cursor-plugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDecorations: () => (/* binding */ createDecorations),\n/* harmony export */   defaultCursorBuilder: () => (/* binding */ defaultCursorBuilder),\n/* harmony export */   defaultSelectionBuilder: () => (/* binding */ defaultSelectionBuilder),\n/* harmony export */   yCursorPlugin: () => (/* binding */ yCursorPlugin)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"(ssr)/./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n\n // eslint-disable-line\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n/**\n * Default generator for a cursor element\n *\n * @param {any} user user data\n * @return {HTMLElement}\n */ const defaultCursorBuilder = (user)=>{\n    const cursor = document.createElement(\"span\");\n    cursor.classList.add(\"ProseMirror-yjs-cursor\");\n    cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n    const userDiv = document.createElement(\"div\");\n    userDiv.setAttribute(\"style\", `background-color: ${user.color}`);\n    userDiv.insertBefore(document.createTextNode(user.name), null);\n    const nonbreakingSpace1 = document.createTextNode(\"⁠\");\n    const nonbreakingSpace2 = document.createTextNode(\"⁠\");\n    cursor.insertBefore(nonbreakingSpace1, null);\n    cursor.insertBefore(userDiv, null);\n    cursor.insertBefore(nonbreakingSpace2, null);\n    return cursor;\n};\n/**\n * Default generator for the selection attributes\n *\n * @param {any} user user data\n * @return {import('prosemirror-view').DecorationAttrs}\n */ const defaultSelectionBuilder = (user)=>{\n    return {\n        style: `background-color: ${user.color}70`,\n        class: \"ProseMirror-yjs-selection\"\n    };\n};\nconst rxValidColor = /^#[0-9a-fA-F]{6}$/;\n/**\n * @param {any} state\n * @param {Awareness} awareness\n * @param {function({ name: string, color: string }):Element} createCursor\n * @param {function({ name: string, color: string }):import('prosemirror-view').DecorationAttrs} createSelection\n * @return {any} DecorationSet\n */ const createDecorations = (state, awareness, createCursor, createSelection)=>{\n    const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(state);\n    const y = ystate.doc;\n    const decorations = [];\n    if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding === null) {\n        // do not render cursors while snapshot is active\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, []);\n    }\n    awareness.getStates().forEach((aw, clientId)=>{\n        if (clientId === y.clientID) {\n            return;\n        }\n        if (aw.cursor != null) {\n            const user = aw.user || {};\n            if (user.color == null) {\n                user.color = \"#ffa500\";\n            } else if (!rxValidColor.test(user.color)) {\n                // We only support 6-digit RGB colors in y-prosemirror\n                console.warn(\"A user uses an unsupported color format\", user);\n            }\n            if (user.name == null) {\n                user.name = `User: ${clientId}`;\n            }\n            let anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(y, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.anchor), ystate.binding.mapping);\n            let head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(y, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.head), ystate.binding.mapping);\n            if (anchor !== null && head !== null) {\n                const maxsize = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(state.doc.content.size - 1, 0);\n                anchor = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, maxsize);\n                head = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(head, maxsize);\n                decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(head, ()=>createCursor(user), {\n                    key: clientId + \"\",\n                    side: 10\n                }));\n                const from = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, head);\n                const to = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(anchor, head);\n                decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, createSelection(user), {\n                    inclusiveEnd: true,\n                    inclusiveStart: false\n                }));\n            }\n        }\n    });\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations);\n};\n/**\n * A prosemirror plugin that listens to awareness information on Yjs.\n * This requires that a `prosemirrorPlugin` is also bound to the prosemirror.\n *\n * @public\n * @param {Awareness} awareness\n * @param {object} opts\n * @param {function(any):HTMLElement} [opts.cursorBuilder]\n * @param {function(any):import('prosemirror-view').DecorationAttrs} [opts.selectionBuilder]\n * @param {function(any):any} [opts.getSelection]\n * @param {string} [cursorStateField] By default all editor bindings use the awareness 'cursor' field to propagate cursor information.\n * @return {any}\n */ const yCursorPlugin = (awareness, { cursorBuilder = defaultCursorBuilder, selectionBuilder = defaultSelectionBuilder, getSelection = (state)=>state.selection } = {}, cursorStateField = \"cursor\")=>new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({\n        key: _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey,\n        state: {\n            init (_, state) {\n                return createDecorations(state, awareness, cursorBuilder, selectionBuilder);\n            },\n            apply (tr, prevState, _oldState, newState) {\n                const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(newState);\n                const yCursorState = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey);\n                if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {\n                    return createDecorations(newState, awareness, cursorBuilder, selectionBuilder);\n                }\n                return prevState.map(tr.mapping, tr.doc);\n            }\n        },\n        props: {\n            decorations: (state)=>{\n                return _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey.getState(state);\n            }\n        },\n        view: (view)=>{\n            const awarenessListener = ()=>{\n                // @ts-ignore\n                if (view.docView) {\n                    (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.setMeta)(view, _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey, {\n                        awarenessUpdated: true\n                    });\n                }\n            };\n            const updateCursorInfo = ()=>{\n                const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(view.state);\n                // @note We make implicit checks when checking for the cursor property\n                const current = awareness.getLocalState() || {};\n                if (ystate.binding == null) {\n                    return;\n                }\n                if (view.hasFocus()) {\n                    const selection = getSelection(view.state);\n                    /**\n           * @type {Y.RelativePosition}\n           */ const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(selection.anchor, ystate.type, ystate.binding.mapping);\n                    /**\n           * @type {Y.RelativePosition}\n           */ const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(selection.head, ystate.type, ystate.binding.mapping);\n                    if (current.cursor == null || !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor), anchor) || !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.head), head)) {\n                        awareness.setLocalStateField(cursorStateField, {\n                            anchor,\n                            head\n                        });\n                    }\n                } else if (current.cursor != null && (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(ystate.doc, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor), ystate.binding.mapping) !== null) {\n                    // delete cursor information if current cursor information is owned by this editor binding\n                    awareness.setLocalStateField(cursorStateField, null);\n                }\n            };\n            awareness.on(\"change\", awarenessListener);\n            view.dom.addEventListener(\"focusin\", updateCursorInfo);\n            view.dom.addEventListener(\"focusout\", updateCursorInfo);\n            return {\n                update: updateCursorInfo,\n                destroy: ()=>{\n                    view.dom.removeEventListener(\"focusin\", updateCursorInfo);\n                    view.dom.removeEventListener(\"focusout\", updateCursorInfo);\n                    awareness.off(\"change\", awarenessListener);\n                    awareness.setLocalStateField(cursorStateField, null);\n                }\n            };\n        }\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9jdXJzb3ItcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ3FDLENBQUMsc0JBQXNCO0FBQ3pDLENBQUMsc0JBQXNCO0FBQ2hCLENBQUMsc0JBQXNCO0FBS3ZEO0FBQzBDO0FBRTNCO0FBRWpDOzs7OztDQUtDLEdBQ00sTUFBTVcsdUJBQXVCLENBQUNDO0lBQ25DLE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztJQUN0Q0YsT0FBT0csU0FBUyxDQUFDQyxHQUFHLENBQUM7SUFDckJKLE9BQU9LLFlBQVksQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFTixLQUFLTyxLQUFLLENBQUMsQ0FBQztJQUMxRCxNQUFNQyxVQUFVTixTQUFTQyxhQUFhLENBQUM7SUFDdkNLLFFBQVFGLFlBQVksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxDQUFDO0lBQy9EQyxRQUFRQyxZQUFZLENBQUNQLFNBQVNRLGNBQWMsQ0FBQ1YsS0FBS1csSUFBSSxHQUFHO0lBQ3pELE1BQU1DLG9CQUFvQlYsU0FBU1EsY0FBYyxDQUFDO0lBQ2xELE1BQU1HLG9CQUFvQlgsU0FBU1EsY0FBYyxDQUFDO0lBQ2xEVCxPQUFPUSxZQUFZLENBQUNHLG1CQUFtQjtJQUN2Q1gsT0FBT1EsWUFBWSxDQUFDRCxTQUFTO0lBQzdCUCxPQUFPUSxZQUFZLENBQUNJLG1CQUFtQjtJQUN2QyxPQUFPWjtBQUNULEVBQUM7QUFFRDs7Ozs7Q0FLQyxHQUNNLE1BQU1hLDBCQUEwQixDQUFDZDtJQUN0QyxPQUFPO1FBQ0xlLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRWYsS0FBS08sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUMxQ1MsT0FBTztJQUNUO0FBQ0YsRUFBQztBQUVELE1BQU1DLGVBQWU7QUFFckI7Ozs7OztDQU1DLEdBQ00sTUFBTUMsb0JBQW9CLENBQy9CQyxPQUNBQyxXQUNBQyxjQUNBQztJQUVBLE1BQU1DLFNBQVMxQixvREFBY0EsQ0FBQzJCLFFBQVEsQ0FBQ0w7SUFDdkMsTUFBTU0sSUFBSUYsT0FBT0csR0FBRztJQUNwQixNQUFNQyxjQUFjLEVBQUU7SUFDdEIsSUFDRUosT0FBT0ssUUFBUSxJQUFJLFFBQVFMLE9BQU9NLFlBQVksSUFBSSxRQUNsRE4sT0FBT08sT0FBTyxLQUFLLE1BQ25CO1FBQ0EsaURBQWlEO1FBQ2pELE9BQU94QywyREFBYUEsQ0FBQ3lDLE1BQU0sQ0FBQ1osTUFBTU8sR0FBRyxFQUFFLEVBQUU7SUFDM0M7SUFDQU4sVUFBVVksU0FBUyxHQUFHQyxPQUFPLENBQUMsQ0FBQ0MsSUFBSUM7UUFDakMsSUFBSUEsYUFBYVYsRUFBRVcsUUFBUSxFQUFFO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJRixHQUFHakMsTUFBTSxJQUFJLE1BQU07WUFDckIsTUFBTUQsT0FBT2tDLEdBQUdsQyxJQUFJLElBQUksQ0FBQztZQUN6QixJQUFJQSxLQUFLTyxLQUFLLElBQUksTUFBTTtnQkFDdEJQLEtBQUtPLEtBQUssR0FBRztZQUNmLE9BQU8sSUFBSSxDQUFDVSxhQUFhb0IsSUFBSSxDQUFDckMsS0FBS08sS0FBSyxHQUFHO2dCQUN6QyxzREFBc0Q7Z0JBQ3REK0IsUUFBUUMsSUFBSSxDQUFDLDJDQUEyQ3ZDO1lBQzFEO1lBQ0EsSUFBSUEsS0FBS1csSUFBSSxJQUFJLE1BQU07Z0JBQ3JCWCxLQUFLVyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUV3QixTQUFTLENBQUM7WUFDakM7WUFDQSxJQUFJSyxTQUFTOUMsMkVBQWtDQSxDQUM3QytCLEdBQ0FGLE9BQU9rQixJQUFJLEVBQ1hyRCwrREFBZ0MsQ0FBQzhDLEdBQUdqQyxNQUFNLENBQUN1QyxNQUFNLEdBQ2pEakIsT0FBT08sT0FBTyxDQUFDYSxPQUFPO1lBRXhCLElBQUlDLE9BQU9sRCwyRUFBa0NBLENBQzNDK0IsR0FDQUYsT0FBT2tCLElBQUksRUFDWHJELCtEQUFnQyxDQUFDOEMsR0FBR2pDLE1BQU0sQ0FBQzJDLElBQUksR0FDL0NyQixPQUFPTyxPQUFPLENBQUNhLE9BQU87WUFFeEIsSUFBSUgsV0FBVyxRQUFRSSxTQUFTLE1BQU07Z0JBQ3BDLE1BQU1DLFVBQVUvQywwQ0FBUSxDQUFDcUIsTUFBTU8sR0FBRyxDQUFDcUIsT0FBTyxDQUFDQyxJQUFJLEdBQUcsR0FBRztnQkFDckRSLFNBQVMxQywwQ0FBUSxDQUFDMEMsUUFBUUs7Z0JBQzFCRCxPQUFPOUMsMENBQVEsQ0FBQzhDLE1BQU1DO2dCQUN0QmxCLFlBQVl1QixJQUFJLENBQ2Q3RCx3REFBVUEsQ0FBQzhELE1BQU0sQ0FBQ1AsTUFBTSxJQUFNdkIsYUFBYXJCLE9BQU87b0JBQ2hEb0QsS0FBS2pCLFdBQVc7b0JBQ2hCa0IsTUFBTTtnQkFDUjtnQkFFRixNQUFNQyxPQUFPeEQsMENBQVEsQ0FBQzBDLFFBQVFJO2dCQUM5QixNQUFNVyxLQUFLekQsMENBQVEsQ0FBQzBDLFFBQVFJO2dCQUM1QmpCLFlBQVl1QixJQUFJLENBQ2Q3RCx3REFBVUEsQ0FBQ21FLE1BQU0sQ0FBQ0YsTUFBTUMsSUFBSWpDLGdCQUFnQnRCLE9BQU87b0JBQ2pEeUQsY0FBYztvQkFDZEMsZ0JBQWdCO2dCQUNsQjtZQUVKO1FBQ0Y7SUFDRjtJQUNBLE9BQU9wRSwyREFBYUEsQ0FBQ3lDLE1BQU0sQ0FBQ1osTUFBTU8sR0FBRyxFQUFFQztBQUN6QyxFQUFDO0FBRUQ7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTWdDLGdCQUFnQixDQUMzQnZDLFdBQ0EsRUFDRXdDLGdCQUFnQjdELG9CQUFvQixFQUNwQzhELG1CQUFtQi9DLHVCQUF1QixFQUMxQ2dELGVBQWUsQ0FBQzNDLFFBQVVBLE1BQU00QyxTQUFTLEVBQzFDLEdBQUcsQ0FBQyxDQUFDLEVBQ05DLG1CQUFtQixRQUFRLEdBRTNCLElBQUl6RSxxREFBTUEsQ0FBQztRQUNUNkQsS0FBS3hELHNEQUFnQkE7UUFDckJ1QixPQUFPO1lBQ0w4QyxNQUFNQyxDQUFDLEVBQUUvQyxLQUFLO2dCQUNaLE9BQU9ELGtCQUNMQyxPQUNBQyxXQUNBd0MsZUFDQUM7WUFFSjtZQUNBTSxPQUFPQyxFQUFFLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxRQUFRO2dCQUN2QyxNQUFNaEQsU0FBUzFCLG9EQUFjQSxDQUFDMkIsUUFBUSxDQUFDK0M7Z0JBQ3ZDLE1BQU1DLGVBQWVKLEdBQUdLLE9BQU8sQ0FBQzdFLHNEQUFnQkE7Z0JBQ2hELElBQ0UsVUFBVzJCLE9BQU9tRCxjQUFjLElBQy9CRixnQkFBZ0JBLGFBQWFHLGdCQUFnQixFQUM5QztvQkFDQSxPQUFPekQsa0JBQ0xxRCxVQUNBbkQsV0FDQXdDLGVBQ0FDO2dCQUVKO2dCQUNBLE9BQU9RLFVBQVVPLEdBQUcsQ0FBQ1IsR0FBR3pCLE9BQU8sRUFBRXlCLEdBQUcxQyxHQUFHO1lBQ3pDO1FBQ0Y7UUFDQW1ELE9BQU87WUFDTGxELGFBQWEsQ0FBQ1I7Z0JBQ1osT0FBT3ZCLHNEQUFnQkEsQ0FBQzRCLFFBQVEsQ0FBQ0w7WUFDbkM7UUFDRjtRQUNBMkQsTUFBTSxDQUFDQTtZQUNMLE1BQU1DLG9CQUFvQjtnQkFDeEIsYUFBYTtnQkFDYixJQUFJRCxLQUFLRSxPQUFPLEVBQUU7b0JBQ2hCckYsZ0RBQU9BLENBQUNtRixNQUFNbEYsc0RBQWdCQSxFQUFFO3dCQUFFK0Usa0JBQWtCO29CQUFLO2dCQUMzRDtZQUNGO1lBQ0EsTUFBTU0sbUJBQW1CO2dCQUN2QixNQUFNMUQsU0FBUzFCLG9EQUFjQSxDQUFDMkIsUUFBUSxDQUFDc0QsS0FBSzNELEtBQUs7Z0JBQ2pELHNFQUFzRTtnQkFDdEUsTUFBTStELFVBQVU5RCxVQUFVK0QsYUFBYSxNQUFNLENBQUM7Z0JBQzlDLElBQUk1RCxPQUFPTyxPQUFPLElBQUksTUFBTTtvQkFDMUI7Z0JBQ0Y7Z0JBQ0EsSUFBSWdELEtBQUtNLFFBQVEsSUFBSTtvQkFDbkIsTUFBTXJCLFlBQVlELGFBQWFnQixLQUFLM0QsS0FBSztvQkFDekM7O1dBRUMsR0FDRCxNQUFNcUIsU0FBUy9DLDJFQUFrQ0EsQ0FDL0NzRSxVQUFVdkIsTUFBTSxFQUNoQmpCLE9BQU9rQixJQUFJLEVBQ1hsQixPQUFPTyxPQUFPLENBQUNhLE9BQU87b0JBRXhCOztXQUVDLEdBQ0QsTUFBTUMsT0FBT25ELDJFQUFrQ0EsQ0FDN0NzRSxVQUFVbkIsSUFBSSxFQUNkckIsT0FBT2tCLElBQUksRUFDWGxCLE9BQU9PLE9BQU8sQ0FBQ2EsT0FBTztvQkFFeEIsSUFDRXVDLFFBQVFqRixNQUFNLElBQUksUUFDbEIsQ0FBQ2IseURBQTBCLENBQ3pCQSwrREFBZ0MsQ0FBQzhGLFFBQVFqRixNQUFNLENBQUN1QyxNQUFNLEdBQ3REQSxXQUVGLENBQUNwRCx5REFBMEIsQ0FDekJBLCtEQUFnQyxDQUFDOEYsUUFBUWpGLE1BQU0sQ0FBQzJDLElBQUksR0FDcERBLE9BRUY7d0JBQ0F4QixVQUFVa0Usa0JBQWtCLENBQUN0QixrQkFBa0I7NEJBQzdDeEI7NEJBQ0FJO3dCQUNGO29CQUNGO2dCQUNGLE9BQU8sSUFDTHNDLFFBQVFqRixNQUFNLElBQUksUUFDbEJQLDJFQUFrQ0EsQ0FDaEM2QixPQUFPRyxHQUFHLEVBQ1ZILE9BQU9rQixJQUFJLEVBQ1hyRCwrREFBZ0MsQ0FBQzhGLFFBQVFqRixNQUFNLENBQUN1QyxNQUFNLEdBQ3REakIsT0FBT08sT0FBTyxDQUFDYSxPQUFPLE1BQ2xCLE1BQ047b0JBQ0EsMEZBQTBGO29CQUMxRnZCLFVBQVVrRSxrQkFBa0IsQ0FBQ3RCLGtCQUFrQjtnQkFDakQ7WUFDRjtZQUNBNUMsVUFBVW1FLEVBQUUsQ0FBQyxVQUFVUjtZQUN2QkQsS0FBS1UsR0FBRyxDQUFDQyxnQkFBZ0IsQ0FBQyxXQUFXUjtZQUNyQ0gsS0FBS1UsR0FBRyxDQUFDQyxnQkFBZ0IsQ0FBQyxZQUFZUjtZQUN0QyxPQUFPO2dCQUNMUyxRQUFRVDtnQkFDUlUsU0FBUztvQkFDUGIsS0FBS1UsR0FBRyxDQUFDSSxtQkFBbUIsQ0FBQyxXQUFXWDtvQkFDeENILEtBQUtVLEdBQUcsQ0FBQ0ksbUJBQW1CLENBQUMsWUFBWVg7b0JBQ3pDN0QsVUFBVXlFLEdBQUcsQ0FBQyxVQUFVZDtvQkFDeEIzRCxVQUFVa0Usa0JBQWtCLENBQUN0QixrQkFBa0I7Z0JBQ2pEO1lBQ0Y7UUFDRjtJQUNGLEdBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZS1qb3VybmFsLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvY3Vyc29yLXBsdWdpbi5qcz84ZWY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBBd2FyZW5lc3MgfSBmcm9tIFwieS1wcm90b2NvbHMvYXdhcmVuZXNzXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7XG4gIGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24sXG4gIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24sXG4gIHNldE1ldGFcbn0gZnJvbSAnLi4vbGliLmpzJ1xuaW1wb3J0IHsgeUN1cnNvclBsdWdpbktleSwgeVN5bmNQbHVnaW5LZXkgfSBmcm9tICcuL2tleXMuanMnXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuXG4vKipcbiAqIERlZmF1bHQgZ2VuZXJhdG9yIGZvciBhIGN1cnNvciBlbGVtZW50XG4gKlxuICogQHBhcmFtIHthbnl9IHVzZXIgdXNlciBkYXRhXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRDdXJzb3JCdWlsZGVyID0gKHVzZXIpID0+IHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGN1cnNvci5jbGFzc0xpc3QuYWRkKCdQcm9zZU1pcnJvci15anMtY3Vyc29yJylcbiAgY3Vyc29yLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgYm9yZGVyLWNvbG9yOiAke3VzZXIuY29sb3J9YClcbiAgY29uc3QgdXNlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHVzZXJEaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9YClcbiAgdXNlckRpdi5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodXNlci5uYW1lKSwgbnVsbClcbiAgY29uc3Qgbm9uYnJlYWtpbmdTcGFjZTEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjA2MCcpXG4gIGNvbnN0IG5vbmJyZWFraW5nU3BhY2UyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTIwNjAnKVxuICBjdXJzb3IuaW5zZXJ0QmVmb3JlKG5vbmJyZWFraW5nU3BhY2UxLCBudWxsKVxuICBjdXJzb3IuaW5zZXJ0QmVmb3JlKHVzZXJEaXYsIG51bGwpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUobm9uYnJlYWtpbmdTcGFjZTIsIG51bGwpXG4gIHJldHVybiBjdXJzb3Jcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGdlbmVyYXRvciBmb3IgdGhlIHNlbGVjdGlvbiBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtIHthbnl9IHVzZXIgdXNlciBkYXRhXG4gKiBAcmV0dXJuIHtpbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlciA9ICh1c2VyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9NzBgLFxuICAgIGNsYXNzOiAnUHJvc2VNaXJyb3IteWpzLXNlbGVjdGlvbidcbiAgfVxufVxuXG5jb25zdCByeFZhbGlkQ29sb3IgPSAvXiNbMC05YS1mQS1GXXs2fSQvXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHsgbmFtZTogc3RyaW5nLCBjb2xvcjogc3RyaW5nIH0pOkVsZW1lbnR9IGNyZWF0ZUN1cnNvclxuICogQHBhcmFtIHtmdW5jdGlvbih7IG5hbWU6IHN0cmluZywgY29sb3I6IHN0cmluZyB9KTppbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9IGNyZWF0ZVNlbGVjdGlvblxuICogQHJldHVybiB7YW55fSBEZWNvcmF0aW9uU2V0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWNvcmF0aW9ucyA9IChcbiAgc3RhdGUsXG4gIGF3YXJlbmVzcyxcbiAgY3JlYXRlQ3Vyc29yLFxuICBjcmVhdGVTZWxlY3Rpb25cbikgPT4ge1xuICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgY29uc3QgeSA9IHlzdGF0ZS5kb2NcbiAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXVxuICBpZiAoXG4gICAgeXN0YXRlLnNuYXBzaG90ICE9IG51bGwgfHwgeXN0YXRlLnByZXZTbmFwc2hvdCAhPSBudWxsIHx8XG4gICAgeXN0YXRlLmJpbmRpbmcgPT09IG51bGxcbiAgKSB7XG4gICAgLy8gZG8gbm90IHJlbmRlciBjdXJzb3JzIHdoaWxlIHNuYXBzaG90IGlzIGFjdGl2ZVxuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtdKVxuICB9XG4gIGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5mb3JFYWNoKChhdywgY2xpZW50SWQpID0+IHtcbiAgICBpZiAoY2xpZW50SWQgPT09IHkuY2xpZW50SUQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXcuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdy51c2VyIHx8IHt9XG4gICAgICBpZiAodXNlci5jb2xvciA9PSBudWxsKSB7XG4gICAgICAgIHVzZXIuY29sb3IgPSAnI2ZmYTUwMCdcbiAgICAgIH0gZWxzZSBpZiAoIXJ4VmFsaWRDb2xvci50ZXN0KHVzZXIuY29sb3IpKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCA2LWRpZ2l0IFJHQiBjb2xvcnMgaW4geS1wcm9zZW1pcnJvclxuICAgICAgICBjb25zb2xlLndhcm4oJ0EgdXNlciB1c2VzIGFuIHVuc3VwcG9ydGVkIGNvbG9yIGZvcm1hdCcsIHVzZXIpXG4gICAgICB9XG4gICAgICBpZiAodXNlci5uYW1lID09IG51bGwpIHtcbiAgICAgICAgdXNlci5uYW1lID0gYFVzZXI6ICR7Y2xpZW50SWR9YFxuICAgICAgfVxuICAgICAgbGV0IGFuY2hvciA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgIHksXG4gICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihhdy5jdXJzb3IuYW5jaG9yKSxcbiAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgbGV0IGhlYWQgPSByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKFxuICAgICAgICB5LFxuICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oYXcuY3Vyc29yLmhlYWQpLFxuICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWF4c2l6ZSA9IG1hdGgubWF4KHN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAxLCAwKVxuICAgICAgICBhbmNob3IgPSBtYXRoLm1pbihhbmNob3IsIG1heHNpemUpXG4gICAgICAgIGhlYWQgPSBtYXRoLm1pbihoZWFkLCBtYXhzaXplKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24ud2lkZ2V0KGhlYWQsICgpID0+IGNyZWF0ZUN1cnNvcih1c2VyKSwge1xuICAgICAgICAgICAga2V5OiBjbGllbnRJZCArICcnLFxuICAgICAgICAgICAgc2lkZTogMTBcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGZyb20gPSBtYXRoLm1pbihhbmNob3IsIGhlYWQpXG4gICAgICAgIGNvbnN0IHRvID0gbWF0aC5tYXgoYW5jaG9yLCBoZWFkKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24uaW5saW5lKGZyb20sIHRvLCBjcmVhdGVTZWxlY3Rpb24odXNlciksIHtcbiAgICAgICAgICAgIGluY2x1c2l2ZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZVN0YXJ0OiBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIGRlY29yYXRpb25zKVxufVxuXG4vKipcbiAqIEEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgbGlzdGVucyB0byBhd2FyZW5lc3MgaW5mb3JtYXRpb24gb24gWWpzLlxuICogVGhpcyByZXF1aXJlcyB0aGF0IGEgYHByb3NlbWlycm9yUGx1Z2luYCBpcyBhbHNvIGJvdW5kIHRvIHRoZSBwcm9zZW1pcnJvci5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOkhUTUxFbGVtZW50fSBbb3B0cy5jdXJzb3JCdWlsZGVyXVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc30gW29wdHMuc2VsZWN0aW9uQnVpbGRlcl1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IFtvcHRzLmdldFNlbGVjdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3RhdGVGaWVsZF0gQnkgZGVmYXVsdCBhbGwgZWRpdG9yIGJpbmRpbmdzIHVzZSB0aGUgYXdhcmVuZXNzICdjdXJzb3InIGZpZWxkIHRvIHByb3BhZ2F0ZSBjdXJzb3IgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCB5Q3Vyc29yUGx1Z2luID0gKFxuICBhd2FyZW5lc3MsXG4gIHtcbiAgICBjdXJzb3JCdWlsZGVyID0gZGVmYXVsdEN1cnNvckJ1aWxkZXIsXG4gICAgc2VsZWN0aW9uQnVpbGRlciA9IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyLFxuICAgIGdldFNlbGVjdGlvbiA9IChzdGF0ZSkgPT4gc3RhdGUuc2VsZWN0aW9uXG4gIH0gPSB7fSxcbiAgY3Vyc29yU3RhdGVGaWVsZCA9ICdjdXJzb3InXG4pID0+XG4gIG5ldyBQbHVnaW4oe1xuICAgIGtleTogeUN1cnNvclBsdWdpbktleSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdCAoXywgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRpb25zKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGF3YXJlbmVzcyxcbiAgICAgICAgICBjdXJzb3JCdWlsZGVyLFxuICAgICAgICAgIHNlbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGFwcGx5ICh0ciwgcHJldlN0YXRlLCBfb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKG5ld1N0YXRlKVxuICAgICAgICBjb25zdCB5Q3Vyc29yU3RhdGUgPSB0ci5nZXRNZXRhKHlDdXJzb3JQbHVnaW5LZXkpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoeXN0YXRlICYmIHlzdGF0ZS5pc0NoYW5nZU9yaWdpbikgfHxcbiAgICAgICAgICAoeUN1cnNvclN0YXRlICYmIHlDdXJzb3JTdGF0ZS5hd2FyZW5lc3NVcGRhdGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdGlvbnMoXG4gICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgIGF3YXJlbmVzcyxcbiAgICAgICAgICAgIGN1cnNvckJ1aWxkZXIsXG4gICAgICAgICAgICBzZWxlY3Rpb25CdWlsZGVyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGUubWFwKHRyLm1hcHBpbmcsIHRyLmRvYylcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB5Q3Vyc29yUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgfVxuICAgIH0sXG4gICAgdmlldzogKHZpZXcpID0+IHtcbiAgICAgIGNvbnN0IGF3YXJlbmVzc0xpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcpIHtcbiAgICAgICAgICBzZXRNZXRhKHZpZXcsIHlDdXJzb3JQbHVnaW5LZXksIHsgYXdhcmVuZXNzVXBkYXRlZDogdHJ1ZSB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB1cGRhdGVDdXJzb3JJbmZvID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgICAgICAvLyBAbm90ZSBXZSBtYWtlIGltcGxpY2l0IGNoZWNrcyB3aGVuIGNoZWNraW5nIGZvciB0aGUgY3Vyc29yIHByb3BlcnR5XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpIHx8IHt9XG4gICAgICAgIGlmICh5c3RhdGUuYmluZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXcuaGFzRm9jdXMoKSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbih2aWV3LnN0YXRlKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHtZLlJlbGF0aXZlUG9zaXRpb259XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgYW5jaG9yID0gYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUge1kuUmVsYXRpdmVQb3NpdGlvbn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBoZWFkID0gYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICAgICAgICAgIHNlbGVjdGlvbi5oZWFkLFxuICAgICAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGN1cnJlbnQuY3Vyc29yID09IG51bGwgfHxcbiAgICAgICAgICAgICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhcbiAgICAgICAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oY3VycmVudC5jdXJzb3IuYW5jaG9yKSxcbiAgICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAhWS5jb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMoXG4gICAgICAgICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmhlYWQpLFxuICAgICAgICAgICAgICBoZWFkXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIHtcbiAgICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgICBoZWFkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjdXJyZW50LmN1cnNvciAhPSBudWxsICYmXG4gICAgICAgICAgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgICAgIHlzdGF0ZS5kb2MsXG4gICAgICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmFuY2hvciksXG4gICAgICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICAgICAgKSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBkZWxldGUgY3Vyc29yIGluZm9ybWF0aW9uIGlmIGN1cnJlbnQgY3Vyc29yIGluZm9ybWF0aW9uIGlzIG93bmVkIGJ5IHRoaXMgZWRpdG9yIGJpbmRpbmdcbiAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YXJlbmVzcy5vbignY2hhbmdlJywgYXdhcmVuZXNzTGlzdGVuZXIpXG4gICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogdXBkYXRlQ3Vyc29ySW5mbyxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgICAgICBhd2FyZW5lc3Mub2ZmKCdjaGFuZ2UnLCBhd2FyZW5lc3NMaXN0ZW5lcilcbiAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4iXSwibmFtZXMiOlsiWSIsIkRlY29yYXRpb24iLCJEZWNvcmF0aW9uU2V0IiwiUGx1Z2luIiwiQXdhcmVuZXNzIiwiYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiIsInJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24iLCJzZXRNZXRhIiwieUN1cnNvclBsdWdpbktleSIsInlTeW5jUGx1Z2luS2V5IiwibWF0aCIsImRlZmF1bHRDdXJzb3JCdWlsZGVyIiwidXNlciIsImN1cnNvciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInNldEF0dHJpYnV0ZSIsImNvbG9yIiwidXNlckRpdiIsImluc2VydEJlZm9yZSIsImNyZWF0ZVRleHROb2RlIiwibmFtZSIsIm5vbmJyZWFraW5nU3BhY2UxIiwibm9uYnJlYWtpbmdTcGFjZTIiLCJkZWZhdWx0U2VsZWN0aW9uQnVpbGRlciIsInN0eWxlIiwiY2xhc3MiLCJyeFZhbGlkQ29sb3IiLCJjcmVhdGVEZWNvcmF0aW9ucyIsInN0YXRlIiwiYXdhcmVuZXNzIiwiY3JlYXRlQ3Vyc29yIiwiY3JlYXRlU2VsZWN0aW9uIiwieXN0YXRlIiwiZ2V0U3RhdGUiLCJ5IiwiZG9jIiwiZGVjb3JhdGlvbnMiLCJzbmFwc2hvdCIsInByZXZTbmFwc2hvdCIsImJpbmRpbmciLCJjcmVhdGUiLCJnZXRTdGF0ZXMiLCJmb3JFYWNoIiwiYXciLCJjbGllbnRJZCIsImNsaWVudElEIiwidGVzdCIsImNvbnNvbGUiLCJ3YXJuIiwiYW5jaG9yIiwidHlwZSIsImNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiIsIm1hcHBpbmciLCJoZWFkIiwibWF4c2l6ZSIsIm1heCIsImNvbnRlbnQiLCJzaXplIiwibWluIiwicHVzaCIsIndpZGdldCIsImtleSIsInNpZGUiLCJmcm9tIiwidG8iLCJpbmxpbmUiLCJpbmNsdXNpdmVFbmQiLCJpbmNsdXNpdmVTdGFydCIsInlDdXJzb3JQbHVnaW4iLCJjdXJzb3JCdWlsZGVyIiwic2VsZWN0aW9uQnVpbGRlciIsImdldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsImN1cnNvclN0YXRlRmllbGQiLCJpbml0IiwiXyIsImFwcGx5IiwidHIiLCJwcmV2U3RhdGUiLCJfb2xkU3RhdGUiLCJuZXdTdGF0ZSIsInlDdXJzb3JTdGF0ZSIsImdldE1ldGEiLCJpc0NoYW5nZU9yaWdpbiIsImF3YXJlbmVzc1VwZGF0ZWQiLCJtYXAiLCJwcm9wcyIsInZpZXciLCJhd2FyZW5lc3NMaXN0ZW5lciIsImRvY1ZpZXciLCJ1cGRhdGVDdXJzb3JJbmZvIiwiY3VycmVudCIsImdldExvY2FsU3RhdGUiLCJoYXNGb2N1cyIsImNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyIsInNldExvY2FsU3RhdGVGaWVsZCIsIm9uIiwiZG9tIiwiYWRkRXZlbnRMaXN0ZW5lciIsInVwZGF0ZSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yCursorPluginKey: () => (/* binding */ yCursorPluginKey),\n/* harmony export */   ySyncPluginKey: () => (/* binding */ ySyncPluginKey),\n/* harmony export */   yUndoPluginKey: () => (/* binding */ yUndoPluginKey)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n // eslint-disable-line\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */ const ySyncPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"y-sync\");\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n */ const yUndoPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"y-undo\");\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */ const yCursorPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"yjs-cursor\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDNkMsQ0FBQyxzQkFBc0I7QUFFcEU7Ozs7Q0FJQyxHQUNNLE1BQU1DLGlCQUFpQixJQUFJRCx3REFBU0EsQ0FBQyxVQUFTO0FBRXJEOzs7O0NBSUMsR0FDTSxNQUFNRSxpQkFBaUIsSUFBSUYsd0RBQVNBLENBQUMsVUFBUztBQUVyRDs7OztDQUlDLEdBQ00sTUFBTUcsbUJBQW1CLElBQUlILHdEQUFTQSxDQUFDLGNBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZS1qb3VybmFsLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMva2V5cy5qcz8wZTA0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBUaGUgdW5pcXVlIHByb3NlbWlycm9yIHBsdWdpbiBrZXkgZm9yIHN5bmNQbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3ktc3luYycpXG5cbi8qKlxuICogVGhlIHVuaXF1ZSBwcm9zZW1pcnJvciBwbHVnaW4ga2V5IGZvciB1bmRvUGx1Z2luXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgeVVuZG9QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCd5LXVuZG8nKVxuXG4vKipcbiAqIFRoZSB1bmlxdWUgcHJvc2VtaXJyb3IgcGx1Z2luIGtleSBmb3IgY3Vyc29yUGx1Z2luXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgeUN1cnNvclBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3lqcy1jdXJzb3InKVxuIl0sIm5hbWVzIjpbIlBsdWdpbktleSIsInlTeW5jUGx1Z2luS2V5IiwieVVuZG9QbHVnaW5LZXkiLCJ5Q3Vyc29yUGx1Z2luS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/sync-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProsemirrorBinding: () => (/* binding */ ProsemirrorBinding),\n/* harmony export */   getRelativeSelection: () => (/* binding */ getRelativeSelection),\n/* harmony export */   isVisible: () => (/* binding */ isVisible),\n/* harmony export */   updateYFragment: () => (/* binding */ updateYFragment),\n/* harmony export */   ySyncPlugin: () => (/* binding */ ySyncPlugin)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/mutex */ \"(ssr)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/diff */ \"(ssr)/./node_modules/lib0/diff.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/environment */ \"(ssr)/./node_modules/lib0/environment.js\");\n/* harmony import */ var lib0_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/dom */ \"(ssr)/./node_modules/lib0/dom.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n/**\n * @module bindings/prosemirror\n */ \n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && /** @type {number} */ snapshot.sv.get(item.id.client) > item.id.clock && !yjs__WEBPACK_IMPORTED_MODULE_0__.isDeleted(snapshot.ds, item.id);\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */ /**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */ /**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */ /**\n * @type {Array<ColorDef>}\n */ const defaultColors = [\n    {\n        light: \"#ecd44433\",\n        dark: \"#ecd444\"\n    }\n];\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */ const getUserColor = (colorMapping, colors, user)=>{\n    // @todo do not hit the same color twice if possible\n    if (!colorMapping.has(user)) {\n        if (colorMapping.size < colors.length) {\n            const usedColors = lib0_set__WEBPACK_IMPORTED_MODULE_1__.create();\n            colorMapping.forEach((color)=>usedColors.add(color));\n            colors = colors.filter((color)=>!usedColors.has(color));\n        }\n        colorMapping.set(user, lib0_random__WEBPACK_IMPORTED_MODULE_2__.oneOf(colors));\n    }\n    return /** @type {ColorDef} */ colorMapping.get(user);\n};\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */ const ySyncPlugin = (yXmlFragment, { colors = defaultColors, colorMapping = new Map(), permanentUserData = null, onFirstRender = ()=>{} } = {})=>{\n    let changedInitialContent = false;\n    let rerenderTimeout;\n    const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n        props: {\n            editable: (state)=>{\n                const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(state);\n                return syncState.snapshot == null && syncState.prevSnapshot == null;\n            }\n        },\n        key: _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey,\n        state: {\n            /**\n       * @returns {any}\n       */ init: (_initargs, _state)=>{\n                return {\n                    type: yXmlFragment,\n                    doc: yXmlFragment.doc,\n                    binding: null,\n                    snapshot: null,\n                    prevSnapshot: null,\n                    isChangeOrigin: false,\n                    isUndoRedoOperation: false,\n                    addToHistory: true,\n                    colors,\n                    colorMapping,\n                    permanentUserData\n                };\n            },\n            apply: (tr, pluginState)=>{\n                const change = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n                if (change !== undefined) {\n                    pluginState = Object.assign({}, pluginState);\n                    for(const key in change){\n                        pluginState[key] = change[key];\n                    }\n                }\n                pluginState.addToHistory = tr.getMeta(\"addToHistory\") !== false;\n                // always set isChangeOrigin. If undefined, this is not change origin.\n                pluginState.isChangeOrigin = change !== undefined && !!change.isChangeOrigin;\n                pluginState.isUndoRedoOperation = change !== undefined && !!change.isChangeOrigin && !!change.isUndoRedoOperation;\n                if (pluginState.binding !== null) {\n                    if (change !== undefined && (change.snapshot != null || change.prevSnapshot != null)) {\n                        // snapshot changed, rerender next\n                        lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, ()=>{\n                            if (pluginState.binding == null || pluginState.binding.isDestroyed) {\n                                return;\n                            }\n                            if (change.restore == null) {\n                                pluginState.binding._renderSnapshot(change.snapshot, change.prevSnapshot, pluginState);\n                            } else {\n                                pluginState.binding._renderSnapshot(change.snapshot, change.snapshot, pluginState);\n                                // reset to current prosemirror state\n                                delete pluginState.restore;\n                                delete pluginState.snapshot;\n                                delete pluginState.prevSnapshot;\n                                pluginState.binding.mux(()=>{\n                                    pluginState.binding._prosemirrorChanged(pluginState.binding.prosemirrorView.state.doc);\n                                });\n                            }\n                        });\n                    }\n                }\n                return pluginState;\n            }\n        },\n        view: (view)=>{\n            const binding = new ProsemirrorBinding(yXmlFragment, view);\n            if (rerenderTimeout != null) {\n                rerenderTimeout.destroy();\n            }\n            // Make sure this is called in a separate context\n            rerenderTimeout = lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, ()=>{\n                binding._forceRerender();\n                view.dispatch(view.state.tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                    binding\n                }));\n                onFirstRender();\n            });\n            return {\n                update: ()=>{\n                    const pluginState = plugin.getState(view.state);\n                    if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {\n                        if (changedInitialContent || view.state.doc.content.findDiffStart(view.state.doc.type.createAndFill().content) !== null) {\n                            changedInitialContent = true;\n                            if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {\n                                const yUndoPluginState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.yUndoPluginKey.getState(view.state);\n                                /**\n                 * @type {Y.UndoManager}\n                 */ const um = yUndoPluginState && yUndoPluginState.undoManager;\n                                if (um) {\n                                    um.stopCapturing();\n                                }\n                            }\n                            binding.mux(()=>{\n                                /** @type {Y.Doc} */ pluginState.doc.transact((tr)=>{\n                                    tr.meta.set(\"addToHistory\", pluginState.addToHistory);\n                                    binding._prosemirrorChanged(view.state.doc);\n                                }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n                            });\n                        }\n                    }\n                },\n                destroy: ()=>{\n                    rerenderTimeout.destroy();\n                    binding.destroy();\n                }\n            };\n        }\n    });\n    return plugin;\n};\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */ const restoreRelativeSelection = (tr, relSel, binding)=>{\n    if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n        const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.anchor, binding.mapping);\n        const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.head, binding.mapping);\n        if (anchor !== null && head !== null) {\n            tr = tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, anchor, head));\n        }\n    }\n};\nconst getRelativeSelection = (pmbinding, state)=>({\n        anchor: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(state.selection.anchor, pmbinding.type, pmbinding.mapping),\n        head: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(state.selection.head, pmbinding.type, pmbinding.mapping)\n    });\n/**\n * Binding for prosemirror.\n *\n * @protected\n */ class ProsemirrorBinding {\n    /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {any} prosemirrorView The target binding\n   */ constructor(yXmlFragment, prosemirrorView){\n        this.type = yXmlFragment;\n        this.prosemirrorView = prosemirrorView;\n        this.mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_7__.createMutex)();\n        this.isDestroyed = false;\n        /**\n     * @type {ProsemirrorMapping}\n     */ this.mapping = new Map();\n        this._observeFunction = this._typeChanged.bind(this);\n        /**\n     * @type {Y.Doc}\n     */ // @ts-ignore\n        this.doc = yXmlFragment.doc;\n        /**\n     * current selection as relative positions in the Yjs model\n     */ this.beforeTransactionSelection = null;\n        this.beforeAllTransactions = ()=>{\n            if (this.beforeTransactionSelection === null) {\n                this.beforeTransactionSelection = getRelativeSelection(this, prosemirrorView.state);\n            }\n        };\n        this.afterAllTransactions = ()=>{\n            this.beforeTransactionSelection = null;\n        };\n        this.doc.on(\"beforeAllTransactions\", this.beforeAllTransactions);\n        this.doc.on(\"afterAllTransactions\", this.afterAllTransactions);\n        yXmlFragment.observeDeep(this._observeFunction);\n        this._domSelectionInView = null;\n    }\n    /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */ get _tr() {\n        return this.prosemirrorView.state.tr.setMeta(\"addToHistory\", false);\n    }\n    _isLocalCursorInView() {\n        if (!this.prosemirrorView.hasFocus()) return false;\n        if (lib0_environment__WEBPACK_IMPORTED_MODULE_8__.isBrowser && this._domSelectionInView === null) {\n            // Calculate the domSelectionInView and clear by next tick after all events are finished\n            lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, ()=>{\n                this._domSelectionInView = null;\n            });\n            this._domSelectionInView = this._isDomSelectionInView();\n        }\n        return this._domSelectionInView;\n    }\n    _isDomSelectionInView() {\n        const selection = this.prosemirrorView._root.getSelection();\n        const range = this.prosemirrorView._root.createRange();\n        range.setStart(selection.anchorNode, selection.anchorOffset);\n        range.setEnd(selection.focusNode, selection.focusOffset);\n        // This is a workaround for an edgecase where getBoundingClientRect will\n        // return zero values if the selection is collapsed at the start of a newline\n        // see reference here: https://stackoverflow.com/a/59780954\n        const rects = range.getClientRects();\n        if (rects.length === 0) {\n            // probably buggy newline behavior, explicitly select the node contents\n            if (range.startContainer && range.collapsed) {\n                range.selectNodeContents(range.startContainer);\n            }\n        }\n        const bounding = range.getBoundingClientRect();\n        const documentElement = lib0_dom__WEBPACK_IMPORTED_MODULE_9__.doc.documentElement;\n        return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);\n    }\n    /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   */ renderSnapshot(snapshot, prevSnapshot) {\n        if (!prevSnapshot) {\n            prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.createSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.createDeleteSet(), new Map());\n        }\n        this.prosemirrorView.dispatch(this._tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n            snapshot,\n            prevSnapshot\n        }));\n    }\n    unrenderSnapshot() {\n        this.mapping = new Map();\n        this.mux(()=>{\n            const fragmentContent = this.type.toArray().map((t)=>createNodeFromYElement(/** @type {Y.XmlElement} */ t, this.prosemirrorView.state.schema, this.mapping)).filter((n)=>n !== null);\n            // @ts-ignore\n            const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n            tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                snapshot: null,\n                prevSnapshot: null\n            });\n            this.prosemirrorView.dispatch(tr);\n        });\n    }\n    _forceRerender() {\n        this.mapping = new Map();\n        this.mux(()=>{\n            const fragmentContent = this.type.toArray().map((t)=>createNodeFromYElement(/** @type {Y.XmlElement} */ t, this.prosemirrorView.state.schema, this.mapping)).filter((n)=>n !== null);\n            // @ts-ignore\n            const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n            this.prosemirrorView.dispatch(tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                isChangeOrigin: true\n            }));\n        });\n    }\n    /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   * @param {Object} pluginState\n   */ _renderSnapshot(snapshot, prevSnapshot, pluginState) {\n        if (!snapshot) {\n            snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc);\n        }\n        // clear mapping because we are going to rerender\n        this.mapping = new Map();\n        this.mux(()=>{\n            this.doc.transact((transaction)=>{\n                // before rendering, we are going to sanitize ops and split deleted ops\n                // if they were deleted by seperate users.\n                const pud = pluginState.permanentUserData;\n                if (pud) {\n                    pud.dss.forEach((ds)=>{\n                        yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, ds, (_item)=>{});\n                    });\n                }\n                /**\n         * @param {'removed'|'added'} type\n         * @param {Y.ID} id\n         */ const computeYChange = (type, id)=>{\n                    const user = type === \"added\" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);\n                    return {\n                        user,\n                        type,\n                        color: getUserColor(pluginState.colorMapping, pluginState.colors, user)\n                    };\n                };\n                // Create document fragment and render\n                const fragmentContent = yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(this.type, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)).map((t)=>{\n                    if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {\n                        return createNodeFromYElement(t, this.prosemirrorView.state.schema, new Map(), snapshot, prevSnapshot, computeYChange);\n                    } else {\n                        // No need to render elements that are not visible by either snapshot.\n                        // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n                        return null;\n                    }\n                }).filter((n)=>n !== null);\n                // @ts-ignore\n                const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n                this.prosemirrorView.dispatch(tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                    isChangeOrigin: true\n                }));\n            }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n        });\n    }\n    /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */ _typeChanged(events, transaction) {\n        const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(this.prosemirrorView.state);\n        if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {\n            // drop out if snapshot is active\n            this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);\n            return;\n        }\n        this.mux(()=>{\n            /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */ const delType = (_, type)=>this.mapping.delete(type);\n            yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, transaction.deleteSet, (struct)=>{\n                if (struct.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.Item) {\n                    const type = /** @type {Y.ContentType} */ /** @type {Y.Item} */ struct.content.type;\n                    type && this.mapping.delete(type);\n                }\n            });\n            transaction.changed.forEach(delType);\n            transaction.changedParentTypes.forEach(delType);\n            const fragmentContent = this.type.toArray().map((t)=>createNodeIfNotExists(/** @type {Y.XmlElement | Y.XmlHook} */ t, this.prosemirrorView.state.schema, this.mapping)).filter((n)=>n !== null);\n            // @ts-ignore\n            let tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n            restoreRelativeSelection(tr, this.beforeTransactionSelection, this);\n            tr = tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                isChangeOrigin: true,\n                isUndoRedoOperation: transaction.origin instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.UndoManager\n            });\n            if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {\n                tr.scrollIntoView();\n            }\n            this.prosemirrorView.dispatch(tr);\n        });\n    }\n    _prosemirrorChanged(doc) {\n        this.doc.transact(()=>{\n            updateYFragment(this.doc, this.type, doc, this.mapping);\n            this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state);\n        }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n    }\n    destroy() {\n        this.isDestroyed = true;\n        this.type.unobserveDeep(this._observeFunction);\n        this.doc.off(\"beforeAllTransactions\", this.beforeAllTransactions);\n        this.doc.off(\"afterAllTransactions\", this.afterAllTransactions);\n    }\n}\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */ const createNodeIfNotExists = (el, schema, mapping, snapshot, prevSnapshot, computeYChange)=>{\n    const node = /** @type {PModel.Node} */ mapping.get(el);\n    if (node === undefined) {\n        if (el instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n            return createNodeFromYElement(el, schema, mapping, snapshot, prevSnapshot, computeYChange);\n        } else {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_11__.methodUnimplemented() // we are currently not handling hooks\n            ;\n        }\n    }\n    return node;\n};\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */ const createNodeFromYElement = (el, schema, mapping, snapshot, prevSnapshot, computeYChange)=>{\n    const children = [];\n    const createChildren = (type)=>{\n        if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n            const n = createNodeIfNotExists(type, schema, mapping, snapshot, prevSnapshot, computeYChange);\n            if (n !== null) {\n                children.push(n);\n            }\n        } else {\n            const ns = createTextNodesFromYText(type, schema, mapping, snapshot, prevSnapshot, computeYChange);\n            if (ns !== null) {\n                ns.forEach((textchild)=>{\n                    if (textchild !== null) {\n                        children.push(textchild);\n                    }\n                });\n            }\n        }\n    };\n    if (snapshot === undefined || prevSnapshot === undefined) {\n        el.toArray().forEach(createChildren);\n    } else {\n        yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(el, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren);\n    }\n    try {\n        const attrs = el.getAttributes(snapshot);\n        if (snapshot !== undefined) {\n            if (!isVisible(/** @type {Y.Item} */ el._item, snapshot)) {\n                attrs.ychange = computeYChange ? computeYChange(\"removed\", /** @type {Y.Item} */ el._item.id) : {\n                    type: \"removed\"\n                };\n            } else if (!isVisible(/** @type {Y.Item} */ el._item, prevSnapshot)) {\n                attrs.ychange = computeYChange ? computeYChange(\"added\", /** @type {Y.Item} */ el._item.id) : {\n                    type: \"added\"\n                };\n            }\n        }\n        const node = schema.node(el.nodeName, attrs, children);\n        mapping.set(el, node);\n        return node;\n    } catch (e) {\n        // an error occured while creating the node. This is probably a result of a concurrent action.\n        /** @type {Y.Doc} */ el.doc.transact((transaction)=>{\n            /** @type {Y.Item} */ el._item.delete(transaction);\n        }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n        mapping.delete(el);\n        return null;\n    }\n};\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {any} schema\n * @param {ProsemirrorMapping} _mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */ const createTextNodesFromYText = (text, schema, _mapping, snapshot, prevSnapshot, computeYChange)=>{\n    const nodes = [];\n    const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange);\n    try {\n        for(let i = 0; i < deltas.length; i++){\n            const delta = deltas[i];\n            const marks = [];\n            for(const markName in delta.attributes){\n                marks.push(schema.mark(markName, delta.attributes[markName]));\n            }\n            nodes.push(schema.text(delta.insert, marks));\n        }\n    } catch (e) {\n        // an error occured while creating the node. This is probably a result of a concurrent action.\n        /** @type {Y.Doc} */ text.doc.transact((transaction)=>{\n            /** @type {Y.Item} */ text._item.delete(transaction);\n        }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n        return null;\n    }\n    // @ts-ignore\n    return nodes;\n};\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlText}\n */ const createTypeFromTextNodes = (nodes, mapping)=>{\n    const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText();\n    const delta = nodes.map((node)=>({\n            // @ts-ignore\n            insert: node.text,\n            attributes: marksToAttributes(node.marks)\n        }));\n    type.applyDelta(delta);\n    mapping.set(type, nodes);\n    return type;\n};\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement}\n */ const createTypeFromElementNode = (node, mapping)=>{\n    const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement(node.type.name);\n    for(const key in node.attrs){\n        const val = node.attrs[key];\n        if (val !== null && key !== \"ychange\") {\n            type.setAttribute(key, val);\n        }\n    }\n    type.insert(0, normalizePNodeContent(node).map((n)=>createTypeFromTextOrElementNode(n, mapping)));\n    mapping.set(type, node);\n    return type;\n};\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement|Y.XmlText}\n */ const createTypeFromTextOrElementNode = (node, mapping)=>node instanceof Array ? createTypeFromTextNodes(node, mapping) : createTypeFromElementNode(node, mapping);\nconst isObject = (val)=>typeof val === \"object\" && val !== null;\nconst equalAttrs = (pattrs, yattrs)=>{\n    const keys = Object.keys(pattrs).filter((key)=>pattrs[key] !== null);\n    let eq = keys.length === Object.keys(yattrs).filter((key)=>yattrs[key] !== null).length;\n    for(let i = 0; i < keys.length && eq; i++){\n        const key = keys[i];\n        const l = pattrs[key];\n        const r = yattrs[key];\n        eq = key === \"ychange\" || l === r || isObject(l) && isObject(r) && equalAttrs(l, r);\n    }\n    return eq;\n};\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */ /**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */ const normalizePNodeContent = (pnode)=>{\n    const c = pnode.content.content;\n    const res = [];\n    for(let i = 0; i < c.length; i++){\n        const n = c[i];\n        if (n.isText) {\n            const textNodes = [];\n            for(let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]){\n                textNodes.push(tnode);\n            }\n            i--;\n            res.push(textNodes);\n        } else {\n            res.push(n);\n        }\n    }\n    return res;\n};\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */ const equalYTextPText = (ytext, ptexts)=>{\n    const delta = ytext.toDelta();\n    return delta.length === ptexts.length && delta.every((d, i)=>d.insert === /** @type {any} */ ptexts[i].text && lib0_object__WEBPACK_IMPORTED_MODULE_12__.keys(d.attributes || {}).length === ptexts[i].marks.length && ptexts[i].marks.every((mark)=>equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)));\n};\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */ const equalYTypePNode = (ytype, pnode)=>{\n    if (ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {\n        const normalizedContent = normalizePNodeContent(pnode);\n        return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every((ychild, i)=>equalYTypePNode(ychild, normalizedContent[i]));\n    }\n    return ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);\n};\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */ const mappedIdentity = (mapped, pcontent)=>mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every((a, i)=>pcontent[i] === a);\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {ProsemirrorMapping} mapping\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */ const computeChildEqualityFactor = (ytype, pnode, mapping)=>{\n    const yChildren = ytype.toArray();\n    const pChildren = normalizePNodeContent(pnode);\n    const pChildCnt = pChildren.length;\n    const yChildCnt = yChildren.length;\n    const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_13__.min(yChildCnt, pChildCnt);\n    let left = 0;\n    let right = 0;\n    let foundMappedChild = false;\n    for(; left < minCnt; left++){\n        const leftY = yChildren[left];\n        const leftP = pChildren[left];\n        if (mappedIdentity(mapping.get(leftY), leftP)) {\n            foundMappedChild = true // definite (good) match!\n            ;\n        } else if (!equalYTypePNode(leftY, leftP)) {\n            break;\n        }\n    }\n    for(; left + right < minCnt; right++){\n        const rightY = yChildren[yChildCnt - right - 1];\n        const rightP = pChildren[pChildCnt - right - 1];\n        if (mappedIdentity(mapping.get(rightY), rightP)) {\n            foundMappedChild = true;\n        } else if (!equalYTypePNode(rightY, rightP)) {\n            break;\n        }\n    }\n    return {\n        equalityFactor: left + right,\n        foundMappedChild\n    };\n};\nconst ytextTrans = (ytext)=>{\n    let str = \"\";\n    /**\n   * @type {Y.Item|null}\n   */ let n = ytext._start;\n    const nAttrs = {};\n    while(n !== null){\n        if (!n.deleted) {\n            if (n.countable && n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentString) {\n                str += n.content.str;\n            } else if (n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentFormat) {\n                nAttrs[n.content.key] = null;\n            }\n        }\n        n = n.right;\n    }\n    return {\n        str,\n        nAttrs\n    };\n};\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {ProsemirrorMapping} mapping\n */ const updateYText = (ytext, ptexts, mapping)=>{\n    mapping.set(ytext, ptexts);\n    const { nAttrs, str } = ytextTrans(ytext);\n    const content = ptexts.map((p)=>({\n            insert: /** @type {any} */ p.text,\n            attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks))\n        }));\n    const { insert, remove, index } = (0,lib0_diff__WEBPACK_IMPORTED_MODULE_14__.simpleDiff)(str, content.map((c)=>c.insert).join(\"\"));\n    ytext.delete(index, remove);\n    ytext.insert(index, insert);\n    ytext.applyDelta(content.map((c)=>({\n            retain: c.insert.length,\n            attributes: c.attributes\n        })));\n};\nconst marksToAttributes = (marks)=>{\n    const pattrs = {};\n    marks.forEach((mark)=>{\n        if (mark.type.name !== \"ychange\") {\n            pattrs[mark.type.name] = mark.attrs;\n        }\n    });\n    return pattrs;\n};\n/**\n * @private\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {ProsemirrorMapping} mapping\n */ const updateYFragment = (y, yDomFragment, pNode, mapping)=>{\n    if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && yDomFragment.nodeName !== pNode.type.name) {\n        throw new Error(\"node name mismatch!\");\n    }\n    mapping.set(yDomFragment, pNode);\n    // update attributes\n    if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n        const yDomAttrs = yDomFragment.getAttributes();\n        const pAttrs = pNode.attrs;\n        for(const key in pAttrs){\n            if (pAttrs[key] !== null) {\n                if (yDomAttrs[key] !== pAttrs[key] && key !== \"ychange\") {\n                    yDomFragment.setAttribute(key, pAttrs[key]);\n                }\n            } else {\n                yDomFragment.removeAttribute(key);\n            }\n        }\n        // remove all keys that are no longer in pAttrs\n        for(const key in yDomAttrs){\n            if (pAttrs[key] === undefined) {\n                yDomFragment.removeAttribute(key);\n            }\n        }\n    }\n    // update children\n    const pChildren = normalizePNodeContent(pNode);\n    const pChildCnt = pChildren.length;\n    const yChildren = yDomFragment.toArray();\n    const yChildCnt = yChildren.length;\n    const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_13__.min(pChildCnt, yChildCnt);\n    let left = 0;\n    let right = 0;\n    // find number of matching elements from left\n    for(; left < minCnt; left++){\n        const leftY = yChildren[left];\n        const leftP = pChildren[left];\n        if (!mappedIdentity(mapping.get(leftY), leftP)) {\n            if (equalYTypePNode(leftY, leftP)) {\n                // update mapping\n                mapping.set(leftY, leftP);\n            } else {\n                break;\n            }\n        }\n    }\n    // find number of matching elements from right\n    for(; right + left + 1 < minCnt; right++){\n        const rightY = yChildren[yChildCnt - right - 1];\n        const rightP = pChildren[pChildCnt - right - 1];\n        if (!mappedIdentity(mapping.get(rightY), rightP)) {\n            if (equalYTypePNode(rightY, rightP)) {\n                // update mapping\n                mapping.set(rightY, rightP);\n            } else {\n                break;\n            }\n        }\n    }\n    y.transact(()=>{\n        // try to compare and update\n        while(yChildCnt - left - right > 0 && pChildCnt - left - right > 0){\n            const leftY = yChildren[left];\n            const leftP = pChildren[left];\n            const rightY = yChildren[yChildCnt - right - 1];\n            const rightP = pChildren[pChildCnt - right - 1];\n            if (leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && leftP instanceof Array) {\n                if (!equalYTextPText(leftY, leftP)) {\n                    updateYText(leftY, leftP, mapping);\n                }\n                left += 1;\n            } else {\n                let updateLeft = leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && matchNodeName(leftY, leftP);\n                let updateRight = rightY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && matchNodeName(rightY, rightP);\n                if (updateLeft && updateRight) {\n                    // decide which which element to update\n                    const equalityLeft = computeChildEqualityFactor(/** @type {Y.XmlElement} */ leftY, /** @type {PModel.Node} */ leftP, mapping);\n                    const equalityRight = computeChildEqualityFactor(/** @type {Y.XmlElement} */ rightY, /** @type {PModel.Node} */ rightP, mapping);\n                    if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {\n                        updateRight = false;\n                    } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {\n                        updateLeft = false;\n                    } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {\n                        updateLeft = false;\n                    } else {\n                        updateRight = false;\n                    }\n                }\n                if (updateLeft) {\n                    updateYFragment(y, /** @type {Y.XmlFragment} */ leftY, /** @type {PModel.Node} */ leftP, mapping);\n                    left += 1;\n                } else if (updateRight) {\n                    updateYFragment(y, /** @type {Y.XmlFragment} */ rightY, /** @type {PModel.Node} */ rightP, mapping);\n                    right += 1;\n                } else {\n                    mapping.delete(yDomFragment.get(left));\n                    yDomFragment.delete(left, 1);\n                    yDomFragment.insert(left, [\n                        createTypeFromTextOrElementNode(leftP, mapping)\n                    ]);\n                    left += 1;\n                }\n            }\n        }\n        const yDelLen = yChildCnt - left - right;\n        if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText) {\n            mapping.delete(yChildren[0]);\n            // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n            // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n            yChildren[0].delete(0, yChildren[0].length);\n        } else if (yDelLen > 0) {\n            yDomFragment.slice(left, left + yDelLen).forEach((type)=>mapping.delete(type));\n            yDomFragment.delete(left, yDelLen);\n        }\n        if (left + right < pChildCnt) {\n            const ins = [];\n            for(let i = left; i < pChildCnt - right; i++){\n                ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping));\n            }\n            yDomFragment.insert(left, ins);\n        }\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n};\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */ const matchNodeName = (yElement, pNode)=>!(pNode instanceof Array) && yElement.nodeName === pNode.type.name;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBRXVDO0FBQ0c7QUFDZSxDQUFDLHNCQUFzQjtBQUNoRDtBQUNJO0FBQ047QUFDTztBQUNIO0FBQ3VCO0FBQ2xDO0FBSU47QUFDbUI7QUFDVTtBQUNoQjtBQUNZO0FBRTNDOzs7Q0FHQyxHQUNNLE1BQU1rQixZQUFZLENBQUNDLE1BQU1DLFdBQzlCQSxhQUFhQyxZQUNULENBQUNGLEtBQUtHLE9BQU8sR0FDWkYsU0FBU0csRUFBRSxDQUFDQyxHQUFHLENBQUNMLEtBQUtNLEVBQUUsQ0FBQ0MsTUFBTSxLQUMvQixtQkFEdUQsR0FDdEROLFNBQVNHLEVBQUUsQ0FBQ0ksR0FBRyxDQUFDUixLQUFLTSxFQUFFLENBQUNDLE1BQU0sSUFBS1AsS0FBS00sRUFBRSxDQUFDRyxLQUFLLElBQ2pELENBQUNqQiwwQ0FBVyxDQUFDUyxTQUFTVSxFQUFFLEVBQUVYLEtBQUtNLEVBQUUsRUFBRTtBQUV6Qzs7O0NBR0MsR0FFRDs7OztDQUlDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7O0NBRUMsR0FDRCxNQUFNTSxnQkFBZ0I7SUFBQztRQUFFQyxPQUFPO1FBQWFDLE1BQU07SUFBVTtDQUFFO0FBRS9EOzs7OztDQUtDLEdBQ0QsTUFBTUMsZUFBZSxDQUFDQyxjQUFjQyxRQUFRQztJQUMxQyxvREFBb0Q7SUFDcEQsSUFBSSxDQUFDRixhQUFhWCxHQUFHLENBQUNhLE9BQU87UUFDM0IsSUFBSUYsYUFBYUcsSUFBSSxHQUFHRixPQUFPRyxNQUFNLEVBQUU7WUFDckMsTUFBTUMsYUFBYWxDLDRDQUFVO1lBQzdCNkIsYUFBYU8sT0FBTyxDQUFDLENBQUNDLFFBQVVILFdBQVdJLEdBQUcsQ0FBQ0Q7WUFDL0NQLFNBQVNBLE9BQU9TLE1BQU0sQ0FBQyxDQUFDRixRQUFVLENBQUNILFdBQVdoQixHQUFH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QyxHQUFHaUYsU0FBUyxDQUFDLEVBQUUsQ0FBQzlOLE1BQU07UUFDNUMsT0FBTyxJQUFJa1EsVUFBVSxHQUFHO1lBQ3RCVixhQUFhVyxLQUFLLENBQUN6SixNQUFNQSxPQUFPd0osU0FBUy9QLE9BQU8sQ0FBQ3VCLENBQUFBLE9BQVF3QyxRQUFRMkUsTUFBTSxDQUFDbkg7WUFDeEU4TixhQUFhM0csTUFBTSxDQUFDbkMsTUFBTXdKO1FBQzVCO1FBQ0EsSUFBSXhKLE9BQU9ELFFBQVF1SCxXQUFXO1lBQzVCLE1BQU1vQyxNQUFNLEVBQUU7WUFDZCxJQUFLLElBQUl0RixJQUFJcEUsTUFBTW9FLElBQUlrRCxZQUFZdkgsT0FBT3FFLElBQUs7Z0JBQzdDc0YsSUFBSXBHLElBQUksQ0FBQzhCLGdDQUFnQ2lDLFNBQVMsQ0FBQ2pELEVBQUUsRUFBRTVHO1lBQ3pEO1lBQ0FzTCxhQUFhcEUsTUFBTSxDQUFDMUUsTUFBTTBKO1FBQzVCO0lBQ0YsR0FBR2xTLG9EQUFjQTtBQUNuQixFQUFDO0FBRUQ7Ozs7Q0FJQyxHQUNELE1BQU1tUCxnQkFBZ0IsQ0FBQ2dELFVBQVVaLFFBQy9CLENBQUVBLENBQUFBLGlCQUFpQjFELEtBQUksS0FBTXNFLFNBQVM5RixRQUFRLEtBQUtrRixNQUFNL04sSUFBSSxDQUFDZ0ssSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlLWpvdXJuYWwvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcz8wZWUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBiaW5kaW5ncy9wcm9zZW1pcnJvclxuICovXG5cbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleCdcbmltcG9ydCAqIGFzIFBNb2RlbCBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICdsaWIwL29iamVjdCdcbmltcG9ydCAqIGFzIHNldCBmcm9tICdsaWIwL3NldCdcbmltcG9ydCB7IHNpbXBsZURpZmYgfSBmcm9tICdsaWIwL2RpZmYnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0IHsgeVN5bmNQbHVnaW5LZXksIHlVbmRvUGx1Z2luS2V5IH0gZnJvbSAnLi9rZXlzLmpzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQge1xuICBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uLFxuICByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uXG59IGZyb20gJy4uL2xpYi5qcydcbmltcG9ydCAqIGFzIHJhbmRvbSBmcm9tICdsaWIwL3JhbmRvbSdcbmltcG9ydCAqIGFzIGVudmlyb25tZW50IGZyb20gJ2xpYjAvZW52aXJvbm1lbnQnXG5pbXBvcnQgKiBhcyBkb20gZnJvbSAnbGliMC9kb20nXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnbGliMC9ldmVudGxvb3AnXG5cbi8qKlxuICogQHBhcmFtIHtZLkl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICovXG5leHBvcnQgY29uc3QgaXNWaXNpYmxlID0gKGl0ZW0sIHNuYXBzaG90KSA9PlxuICBzbmFwc2hvdCA9PT0gdW5kZWZpbmVkXG4gICAgPyAhaXRlbS5kZWxldGVkXG4gICAgOiAoc25hcHNob3Quc3YuaGFzKGl0ZW0uaWQuY2xpZW50KSAmJiAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpKSA+IGl0ZW0uaWQuY2xvY2sgJiZcbiAgICAgICFZLmlzRGVsZXRlZChzbmFwc2hvdC5kcywgaXRlbS5pZCkpXG5cbi8qKlxuICogRWl0aGVyIGEgbm9kZSBpZiB0eXBlIGlzIFlYbWxFbGVtZW50IG9yIGFuIEFycmF5IG9mIHRleHQgbm9kZXMgaWYgWVhtbFRleHRcbiAqIEB0eXBlZGVmIHtNYXA8WS5BYnN0cmFjdFR5cGU8YW55PiwgUE1vZGVsLk5vZGUgfCBBcnJheTxQTW9kZWwuTm9kZT4+fSBQcm9zZW1pcnJvck1hcHBpbmdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbG9yRGVmXG4gKiBAcHJvcGVydHkge3N0cmluZ30gQ29sb3JEZWYubGlnaHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDb2xvckRlZi5kYXJrXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBZU3luY09wdHNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8Q29sb3JEZWY+fSBbWVN5bmNPcHRzLmNvbG9yc11cbiAqIEBwcm9wZXJ0eSB7TWFwPHN0cmluZyxDb2xvckRlZj59IFtZU3luY09wdHMuY29sb3JNYXBwaW5nXVxuICogQHByb3BlcnR5IHtZLlBlcm1hbmVudFVzZXJEYXRhfG51bGx9IFtZU3luY09wdHMucGVybWFuZW50VXNlckRhdGFdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbWVN5bmNPcHRzLm9uRmlyc3RSZW5kZXJdIEZpcmVkIHdoZW4gdGhlIGNvbnRlbnQgZnJvbSBZanMgaXMgaW5pdGlhbGx5IHJlbmRlcmVkIHRvIFByb3NlTWlycm9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8Q29sb3JEZWY+fVxuICovXG5jb25zdCBkZWZhdWx0Q29sb3JzID0gW3sgbGlnaHQ6ICcjZWNkNDQ0MzMnLCBkYXJrOiAnI2VjZDQ0NCcgfV1cblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsQ29sb3JEZWY+fSBjb2xvck1hcHBpbmdcbiAqIEBwYXJhbSB7QXJyYXk8Q29sb3JEZWY+fSBjb2xvcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyXG4gKiBAcmV0dXJuIHtDb2xvckRlZn1cbiAqL1xuY29uc3QgZ2V0VXNlckNvbG9yID0gKGNvbG9yTWFwcGluZywgY29sb3JzLCB1c2VyKSA9PiB7XG4gIC8vIEB0b2RvIGRvIG5vdCBoaXQgdGhlIHNhbWUgY29sb3IgdHdpY2UgaWYgcG9zc2libGVcbiAgaWYgKCFjb2xvck1hcHBpbmcuaGFzKHVzZXIpKSB7XG4gICAgaWYgKGNvbG9yTWFwcGluZy5zaXplIDwgY29sb3JzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdXNlZENvbG9ycyA9IHNldC5jcmVhdGUoKVxuICAgICAgY29sb3JNYXBwaW5nLmZvckVhY2goKGNvbG9yKSA9PiB1c2VkQ29sb3JzLmFkZChjb2xvcikpXG4gICAgICBjb2xvcnMgPSBjb2xvcnMuZmlsdGVyKChjb2xvcikgPT4gIXVzZWRDb2xvcnMuaGFzKGNvbG9yKSlcbiAgICB9XG4gICAgY29sb3JNYXBwaW5nLnNldCh1c2VyLCByYW5kb20ub25lT2YoY29sb3JzKSlcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtDb2xvckRlZn0gKi8gKGNvbG9yTWFwcGluZy5nZXQodXNlcikpXG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gbGlzdGVucyB0byBjaGFuZ2VzIGluIHByb3NlbWlycm9yIHZpZXcgYW5kIGtlZXBzIHlYbWxTdGF0ZSBhbmQgdmlldyBpbiBzeW5jLlxuICpcbiAqIFRoaXMgcGx1Z2luIGFsc28ga2VlcHMgcmVmZXJlbmNlcyB0byB0aGUgdHlwZSBhbmQgdGhlIHNoYXJlZCBkb2N1bWVudCBzbyBvdGhlciBwbHVnaW5zIGNhbiBhY2Nlc3MgaXQuXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlYbWxGcmFnbWVudFxuICogQHBhcmFtIHtZU3luY09wdHN9IG9wdHNcbiAqIEByZXR1cm4ge2FueX0gUmV0dXJucyBhIHByb3NlbWlycm9yIHBsdWdpbiB0aGF0IGJpbmRzIHRvIHRoaXMgdHlwZVxuICovXG5leHBvcnQgY29uc3QgeVN5bmNQbHVnaW4gPSAoeVhtbEZyYWdtZW50LCB7XG4gIGNvbG9ycyA9IGRlZmF1bHRDb2xvcnMsXG4gIGNvbG9yTWFwcGluZyA9IG5ldyBNYXAoKSxcbiAgcGVybWFuZW50VXNlckRhdGEgPSBudWxsLFxuICBvbkZpcnN0UmVuZGVyID0gKCkgPT4ge31cbn0gPSB7fSkgPT4ge1xuICBsZXQgY2hhbmdlZEluaXRpYWxDb250ZW50ID0gZmFsc2VcbiAgbGV0IHJlcmVuZGVyVGltZW91dFxuICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICBwcm9wczoge1xuICAgICAgZWRpdGFibGU6IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHN5bmNTdGF0ZS5zbmFwc2hvdCA9PSBudWxsICYmIHN5bmNTdGF0ZS5wcmV2U25hcHNob3QgPT0gbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAga2V5OiB5U3luY1BsdWdpbktleSxcbiAgICBzdGF0ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAgICovXG4gICAgICBpbml0OiAoX2luaXRhcmdzLCBfc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB5WG1sRnJhZ21lbnQsXG4gICAgICAgICAgZG9jOiB5WG1sRnJhZ21lbnQuZG9jLFxuICAgICAgICAgIGJpbmRpbmc6IG51bGwsXG4gICAgICAgICAgc25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgcHJldlNuYXBzaG90OiBudWxsLFxuICAgICAgICAgIGlzQ2hhbmdlT3JpZ2luOiBmYWxzZSxcbiAgICAgICAgICBpc1VuZG9SZWRvT3BlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBhZGRUb0hpc3Rvcnk6IHRydWUsXG4gICAgICAgICAgY29sb3JzLFxuICAgICAgICAgIGNvbG9yTWFwcGluZyxcbiAgICAgICAgICBwZXJtYW5lbnRVc2VyRGF0YVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXBwbHk6ICh0ciwgcGx1Z2luU3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gdHIuZ2V0TWV0YSh5U3luY1BsdWdpbktleSlcbiAgICAgICAgaWYgKGNoYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGx1Z2luU3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwbHVnaW5TdGF0ZSlcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHBsdWdpblN0YXRlW2tleV0gPSBjaGFuZ2Vba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwbHVnaW5TdGF0ZS5hZGRUb0hpc3RvcnkgPSB0ci5nZXRNZXRhKCdhZGRUb0hpc3RvcnknKSAhPT0gZmFsc2VcbiAgICAgICAgLy8gYWx3YXlzIHNldCBpc0NoYW5nZU9yaWdpbi4gSWYgdW5kZWZpbmVkLCB0aGlzIGlzIG5vdCBjaGFuZ2Ugb3JpZ2luLlxuICAgICAgICBwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpbiA9IGNoYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgISFjaGFuZ2UuaXNDaGFuZ2VPcmlnaW5cbiAgICAgICAgcGx1Z2luU3RhdGUuaXNVbmRvUmVkb09wZXJhdGlvbiA9IGNoYW5nZSAhPT0gdW5kZWZpbmVkICYmICEhY2hhbmdlLmlzQ2hhbmdlT3JpZ2luICYmICEhY2hhbmdlLmlzVW5kb1JlZG9PcGVyYXRpb25cbiAgICAgICAgaWYgKHBsdWdpblN0YXRlLmJpbmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaGFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zbmFwc2hvdCAhPSBudWxsIHx8IGNoYW5nZS5wcmV2U25hcHNob3QgIT0gbnVsbClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNoYW5nZWQsIHJlcmVuZGVyIG5leHRcbiAgICAgICAgICAgIGV2ZW50bG9vcC50aW1lb3V0KDAsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBsdWdpblN0YXRlLmJpbmRpbmcgPT0gbnVsbCB8fCBwbHVnaW5TdGF0ZS5iaW5kaW5nLmlzRGVzdHJveWVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYmluZGluZy5fcmVuZGVyU25hcHNob3QoXG4gICAgICAgICAgICAgICAgICBjaGFuZ2Uuc25hcHNob3QsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldlNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgcGx1Z2luU3RhdGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYmluZGluZy5fcmVuZGVyU25hcHNob3QoXG4gICAgICAgICAgICAgICAgICBjaGFuZ2Uuc25hcHNob3QsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2Uuc25hcHNob3QsXG4gICAgICAgICAgICAgICAgICBwbHVnaW5TdGF0ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0byBjdXJyZW50IHByb3NlbWlycm9yIHN0YXRlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnJlc3RvcmVcbiAgICAgICAgICAgICAgICBkZWxldGUgcGx1Z2luU3RhdGUuc25hcHNob3RcbiAgICAgICAgICAgICAgICBkZWxldGUgcGx1Z2luU3RhdGUucHJldlNuYXBzaG90XG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYmluZGluZy5tdXgoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYmluZGluZy5fcHJvc2VtaXJyb3JDaGFuZ2VkKFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5TdGF0ZS5iaW5kaW5nLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2NcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2luU3RhdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIHZpZXc6ICh2aWV3KSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gbmV3IFByb3NlbWlycm9yQmluZGluZyh5WG1sRnJhZ21lbnQsIHZpZXcpXG4gICAgICBpZiAocmVyZW5kZXJUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgcmVyZW5kZXJUaW1lb3V0LmRlc3Ryb3koKVxuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgaXMgY2FsbGVkIGluIGEgc2VwYXJhdGUgY29udGV4dFxuICAgICAgcmVyZW5kZXJUaW1lb3V0ID0gZXZlbnRsb29wLnRpbWVvdXQoMCwgKCkgPT4ge1xuICAgICAgICBiaW5kaW5nLl9mb3JjZVJlcmVuZGVyKClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgYmluZGluZyB9KSlcbiAgICAgICAgb25GaXJzdFJlbmRlcigpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luU3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwbHVnaW5TdGF0ZS5zbmFwc2hvdCA9PSBudWxsICYmIHBsdWdpblN0YXRlLnByZXZTbmFwc2hvdCA9PSBudWxsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGNoYW5nZWRJbml0aWFsQ29udGVudCB8fFxuICAgICAgICAgICAgICB2aWV3LnN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5kb2MudHlwZS5jcmVhdGVBbmRGaWxsKCkuY29udGVudFxuICAgICAgICAgICAgICApICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY2hhbmdlZEluaXRpYWxDb250ZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYWRkVG9IaXN0b3J5ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5VW5kb1BsdWdpblN0YXRlID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7WS5VbmRvTWFuYWdlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB1bSA9IHlVbmRvUGx1Z2luU3RhdGUgJiYgeVVuZG9QbHVnaW5TdGF0ZS51bmRvTWFuYWdlclxuICAgICAgICAgICAgICAgIGlmICh1bSkge1xuICAgICAgICAgICAgICAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAocGx1Z2luU3RhdGUuZG9jKS50cmFuc2FjdCgodHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyLm1ldGEuc2V0KCdhZGRUb0hpc3RvcnknLCBwbHVnaW5TdGF0ZS5hZGRUb0hpc3RvcnkpXG4gICAgICAgICAgICAgICAgICBiaW5kaW5nLl9wcm9zZW1pcnJvckNoYW5nZWQodmlldy5zdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgcmVyZW5kZXJUaW1lb3V0LmRlc3Ryb3koKVxuICAgICAgICAgIGJpbmRpbmcuZGVzdHJveSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBwbHVnaW5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdHJcbiAqIEBwYXJhbSB7YW55fSByZWxTZWxcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JCaW5kaW5nfSBiaW5kaW5nXG4gKi9cbmNvbnN0IHJlc3RvcmVSZWxhdGl2ZVNlbGVjdGlvbiA9ICh0ciwgcmVsU2VsLCBiaW5kaW5nKSA9PiB7XG4gIGlmIChyZWxTZWwgIT09IG51bGwgJiYgcmVsU2VsLmFuY2hvciAhPT0gbnVsbCAmJiByZWxTZWwuaGVhZCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICBiaW5kaW5nLmRvYyxcbiAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgIHJlbFNlbC5hbmNob3IsXG4gICAgICBiaW5kaW5nLm1hcHBpbmdcbiAgICApXG4gICAgY29uc3QgaGVhZCA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICBiaW5kaW5nLmRvYyxcbiAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgIHJlbFNlbC5oZWFkLFxuICAgICAgYmluZGluZy5tYXBwaW5nXG4gICAgKVxuICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCkge1xuICAgICAgdHIgPSB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBhbmNob3IsIGhlYWQpKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UmVsYXRpdmVTZWxlY3Rpb24gPSAocG1iaW5kaW5nLCBzdGF0ZSkgPT4gKHtcbiAgYW5jaG9yOiBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKFxuICAgIHN0YXRlLnNlbGVjdGlvbi5hbmNob3IsXG4gICAgcG1iaW5kaW5nLnR5cGUsXG4gICAgcG1iaW5kaW5nLm1hcHBpbmdcbiAgKSxcbiAgaGVhZDogYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICBzdGF0ZS5zZWxlY3Rpb24uaGVhZCxcbiAgICBwbWJpbmRpbmcudHlwZSxcbiAgICBwbWJpbmRpbmcubWFwcGluZ1xuICApXG59KVxuXG4vKipcbiAqIEJpbmRpbmcgZm9yIHByb3NlbWlycm9yLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIFByb3NlbWlycm9yQmluZGluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlYbWxGcmFnbWVudCBUaGUgYmluZCBzb3VyY2VcbiAgICogQHBhcmFtIHthbnl9IHByb3NlbWlycm9yVmlldyBUaGUgdGFyZ2V0IGJpbmRpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5WG1sRnJhZ21lbnQsIHByb3NlbWlycm9yVmlldykge1xuICAgIHRoaXMudHlwZSA9IHlYbWxGcmFnbWVudFxuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3ID0gcHJvc2VtaXJyb3JWaWV3XG4gICAgdGhpcy5tdXggPSBjcmVhdGVNdXRleCgpXG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb3NlbWlycm9yTWFwcGluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9vYnNlcnZlRnVuY3Rpb24gPSB0aGlzLl90eXBlQ2hhbmdlZC5iaW5kKHRoaXMpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1kuRG9jfVxuICAgICAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmRvYyA9IHlYbWxGcmFnbWVudC5kb2NcbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHNlbGVjdGlvbiBhcyByZWxhdGl2ZSBwb3NpdGlvbnMgaW4gdGhlIFlqcyBtb2RlbFxuICAgICAqL1xuICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBudWxsXG4gICAgdGhpcy5iZWZvcmVBbGxUcmFuc2FjdGlvbnMgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gZ2V0UmVsYXRpdmVTZWxlY3Rpb24oXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBwcm9zZW1pcnJvclZpZXcuc3RhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xuICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLmRvYy5vbignYmVmb3JlQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5iZWZvcmVBbGxUcmFuc2FjdGlvbnMpXG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5hZnRlckFsbFRyYW5zYWN0aW9ucylcbiAgICB5WG1sRnJhZ21lbnQub2JzZXJ2ZURlZXAodGhpcy5fb2JzZXJ2ZUZ1bmN0aW9uKVxuXG4gICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGZvciBjaGFuZ2luZyB0aGUgcHJvc2VtaXJyb3Igc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXQgX3RyICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUudHIuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG4gIH1cblxuICBfaXNMb2NhbEN1cnNvckluVmlldyAoKSB7XG4gICAgaWYgKCF0aGlzLnByb3NlbWlycm9yVmlldy5oYXNGb2N1cygpKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoZW52aXJvbm1lbnQuaXNCcm93c2VyICYmIHRoaXMuX2RvbVNlbGVjdGlvbkluVmlldyA9PT0gbnVsbCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkb21TZWxlY3Rpb25JblZpZXcgYW5kIGNsZWFyIGJ5IG5leHQgdGljayBhZnRlciBhbGwgZXZlbnRzIGFyZSBmaW5pc2hlZFxuICAgICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSBudWxsXG4gICAgICB9KVxuICAgICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gdGhpcy5faXNEb21TZWxlY3Rpb25JblZpZXcoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3XG4gIH1cblxuICBfaXNEb21TZWxlY3Rpb25JblZpZXcgKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmdldFNlbGVjdGlvbigpXG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmNyZWF0ZVJhbmdlKClcbiAgICByYW5nZS5zZXRTdGFydChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldClcbiAgICByYW5nZS5zZXRFbmQoc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KVxuXG4gICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGFuIGVkZ2VjYXNlIHdoZXJlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB3aWxsXG4gICAgLy8gcmV0dXJuIHplcm8gdmFsdWVzIGlmIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkIGF0IHRoZSBzdGFydCBvZiBhIG5ld2xpbmVcbiAgICAvLyBzZWUgcmVmZXJlbmNlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81OTc4MDk1NFxuICAgIGNvbnN0IHJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVxuICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHByb2JhYmx5IGJ1Z2d5IG5ld2xpbmUgYmVoYXZpb3IsIGV4cGxpY2l0bHkgc2VsZWN0IHRoZSBub2RlIGNvbnRlbnRzXG4gICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIgJiYgcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhyYW5nZS5zdGFydENvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBib3VuZGluZyA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9tLmRvYy5kb2N1bWVudEVsZW1lbnRcblxuICAgIHJldHVybiBib3VuZGluZy5ib3R0b20gPj0gMCAmJiBib3VuZGluZy5yaWdodCA+PSAwICYmXG4gICAgICBib3VuZGluZy5sZWZ0IDw9XG4gICAgICAgICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgJiZcbiAgICAgIGJvdW5kaW5nLnRvcCA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R9IHNuYXBzaG90XG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gcHJldlNuYXBzaG90XG4gICAqL1xuICByZW5kZXJTbmFwc2hvdCAoc25hcHNob3QsIHByZXZTbmFwc2hvdCkge1xuICAgIGlmICghcHJldlNuYXBzaG90KSB7XG4gICAgICBwcmV2U25hcHNob3QgPSBZLmNyZWF0ZVNuYXBzaG90KFkuY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSlcbiAgICB9XG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLl90ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IHNuYXBzaG90LCBwcmV2U25hcHNob3QgfSlcbiAgICApXG4gIH1cblxuICB1bnJlbmRlclNuYXBzaG90ICgpIHtcbiAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwKClcbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB0aGlzLnR5cGUudG9BcnJheSgpLm1hcCgodCkgPT5cbiAgICAgICAgY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHQpLFxuICAgICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNjaGVtYSxcbiAgICAgICAgICB0aGlzLm1hcHBpbmdcbiAgICAgICAgKVxuICAgICAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgIClcbiAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgc25hcHNob3Q6IG51bGwsIHByZXZTbmFwc2hvdDogbnVsbCB9KVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIF9mb3JjZVJlcmVuZGVyICgpIHtcbiAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwKClcbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB0aGlzLnR5cGUudG9BcnJheSgpLm1hcCgodCkgPT5cbiAgICAgICAgY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHQpLFxuICAgICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNjaGVtYSxcbiAgICAgICAgICB0aGlzLm1hcHBpbmdcbiAgICAgICAgKVxuICAgICAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgIClcbiAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKFxuICAgICAgICB0ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IGlzQ2hhbmdlT3JpZ2luOiB0cnVlIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R9IHNuYXBzaG90XG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gcHJldlNuYXBzaG90XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5TdGF0ZVxuICAgKi9cbiAgX3JlbmRlclNuYXBzaG90IChzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBwbHVnaW5TdGF0ZSkge1xuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHNuYXBzaG90ID0gWS5zbmFwc2hvdCh0aGlzLmRvYylcbiAgICB9XG4gICAgLy8gY2xlYXIgbWFwcGluZyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byByZXJlbmRlclxuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIHRoaXMuZG9jLnRyYW5zYWN0KCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAvLyBiZWZvcmUgcmVuZGVyaW5nLCB3ZSBhcmUgZ29pbmcgdG8gc2FuaXRpemUgb3BzIGFuZCBzcGxpdCBkZWxldGVkIG9wc1xuICAgICAgICAvLyBpZiB0aGV5IHdlcmUgZGVsZXRlZCBieSBzZXBlcmF0ZSB1c2Vycy5cbiAgICAgICAgY29uc3QgcHVkID0gcGx1Z2luU3RhdGUucGVybWFuZW50VXNlckRhdGFcbiAgICAgICAgaWYgKHB1ZCkge1xuICAgICAgICAgIHB1ZC5kc3MuZm9yRWFjaCgoZHMpID0+IHtcbiAgICAgICAgICAgIFkuaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBkcywgKF9pdGVtKSA9PiB7fSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geydyZW1vdmVkJ3wnYWRkZWQnfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7WS5JRH0gaWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNvbXB1dGVZQ2hhbmdlID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlciA9IHR5cGUgPT09ICdhZGRlZCdcbiAgICAgICAgICAgID8gcHVkLmdldFVzZXJCeUNsaWVudElkKGlkLmNsaWVudClcbiAgICAgICAgICAgIDogcHVkLmdldFVzZXJCeURlbGV0ZWRJZChpZClcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjb2xvcjogZ2V0VXNlckNvbG9yKFxuICAgICAgICAgICAgICBwbHVnaW5TdGF0ZS5jb2xvck1hcHBpbmcsXG4gICAgICAgICAgICAgIHBsdWdpblN0YXRlLmNvbG9ycyxcbiAgICAgICAgICAgICAgdXNlclxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgZG9jdW1lbnQgZnJhZ21lbnQgYW5kIHJlbmRlclxuICAgICAgICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSBZLnR5cGVMaXN0VG9BcnJheVNuYXBzaG90KFxuICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgICBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KVxuICAgICAgICApLm1hcCgodCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICF0Ll9pdGVtLmRlbGV0ZWQgfHwgaXNWaXNpYmxlKHQuX2l0ZW0sIHNuYXBzaG90KSB8fFxuICAgICAgICAgICAgaXNWaXNpYmxlKHQuX2l0ZW0sIHByZXZTbmFwc2hvdClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgICAgIG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW5kZXIgZWxlbWVudHMgdGhhdCBhcmUgbm90IHZpc2libGUgYnkgZWl0aGVyIHNuYXBzaG90LlxuICAgICAgICAgICAgLy8gSWYgYSBjbGllbnQgYWRkcyBhbmQgZGVsZXRlcyBjb250ZW50IGluIHRoZSBzYW1lIHNuYXBzaG90IHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlIGJ5IGVpdGhlciBzbmFwc2hvdC5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLl90ci5yZXBsYWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgICBuZXcgUE1vZGVsLlNsaWNlKFBNb2RlbC5GcmFnbWVudC5mcm9tKGZyYWdtZW50Q29udGVudCksIDAsIDApXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICAgICAgdHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBpc0NoYW5nZU9yaWdpbjogdHJ1ZSB9KVxuICAgICAgICApXG4gICAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8WS5ZRXZlbnQ8YW55Pj59IGV2ZW50c1xuICAgKiBAcGFyYW0ge1kuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdHlwZUNoYW5nZWQgKGV2ZW50cywgdHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZSlcbiAgICBpZiAoXG4gICAgICBldmVudHMubGVuZ3RoID09PSAwIHx8IHN5bmNTdGF0ZS5zbmFwc2hvdCAhPSBudWxsIHx8XG4gICAgICBzeW5jU3RhdGUucHJldlNuYXBzaG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIC8vIGRyb3Agb3V0IGlmIHNuYXBzaG90IGlzIGFjdGl2ZVxuICAgICAgdGhpcy5yZW5kZXJTbmFwc2hvdChzeW5jU3RhdGUuc25hcHNob3QsIHN5bmNTdGF0ZS5wcmV2U25hcHNob3QpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2FueX0gX1xuICAgICAgICogQHBhcmFtIHtZLkFic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbFR5cGUgPSAoXywgdHlwZSkgPT4gdGhpcy5tYXBwaW5nLmRlbGV0ZSh0eXBlKVxuICAgICAgWS5pdGVyYXRlRGVsZXRlZFN0cnVjdHMoXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGVTZXQsXG4gICAgICAgIChzdHJ1Y3QpID0+IHtcbiAgICAgICAgICBpZiAoc3RydWN0LmNvbnN0cnVjdG9yID09PSBZLkl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKHN0cnVjdCkuY29udGVudCkudHlwZVxuICAgICAgICAgICAgdHlwZSAmJiB0aGlzLm1hcHBpbmcuZGVsZXRlKHR5cGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goZGVsVHlwZSlcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKGRlbFR5cGUpXG4gICAgICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB0aGlzLnR5cGUudG9BcnJheSgpLm1hcCgodCkgPT5cbiAgICAgICAgY3JlYXRlTm9kZUlmTm90RXhpc3RzKFxuICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50IHwgWS5YbWxIb29rfSAqLyAodCksXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHRoaXMubWFwcGluZ1xuICAgICAgICApXG4gICAgICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxldCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgIClcbiAgICAgIHJlc3RvcmVSZWxhdGl2ZVNlbGVjdGlvbih0ciwgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiwgdGhpcylcbiAgICAgIHRyID0gdHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBpc0NoYW5nZU9yaWdpbjogdHJ1ZSwgaXNVbmRvUmVkb09wZXJhdGlvbjogdHJhbnNhY3Rpb24ub3JpZ2luIGluc3RhbmNlb2YgWS5VbmRvTWFuYWdlciB9KVxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uICE9PSBudWxsICYmIHRoaXMuX2lzTG9jYWxDdXJzb3JJblZpZXcoKVxuICAgICAgKSB7XG4gICAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKHRyKVxuICAgIH0pXG4gIH1cblxuICBfcHJvc2VtaXJyb3JDaGFuZ2VkIChkb2MpIHtcbiAgICB0aGlzLmRvYy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICB1cGRhdGVZRnJhZ21lbnQodGhpcy5kb2MsIHRoaXMudHlwZSwgZG9jLCB0aGlzLm1hcHBpbmcpXG4gICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gZ2V0UmVsYXRpdmVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlXG4gICAgICApXG4gICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIHRoaXMudHlwZS51bm9ic2VydmVEZWVwKHRoaXMuX29ic2VydmVGdW5jdGlvbilcbiAgICB0aGlzLmRvYy5vZmYoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIHRoaXMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zKVxuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50IHwgWS5YbWxIb29rfSBlbFxuICogQHBhcmFtIHtQTW9kZWwuU2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtQTW9kZWwuTm9kZSB8IG51bGx9XG4gKi9cbmNvbnN0IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyA9IChcbiAgZWwsXG4gIHNjaGVtYSxcbiAgbWFwcGluZyxcbiAgc25hcHNob3QsXG4gIHByZXZTbmFwc2hvdCxcbiAgY29tcHV0ZVlDaGFuZ2VcbikgPT4ge1xuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKG1hcHBpbmcuZ2V0KGVsKSlcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAgIGVsLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG1hcHBpbmcsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBwcmV2U25hcHNob3QsXG4gICAgICAgIGNvbXB1dGVZQ2hhbmdlXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKSAvLyB3ZSBhcmUgY3VycmVudGx5IG5vdCBoYW5kbGluZyBob29rc1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7YW55fSBzY2hlbWFcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtQTW9kZWwuTm9kZSB8IG51bGx9IFJldHVybnMgbm9kZSBpZiBub2RlIGNvdWxkIGJlIGNyZWF0ZWQuIE90aGVyd2lzZSBpdCBkZWxldGVzIHRoZSB5anMgdHlwZSBhbmQgcmV0dXJucyBudWxsXG4gKi9cbmNvbnN0IGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQgPSAoXG4gIGVsLFxuICBzY2hlbWEsXG4gIG1hcHBpbmcsXG4gIHNuYXBzaG90LFxuICBwcmV2U25hcHNob3QsXG4gIGNvbXB1dGVZQ2hhbmdlXG4pID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICBjb25zdCBjcmVhdGVDaGlsZHJlbiA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUuY29uc3RydWN0b3IgPT09IFkuWG1sRWxlbWVudCkge1xuICAgICAgY29uc3QgbiA9IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyhcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtYXBwaW5nLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBucyA9IGNyZWF0ZVRleHROb2Rlc0Zyb21ZVGV4dChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtYXBwaW5nLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG5zICE9PSBudWxsKSB7XG4gICAgICAgIG5zLmZvckVhY2goKHRleHRjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0Y2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dGNoaWxkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgfHwgcHJldlNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbC50b0FycmF5KCkuZm9yRWFjaChjcmVhdGVDaGlsZHJlbilcbiAgfSBlbHNlIHtcbiAgICBZLnR5cGVMaXN0VG9BcnJheVNuYXBzaG90KGVsLCBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KSlcbiAgICAgIC5mb3JFYWNoKGNyZWF0ZUNoaWxkcmVuKVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYXR0cnMgPSBlbC5nZXRBdHRyaWJ1dGVzKHNuYXBzaG90KVxuICAgIGlmIChzbmFwc2hvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgc25hcHNob3QpKSB7XG4gICAgICAgIGF0dHJzLnljaGFuZ2UgPSBjb21wdXRlWUNoYW5nZVxuICAgICAgICAgID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCAvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKS5pZClcbiAgICAgICAgICA6IHsgdHlwZTogJ3JlbW92ZWQnIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICBhdHRycy55Y2hhbmdlID0gY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICA/IGNvbXB1dGVZQ2hhbmdlKCdhZGRlZCcsIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLmlkKVxuICAgICAgICAgIDogeyB0eXBlOiAnYWRkZWQnIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHNjaGVtYS5ub2RlKGVsLm5vZGVOYW1lLCBhdHRycywgY2hpbGRyZW4pXG4gICAgbWFwcGluZy5zZXQoZWwsIG5vZGUpXG4gICAgcmV0dXJuIG5vZGVcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGFuIGVycm9yIG9jY3VyZWQgd2hpbGUgY3JlYXRpbmcgdGhlIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSByZXN1bHQgb2YgYSBjb25jdXJyZW50IGFjdGlvbi5cbiAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAoZWwuZG9jKS50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICBtYXBwaW5nLmRlbGV0ZShlbClcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge2FueX0gc2NoZW1hXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gX21hcHBpbmdcbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBZLklEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAqIEByZXR1cm4ge0FycmF5PFBNb2RlbC5Ob2RlPnxudWxsfVxuICovXG5jb25zdCBjcmVhdGVUZXh0Tm9kZXNGcm9tWVRleHQgPSAoXG4gIHRleHQsXG4gIHNjaGVtYSxcbiAgX21hcHBpbmcsXG4gIHNuYXBzaG90LFxuICBwcmV2U25hcHNob3QsXG4gIGNvbXB1dGVZQ2hhbmdlXG4pID0+IHtcbiAgY29uc3Qgbm9kZXMgPSBbXVxuICBjb25zdCBkZWx0YXMgPSB0ZXh0LnRvRGVsdGEoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpXG4gIHRyeSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZGVsdGFzW2ldXG4gICAgICBjb25zdCBtYXJrcyA9IFtdXG4gICAgICBmb3IgKGNvbnN0IG1hcmtOYW1lIGluIGRlbHRhLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbWFya3MucHVzaChzY2hlbWEubWFyayhtYXJrTmFtZSwgZGVsdGEuYXR0cmlidXRlc1ttYXJrTmFtZV0pKVxuICAgICAgfVxuICAgICAgbm9kZXMucHVzaChzY2hlbWEudGV4dChkZWx0YS5pbnNlcnQsIG1hcmtzKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKHRleHQuZG9jKS50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAodGV4dC5faXRlbSkuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gbm9kZXNcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBub2RlcyBwcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7WS5YbWxUZXh0fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbVRleHROb2RlcyA9IChub2RlcywgbWFwcGluZykgPT4ge1xuICBjb25zdCB0eXBlID0gbmV3IFkuWG1sVGV4dCgpXG4gIGNvbnN0IGRlbHRhID0gbm9kZXMubWFwKChub2RlKSA9PiAoe1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnNlcnQ6IG5vZGUudGV4dCxcbiAgICBhdHRyaWJ1dGVzOiBtYXJrc1RvQXR0cmlidXRlcyhub2RlLm1hcmtzKVxuICB9KSlcbiAgdHlwZS5hcHBseURlbHRhKGRlbHRhKVxuICBtYXBwaW5nLnNldCh0eXBlLCBub2RlcylcbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHthbnl9IG5vZGUgcHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge1kuWG1sRWxlbWVudH1cbiAqL1xuY29uc3QgY3JlYXRlVHlwZUZyb21FbGVtZW50Tm9kZSA9IChub2RlLCBtYXBwaW5nKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBuZXcgWS5YbWxFbGVtZW50KG5vZGUudHlwZS5uYW1lKVxuICBmb3IgKGNvbnN0IGtleSBpbiBub2RlLmF0dHJzKSB7XG4gICAgY29uc3QgdmFsID0gbm9kZS5hdHRyc1trZXldXG4gICAgaWYgKHZhbCAhPT0gbnVsbCAmJiBrZXkgIT09ICd5Y2hhbmdlJykge1xuICAgICAgdHlwZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpXG4gICAgfVxuICB9XG4gIHR5cGUuaW5zZXJ0KFxuICAgIDAsXG4gICAgbm9ybWFsaXplUE5vZGVDb250ZW50KG5vZGUpLm1hcCgobikgPT5cbiAgICAgIGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUobiwgbWFwcGluZylcbiAgICApXG4gIClcbiAgbWFwcGluZy5zZXQodHlwZSwgbm9kZSlcbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQTW9kZWwuTm9kZXxBcnJheTxQTW9kZWwuTm9kZT59IG5vZGUgcHJvc2VtaXJyb3IgdGV4dCBub2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7WS5YbWxFbGVtZW50fFkuWG1sVGV4dH1cbiAqL1xuY29uc3QgY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZSA9IChub2RlLCBtYXBwaW5nKSA9PlxuICBub2RlIGluc3RhbmNlb2YgQXJyYXlcbiAgICA/IGNyZWF0ZVR5cGVGcm9tVGV4dE5vZGVzKG5vZGUsIG1hcHBpbmcpXG4gICAgOiBjcmVhdGVUeXBlRnJvbUVsZW1lbnROb2RlKG5vZGUsIG1hcHBpbmcpXG5cbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsXG5cbmNvbnN0IGVxdWFsQXR0cnMgPSAocGF0dHJzLCB5YXR0cnMpID0+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhdHRycykuZmlsdGVyKChrZXkpID0+IHBhdHRyc1trZXldICE9PSBudWxsKVxuICBsZXQgZXEgPVxuICAgIGtleXMubGVuZ3RoID09PVxuICAgICAgT2JqZWN0LmtleXMoeWF0dHJzKS5maWx0ZXIoKGtleSkgPT4geWF0dHJzW2tleV0gIT09IG51bGwpLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoICYmIGVxOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgY29uc3QgbCA9IHBhdHRyc1trZXldXG4gICAgY29uc3QgciA9IHlhdHRyc1trZXldXG4gICAgZXEgPSBrZXkgPT09ICd5Y2hhbmdlJyB8fCBsID09PSByIHx8XG4gICAgICAoaXNPYmplY3QobCkgJiYgaXNPYmplY3QocikgJiYgZXF1YWxBdHRycyhsLCByKSlcbiAgfVxuICByZXR1cm4gZXFcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8QXJyYXk8UE1vZGVsLk5vZGU+fFBNb2RlbC5Ob2RlPn0gTm9ybWFsaXplZFBOb2RlQ29udGVudFxuICovXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHBub2RlXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkUE5vZGVDb250ZW50fVxuICovXG5jb25zdCBub3JtYWxpemVQTm9kZUNvbnRlbnQgPSAocG5vZGUpID0+IHtcbiAgY29uc3QgYyA9IHBub2RlLmNvbnRlbnQuY29udGVudFxuICBjb25zdCByZXMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuID0gY1tpXVxuICAgIGlmIChuLmlzVGV4dCkge1xuICAgICAgY29uc3QgdGV4dE5vZGVzID0gW11cbiAgICAgIGZvciAobGV0IHRub2RlID0gY1tpXTsgaSA8IGMubGVuZ3RoICYmIHRub2RlLmlzVGV4dDsgdG5vZGUgPSBjWysraV0pIHtcbiAgICAgICAgdGV4dE5vZGVzLnB1c2godG5vZGUpXG4gICAgICB9XG4gICAgICBpLS1cbiAgICAgIHJlcy5wdXNoKHRleHROb2RlcylcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnB1c2gobilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5YbWxUZXh0fSB5dGV4dFxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBwdGV4dHNcbiAqL1xuY29uc3QgZXF1YWxZVGV4dFBUZXh0ID0gKHl0ZXh0LCBwdGV4dHMpID0+IHtcbiAgY29uc3QgZGVsdGEgPSB5dGV4dC50b0RlbHRhKClcbiAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gcHRleHRzLmxlbmd0aCAmJlxuICAgIGRlbHRhLmV2ZXJ5KChkLCBpKSA9PlxuICAgICAgZC5pbnNlcnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAocHRleHRzW2ldKS50ZXh0ICYmXG4gICAgICBvYmplY3Qua2V5cyhkLmF0dHJpYnV0ZXMgfHwge30pLmxlbmd0aCA9PT0gcHRleHRzW2ldLm1hcmtzLmxlbmd0aCAmJlxuICAgICAgcHRleHRzW2ldLm1hcmtzLmV2ZXJ5KChtYXJrKSA9PlxuICAgICAgICBlcXVhbEF0dHJzKGQuYXR0cmlidXRlc1ttYXJrLnR5cGUubmFtZV0gfHwge30sIG1hcmsuYXR0cnMpXG4gICAgICApXG4gICAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fFkuWG1sVGV4dHxZLlhtbEhvb2t9IHl0eXBlXG4gKiBAcGFyYW0ge2FueXxBcnJheTxhbnk+fSBwbm9kZVxuICovXG5jb25zdCBlcXVhbFlUeXBlUE5vZGUgPSAoeXR5cGUsIHBub2RlKSA9PiB7XG4gIGlmIChcbiAgICB5dHlwZSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJiAhKHBub2RlIGluc3RhbmNlb2YgQXJyYXkpICYmXG4gICAgbWF0Y2hOb2RlTmFtZSh5dHlwZSwgcG5vZGUpXG4gICkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb250ZW50ID0gbm9ybWFsaXplUE5vZGVDb250ZW50KHBub2RlKVxuICAgIHJldHVybiB5dHlwZS5fbGVuZ3RoID09PSBub3JtYWxpemVkQ29udGVudC5sZW5ndGggJiZcbiAgICAgIGVxdWFsQXR0cnMoeXR5cGUuZ2V0QXR0cmlidXRlcygpLCBwbm9kZS5hdHRycykgJiZcbiAgICAgIHl0eXBlLnRvQXJyYXkoKS5ldmVyeSgoeWNoaWxkLCBpKSA9PlxuICAgICAgICBlcXVhbFlUeXBlUE5vZGUoeWNoaWxkLCBub3JtYWxpemVkQ29udGVudFtpXSlcbiAgICAgIClcbiAgfVxuICByZXR1cm4geXR5cGUgaW5zdGFuY2VvZiBZLlhtbFRleHQgJiYgcG5vZGUgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgIGVxdWFsWVRleHRQVGV4dCh5dHlwZSwgcG5vZGUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtQTW9kZWwuTm9kZSB8IEFycmF5PFBNb2RlbC5Ob2RlPiB8IHVuZGVmaW5lZH0gbWFwcGVkXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+fSBwY29udGVudFxuICovXG5jb25zdCBtYXBwZWRJZGVudGl0eSA9IChtYXBwZWQsIHBjb250ZW50KSA9PlxuICBtYXBwZWQgPT09IHBjb250ZW50IHx8XG4gIChtYXBwZWQgaW5zdGFuY2VvZiBBcnJheSAmJiBwY29udGVudCBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgbWFwcGVkLmxlbmd0aCA9PT0gcGNvbnRlbnQubGVuZ3RoICYmIG1hcHBlZC5ldmVyeSgoYSwgaSkgPT5cbiAgICBwY29udGVudFtpXSA9PT0gYVxuICApKVxuXG4vKipcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fSB5dHlwZVxuICogQHBhcmFtIHtQTW9kZWwuTm9kZX0gcG5vZGVcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHt7IGZvdW5kTWFwcGVkQ2hpbGQ6IGJvb2xlYW4sIGVxdWFsaXR5RmFjdG9yOiBudW1iZXIgfX1cbiAqL1xuY29uc3QgY29tcHV0ZUNoaWxkRXF1YWxpdHlGYWN0b3IgPSAoeXR5cGUsIHBub2RlLCBtYXBwaW5nKSA9PiB7XG4gIGNvbnN0IHlDaGlsZHJlbiA9IHl0eXBlLnRvQXJyYXkoKVxuICBjb25zdCBwQ2hpbGRyZW4gPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocG5vZGUpXG4gIGNvbnN0IHBDaGlsZENudCA9IHBDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgeUNoaWxkQ250ID0geUNoaWxkcmVuLmxlbmd0aFxuICBjb25zdCBtaW5DbnQgPSBtYXRoLm1pbih5Q2hpbGRDbnQsIHBDaGlsZENudClcbiAgbGV0IGxlZnQgPSAwXG4gIGxldCByaWdodCA9IDBcbiAgbGV0IGZvdW5kTWFwcGVkQ2hpbGQgPSBmYWxzZVxuICBmb3IgKDsgbGVmdCA8IG1pbkNudDsgbGVmdCsrKSB7XG4gICAgY29uc3QgbGVmdFkgPSB5Q2hpbGRyZW5bbGVmdF1cbiAgICBjb25zdCBsZWZ0UCA9IHBDaGlsZHJlbltsZWZ0XVxuICAgIGlmIChtYXBwZWRJZGVudGl0eShtYXBwaW5nLmdldChsZWZ0WSksIGxlZnRQKSkge1xuICAgICAgZm91bmRNYXBwZWRDaGlsZCA9IHRydWUgLy8gZGVmaW5pdGUgKGdvb2QpIG1hdGNoIVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShsZWZ0WSwgbGVmdFApKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbGVmdCArIHJpZ2h0IDwgbWluQ250OyByaWdodCsrKSB7XG4gICAgY29uc3QgcmlnaHRZID0geUNoaWxkcmVuW3lDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBjb25zdCByaWdodFAgPSBwQ2hpbGRyZW5bcENoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgIGlmIChtYXBwZWRJZGVudGl0eShtYXBwaW5nLmdldChyaWdodFkpLCByaWdodFApKSB7XG4gICAgICBmb3VuZE1hcHBlZENoaWxkID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXF1YWxpdHlGYWN0b3I6IGxlZnQgKyByaWdodCxcbiAgICBmb3VuZE1hcHBlZENoaWxkXG4gIH1cbn1cblxuY29uc3QgeXRleHRUcmFucyA9ICh5dGV4dCkgPT4ge1xuICBsZXQgc3RyID0gJydcbiAgLyoqXG4gICAqIEB0eXBlIHtZLkl0ZW18bnVsbH1cbiAgICovXG4gIGxldCBuID0geXRleHQuX3N0YXJ0XG4gIGNvbnN0IG5BdHRycyA9IHt9XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgIGlmIChuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQgaW5zdGFuY2VvZiBZLkNvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IG4uY29udGVudC5zdHJcbiAgICAgIH0gZWxzZSBpZiAobi5jb250ZW50IGluc3RhbmNlb2YgWS5Db250ZW50Rm9ybWF0KSB7XG4gICAgICAgIG5BdHRyc1tuLmNvbnRlbnQua2V5XSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cixcbiAgICBuQXR0cnNcbiAgfVxufVxuXG4vKipcbiAqIEB0b2RvIHRlc3QgdGhpcyBtb3JlXG4gKlxuICogQHBhcmFtIHtZLlRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqL1xuY29uc3QgdXBkYXRlWVRleHQgPSAoeXRleHQsIHB0ZXh0cywgbWFwcGluZykgPT4ge1xuICBtYXBwaW5nLnNldCh5dGV4dCwgcHRleHRzKVxuICBjb25zdCB7IG5BdHRycywgc3RyIH0gPSB5dGV4dFRyYW5zKHl0ZXh0KVxuICBjb25zdCBjb250ZW50ID0gcHRleHRzLm1hcCgocCkgPT4gKHtcbiAgICBpbnNlcnQ6IC8qKiBAdHlwZSB7YW55fSAqLyAocCkudGV4dCxcbiAgICBhdHRyaWJ1dGVzOiBPYmplY3QuYXNzaWduKHt9LCBuQXR0cnMsIG1hcmtzVG9BdHRyaWJ1dGVzKHAubWFya3MpKVxuICB9KSlcbiAgY29uc3QgeyBpbnNlcnQsIHJlbW92ZSwgaW5kZXggfSA9IHNpbXBsZURpZmYoXG4gICAgc3RyLFxuICAgIGNvbnRlbnQubWFwKChjKSA9PiBjLmluc2VydCkuam9pbignJylcbiAgKVxuICB5dGV4dC5kZWxldGUoaW5kZXgsIHJlbW92ZSlcbiAgeXRleHQuaW5zZXJ0KGluZGV4LCBpbnNlcnQpXG4gIHl0ZXh0LmFwcGx5RGVsdGEoXG4gICAgY29udGVudC5tYXAoKGMpID0+ICh7IHJldGFpbjogYy5pbnNlcnQubGVuZ3RoLCBhdHRyaWJ1dGVzOiBjLmF0dHJpYnV0ZXMgfSkpXG4gIClcbn1cblxuY29uc3QgbWFya3NUb0F0dHJpYnV0ZXMgPSAobWFya3MpID0+IHtcbiAgY29uc3QgcGF0dHJzID0ge31cbiAgbWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgIGlmIChtYXJrLnR5cGUubmFtZSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICBwYXR0cnNbbWFyay50eXBlLm5hbWVdID0gbWFyay5hdHRyc1xuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHBhdHRyc1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3t0cmFuc2FjdDogRnVuY3Rpb259fSB5XG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlEb21GcmFnbWVudFxuICogQHBhcmFtIHthbnl9IHBOb2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlWUZyYWdtZW50ID0gKHksIHlEb21GcmFnbWVudCwgcE5vZGUsIG1hcHBpbmcpID0+IHtcbiAgaWYgKFxuICAgIHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJlxuICAgIHlEb21GcmFnbWVudC5ub2RlTmFtZSAhPT0gcE5vZGUudHlwZS5uYW1lXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm9kZSBuYW1lIG1pc21hdGNoIScpXG4gIH1cbiAgbWFwcGluZy5zZXQoeURvbUZyYWdtZW50LCBwTm9kZSlcbiAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcbiAgaWYgKHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgIGNvbnN0IHlEb21BdHRycyA9IHlEb21GcmFnbWVudC5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBwQXR0cnMgPSBwTm9kZS5hdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBBdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh5RG9tQXR0cnNba2V5XSAhPT0gcEF0dHJzW2tleV0gJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuc2V0QXR0cmlidXRlKGtleSwgcEF0dHJzW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlEb21GcmFnbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHBBdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHlEb21BdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeURvbUZyYWdtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZSBjaGlsZHJlblxuICBjb25zdCBwQ2hpbGRyZW4gPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocE5vZGUpXG4gIGNvbnN0IHBDaGlsZENudCA9IHBDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgeUNoaWxkcmVuID0geURvbUZyYWdtZW50LnRvQXJyYXkoKVxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHBDaGlsZENudCwgeUNoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICAvLyBmaW5kIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBmcm9tIGxlZnRcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1hcHBpbmcuZ2V0KGxlZnRZKSwgbGVmdFApKSB7XG4gICAgICBpZiAoZXF1YWxZVHlwZVBOb2RlKGxlZnRZLCBsZWZ0UCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hcHBpbmdcbiAgICAgICAgbWFwcGluZy5zZXQobGVmdFksIGxlZnRQKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZmluZCBudW1iZXIgb2YgbWF0Y2hpbmcgZWxlbWVudHMgZnJvbSByaWdodFxuICBmb3IgKDsgcmlnaHQgKyBsZWZ0ICsgMSA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1hcHBpbmcuZ2V0KHJpZ2h0WSksIHJpZ2h0UCkpIHtcbiAgICAgIGlmIChlcXVhbFlUeXBlUE5vZGUocmlnaHRZLCByaWdodFApKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBtYXBwaW5nXG4gICAgICAgIG1hcHBpbmcuc2V0KHJpZ2h0WSwgcmlnaHRQKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeS50cmFuc2FjdCgoKSA9PiB7XG4gICAgLy8gdHJ5IHRvIGNvbXBhcmUgYW5kIHVwZGF0ZVxuICAgIHdoaWxlICh5Q2hpbGRDbnQgLSBsZWZ0IC0gcmlnaHQgPiAwICYmIHBDaGlsZENudCAtIGxlZnQgLSByaWdodCA+IDApIHtcbiAgICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgICBjb25zdCBsZWZ0UCA9IHBDaGlsZHJlbltsZWZ0XVxuICAgICAgY29uc3QgcmlnaHRZID0geUNoaWxkcmVuW3lDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICAgIGNvbnN0IHJpZ2h0UCA9IHBDaGlsZHJlbltwQ2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgICBpZiAobGVmdFkgaW5zdGFuY2VvZiBZLlhtbFRleHQgJiYgbGVmdFAgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoIWVxdWFsWVRleHRQVGV4dChsZWZ0WSwgbGVmdFApKSB7XG4gICAgICAgICAgdXBkYXRlWVRleHQobGVmdFksIGxlZnRQLCBtYXBwaW5nKVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHVwZGF0ZUxlZnQgPSBsZWZ0WSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJlxuICAgICAgICAgIG1hdGNoTm9kZU5hbWUobGVmdFksIGxlZnRQKVxuICAgICAgICBsZXQgdXBkYXRlUmlnaHQgPSByaWdodFkgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICAgICAgICBtYXRjaE5vZGVOYW1lKHJpZ2h0WSwgcmlnaHRQKVxuICAgICAgICBpZiAodXBkYXRlTGVmdCAmJiB1cGRhdGVSaWdodCkge1xuICAgICAgICAgIC8vIGRlY2lkZSB3aGljaCB3aGljaCBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAgICAgIGNvbnN0IGVxdWFsaXR5TGVmdCA9IGNvbXB1dGVDaGlsZEVxdWFsaXR5RmFjdG9yKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovIChsZWZ0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAobGVmdFApLFxuICAgICAgICAgICAgbWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBlcXVhbGl0eVJpZ2h0ID0gY29tcHV0ZUNoaWxkRXF1YWxpdHlGYWN0b3IoXG4gICAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHJpZ2h0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAocmlnaHRQKSxcbiAgICAgICAgICAgIG1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXF1YWxpdHlMZWZ0LmZvdW5kTWFwcGVkQ2hpbGQgJiYgIWVxdWFsaXR5UmlnaHQuZm91bmRNYXBwZWRDaGlsZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXBkYXRlUmlnaHQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAhZXF1YWxpdHlMZWZ0LmZvdW5kTWFwcGVkQ2hpbGQgJiYgZXF1YWxpdHlSaWdodC5mb3VuZE1hcHBlZENoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB1cGRhdGVMZWZ0ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgZXF1YWxpdHlMZWZ0LmVxdWFsaXR5RmFjdG9yIDwgZXF1YWxpdHlSaWdodC5lcXVhbGl0eUZhY3RvclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXBkYXRlTGVmdCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVJpZ2h0ID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZUxlZnQpIHtcbiAgICAgICAgICB1cGRhdGVZRnJhZ21lbnQoXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAobGVmdFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKGxlZnRQKSxcbiAgICAgICAgICAgIG1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlUmlnaHQpIHtcbiAgICAgICAgICB1cGRhdGVZRnJhZ21lbnQoXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAocmlnaHRZKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChyaWdodFApLFxuICAgICAgICAgICAgbWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICByaWdodCArPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZy5kZWxldGUoeURvbUZyYWdtZW50LmdldChsZWZ0KSlcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuZGVsZXRlKGxlZnQsIDEpXG4gICAgICAgICAgeURvbUZyYWdtZW50Lmluc2VydChsZWZ0LCBbXG4gICAgICAgICAgICBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKGxlZnRQLCBtYXBwaW5nKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeURlbExlbiA9IHlDaGlsZENudCAtIGxlZnQgLSByaWdodFxuICAgIGlmIChcbiAgICAgIHlDaGlsZENudCA9PT0gMSAmJiBwQ2hpbGRDbnQgPT09IDAgJiYgeUNoaWxkcmVuWzBdIGluc3RhbmNlb2YgWS5YbWxUZXh0XG4gICAgKSB7XG4gICAgICBtYXBwaW5nLmRlbGV0ZSh5Q2hpbGRyZW5bMF0pXG4gICAgICAvLyBFZGdlIGNhc2UgaGFuZGxpbmcgaHR0cHM6Ly9naXRodWIuY29tL3lqcy95LXByb3NlbWlycm9yL2lzc3Vlcy8xMDhcbiAgICAgIC8vIE9ubHkgZGVsZXRlIHRoZSBjb250ZW50IG9mIHRoZSBZLlRleHQgdG8gcmV0YWluIHJlbW90ZSBjaGFuZ2VzIG9uIHRoZSBzYW1lIFkuVGV4dCBvYmplY3RcbiAgICAgIHlDaGlsZHJlblswXS5kZWxldGUoMCwgeUNoaWxkcmVuWzBdLmxlbmd0aClcbiAgICB9IGVsc2UgaWYgKHlEZWxMZW4gPiAwKSB7XG4gICAgICB5RG9tRnJhZ21lbnQuc2xpY2UobGVmdCwgbGVmdCArIHlEZWxMZW4pLmZvckVhY2godHlwZSA9PiBtYXBwaW5nLmRlbGV0ZSh0eXBlKSlcbiAgICAgIHlEb21GcmFnbWVudC5kZWxldGUobGVmdCwgeURlbExlbilcbiAgICB9XG4gICAgaWYgKGxlZnQgKyByaWdodCA8IHBDaGlsZENudCkge1xuICAgICAgY29uc3QgaW5zID0gW11cbiAgICAgIGZvciAobGV0IGkgPSBsZWZ0OyBpIDwgcENoaWxkQ250IC0gcmlnaHQ7IGkrKykge1xuICAgICAgICBpbnMucHVzaChjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKHBDaGlsZHJlbltpXSwgbWFwcGluZykpXG4gICAgICB9XG4gICAgICB5RG9tRnJhZ21lbnQuaW5zZXJ0KGxlZnQsIGlucylcbiAgICB9XG4gIH0sIHlTeW5jUGx1Z2luS2V5KVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR9IHlFbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gcE5vZGUgUHJvc2VtaXJyb3IgTm9kZVxuICovXG5jb25zdCBtYXRjaE5vZGVOYW1lID0gKHlFbGVtZW50LCBwTm9kZSkgPT5cbiAgIShwTm9kZSBpbnN0YW5jZW9mIEFycmF5KSAmJiB5RWxlbWVudC5ub2RlTmFtZSA9PT0gcE5vZGUudHlwZS5uYW1lXG4iXSwibmFtZXMiOlsiY3JlYXRlTXV0ZXgiLCJQTW9kZWwiLCJQbHVnaW4iLCJUZXh0U2VsZWN0aW9uIiwibWF0aCIsIm9iamVjdCIsInNldCIsInNpbXBsZURpZmYiLCJlcnJvciIsInlTeW5jUGx1Z2luS2V5IiwieVVuZG9QbHVnaW5LZXkiLCJZIiwiYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiIsInJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24iLCJyYW5kb20iLCJlbnZpcm9ubWVudCIsImRvbSIsImV2ZW50bG9vcCIsImlzVmlzaWJsZSIsIml0ZW0iLCJzbmFwc2hvdCIsInVuZGVmaW5lZCIsImRlbGV0ZWQiLCJzdiIsImhhcyIsImlkIiwiY2xpZW50IiwiZ2V0IiwiY2xvY2siLCJpc0RlbGV0ZWQiLCJkcyIsImRlZmF1bHRDb2xvcnMiLCJsaWdodCIsImRhcmsiLCJnZXRVc2VyQ29sb3IiLCJjb2xvck1hcHBpbmciLCJjb2xvcnMiLCJ1c2VyIiwic2l6ZSIsImxlbmd0aCIsInVzZWRDb2xvcnMiLCJjcmVhdGUiLCJmb3JFYWNoIiwiY29sb3IiLCJhZGQiLCJmaWx0ZXIiLCJvbmVPZiIsInlTeW5jUGx1Z2luIiwieVhtbEZyYWdtZW50IiwiTWFwIiwicGVybWFuZW50VXNlckRhdGEiLCJvbkZpcnN0UmVuZGVyIiwiY2hhbmdlZEluaXRpYWxDb250ZW50IiwicmVyZW5kZXJUaW1lb3V0IiwicGx1Z2luIiwicHJvcHMiLCJlZGl0YWJsZSIsInN0YXRlIiwic3luY1N0YXRlIiwiZ2V0U3RhdGUiLCJwcmV2U25hcHNob3QiLCJrZXkiLCJpbml0IiwiX2luaXRhcmdzIiwiX3N0YXRlIiwidHlwZSIsImRvYyIsImJpbmRpbmciLCJpc0NoYW5nZU9yaWdpbiIsImlzVW5kb1JlZG9PcGVyYXRpb24iLCJhZGRUb0hpc3RvcnkiLCJhcHBseSIsInRyIiwicGx1Z2luU3RhdGUiLCJjaGFuZ2UiLCJnZXRNZXRhIiwiT2JqZWN0IiwiYXNzaWduIiwidGltZW91dCIsImlzRGVzdHJveWVkIiwicmVzdG9yZSIsIl9yZW5kZXJTbmFwc2hvdCIsIm11eCIsIl9wcm9zZW1pcnJvckNoYW5nZWQiLCJwcm9zZW1pcnJvclZpZXciLCJ2aWV3IiwiUHJvc2VtaXJyb3JCaW5kaW5nIiwiZGVzdHJveSIsIl9mb3JjZVJlcmVuZGVyIiwiZGlzcGF0Y2giLCJzZXRNZXRhIiwidXBkYXRlIiwiY29udGVudCIsImZpbmREaWZmU3RhcnQiLCJjcmVhdGVBbmRGaWxsIiwieVVuZG9QbHVnaW5TdGF0ZSIsInVtIiwidW5kb01hbmFnZXIiLCJzdG9wQ2FwdHVyaW5nIiwidHJhbnNhY3QiLCJtZXRhIiwicmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uIiwicmVsU2VsIiwiYW5jaG9yIiwiaGVhZCIsIm1hcHBpbmciLCJzZXRTZWxlY3Rpb24iLCJnZXRSZWxhdGl2ZVNlbGVjdGlvbiIsInBtYmluZGluZyIsInNlbGVjdGlvbiIsImNvbnN0cnVjdG9yIiwiX29ic2VydmVGdW5jdGlvbiIsIl90eXBlQ2hhbmdlZCIsImJpbmQiLCJiZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiIsImJlZm9yZUFsbFRyYW5zYWN0aW9ucyIsImFmdGVyQWxsVHJhbnNhY3Rpb25zIiwib24iLCJvYnNlcnZlRGVlcCIsIl9kb21TZWxlY3Rpb25JblZpZXciLCJfdHIiLCJfaXNMb2NhbEN1cnNvckluVmlldyIsImhhc0ZvY3VzIiwiaXNCcm93c2VyIiwiX2lzRG9tU2VsZWN0aW9uSW5WaWV3IiwiX3Jvb3QiLCJnZXRTZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0Iiwic2V0RW5kIiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJyZWN0cyIsImdldENsaWVudFJlY3RzIiwic3RhcnRDb250YWluZXIiLCJjb2xsYXBzZWQiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJib3VuZGluZyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRvY3VtZW50RWxlbWVudCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsInRvcCIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwicmVuZGVyU25hcHNob3QiLCJjcmVhdGVTbmFwc2hvdCIsImNyZWF0ZURlbGV0ZVNldCIsInVucmVuZGVyU25hcHNob3QiLCJmcmFnbWVudENvbnRlbnQiLCJ0b0FycmF5IiwibWFwIiwidCIsImNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQiLCJzY2hlbWEiLCJuIiwicmVwbGFjZSIsIlNsaWNlIiwiRnJhZ21lbnQiLCJmcm9tIiwidHJhbnNhY3Rpb24iLCJwdWQiLCJkc3MiLCJpdGVyYXRlRGVsZXRlZFN0cnVjdHMiLCJfaXRlbSIsImNvbXB1dGVZQ2hhbmdlIiwiZ2V0VXNlckJ5Q2xpZW50SWQiLCJnZXRVc2VyQnlEZWxldGVkSWQiLCJ0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCIsIlNuYXBzaG90IiwiZXZlbnRzIiwiZGVsVHlwZSIsIl8iLCJkZWxldGUiLCJkZWxldGVTZXQiLCJzdHJ1Y3QiLCJJdGVtIiwiY2hhbmdlZCIsImNoYW5nZWRQYXJlbnRUeXBlcyIsImNyZWF0ZU5vZGVJZk5vdEV4aXN0cyIsIm9yaWdpbiIsIlVuZG9NYW5hZ2VyIiwic2Nyb2xsSW50b1ZpZXciLCJ1cGRhdGVZRnJhZ21lbnQiLCJ1bm9ic2VydmVEZWVwIiwib2ZmIiwiZWwiLCJub2RlIiwiWG1sRWxlbWVudCIsIm1ldGhvZFVuaW1wbGVtZW50ZWQiLCJjaGlsZHJlbiIsImNyZWF0ZUNoaWxkcmVuIiwicHVzaCIsIm5zIiwiY3JlYXRlVGV4dE5vZGVzRnJvbVlUZXh0IiwidGV4dGNoaWxkIiwiYXR0cnMiLCJnZXRBdHRyaWJ1dGVzIiwieWNoYW5nZSIsIm5vZGVOYW1lIiwiZSIsInRleHQiLCJfbWFwcGluZyIsIm5vZGVzIiwiZGVsdGFzIiwidG9EZWx0YSIsImkiLCJkZWx0YSIsIm1hcmtzIiwibWFya05hbWUiLCJhdHRyaWJ1dGVzIiwibWFyayIsImluc2VydCIsImNyZWF0ZVR5cGVGcm9tVGV4dE5vZGVzIiwiWG1sVGV4dCIsIm1hcmtzVG9BdHRyaWJ1dGVzIiwiYXBwbHlEZWx0YSIsImNyZWF0ZVR5cGVGcm9tRWxlbWVudE5vZGUiLCJuYW1lIiwidmFsIiwic2V0QXR0cmlidXRlIiwibm9ybWFsaXplUE5vZGVDb250ZW50IiwiY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZSIsIkFycmF5IiwiaXNPYmplY3QiLCJlcXVhbEF0dHJzIiwicGF0dHJzIiwieWF0dHJzIiwia2V5cyIsImVxIiwibCIsInIiLCJwbm9kZSIsImMiLCJyZXMiLCJpc1RleHQiLCJ0ZXh0Tm9kZXMiLCJ0bm9kZSIsImVxdWFsWVRleHRQVGV4dCIsInl0ZXh0IiwicHRleHRzIiwiZXZlcnkiLCJkIiwiZXF1YWxZVHlwZVBOb2RlIiwieXR5cGUiLCJtYXRjaE5vZGVOYW1lIiwibm9ybWFsaXplZENvbnRlbnQiLCJfbGVuZ3RoIiwieWNoaWxkIiwibWFwcGVkSWRlbnRpdHkiLCJtYXBwZWQiLCJwY29udGVudCIsImEiLCJjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvciIsInlDaGlsZHJlbiIsInBDaGlsZHJlbiIsInBDaGlsZENudCIsInlDaGlsZENudCIsIm1pbkNudCIsIm1pbiIsImZvdW5kTWFwcGVkQ2hpbGQiLCJsZWZ0WSIsImxlZnRQIiwicmlnaHRZIiwicmlnaHRQIiwiZXF1YWxpdHlGYWN0b3IiLCJ5dGV4dFRyYW5zIiwic3RyIiwiX3N0YXJ0IiwibkF0dHJzIiwiY291bnRhYmxlIiwiQ29udGVudFN0cmluZyIsIkNvbnRlbnRGb3JtYXQiLCJ1cGRhdGVZVGV4dCIsInAiLCJyZW1vdmUiLCJpbmRleCIsImpvaW4iLCJyZXRhaW4iLCJ5IiwieURvbUZyYWdtZW50IiwicE5vZGUiLCJFcnJvciIsInlEb21BdHRycyIsInBBdHRycyIsInJlbW92ZUF0dHJpYnV0ZSIsInVwZGF0ZUxlZnQiLCJ1cGRhdGVSaWdodCIsImVxdWFsaXR5TGVmdCIsImVxdWFsaXR5UmlnaHQiLCJ5RGVsTGVuIiwic2xpY2UiLCJpbnMiLCJ5RWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/undo-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDeleteFilter: () => (/* binding */ defaultDeleteFilter),\n/* harmony export */   defaultProtectedNodes: () => (/* binding */ defaultProtectedNodes),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   yUndoPlugin: () => (/* binding */ yUndoPlugin)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var _sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n // eslint-disable-line\n\n\n\nconst undo = (state)=>{\n    const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager;\n    if (undoManager != null) {\n        undoManager.undo();\n        return true;\n    }\n};\nconst redo = (state)=>{\n    const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager;\n    if (undoManager != null) {\n        undoManager.redo();\n        return true;\n    }\n};\nconst defaultProtectedNodes = new Set([\n    \"paragraph\"\n]);\nconst defaultDeleteFilter = (item, protectedNodes)=>!(item instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Item) || !(item.content instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.ContentType) || !(item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Text || item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;\nconst yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {})=>new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey,\n        state: {\n            init: (initargs, state)=>{\n                // TODO: check if plugin order matches and fix\n                const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state);\n                const _undoManager = undoManager || new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(ystate.type, {\n                    trackedOrigins: new Set([\n                        _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey\n                    ].concat(trackedOrigins)),\n                    deleteFilter: (item)=>defaultDeleteFilter(item, protectedNodes),\n                    captureTransaction: (tr)=>tr.meta.get(\"addToHistory\") !== false\n                });\n                return {\n                    undoManager: _undoManager,\n                    prevSel: null,\n                    hasUndoOps: _undoManager.undoStack.length > 0,\n                    hasRedoOps: _undoManager.redoStack.length > 0\n                };\n            },\n            /**\n     * @returns {any}\n     */ apply: (tr, val, oldState, state)=>{\n                const binding = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state).binding;\n                const undoManager = val.undoManager;\n                const hasUndoOps = undoManager.undoStack.length > 0;\n                const hasRedoOps = undoManager.redoStack.length > 0;\n                if (binding) {\n                    return {\n                        undoManager,\n                        prevSel: (0,_sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(binding, oldState),\n                        hasUndoOps,\n                        hasRedoOps\n                    };\n                } else {\n                    if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n                        return Object.assign({}, val, {\n                            hasUndoOps: undoManager.undoStack.length > 0,\n                            hasRedoOps: undoManager.redoStack.length > 0\n                        });\n                    } else {\n                        return val;\n                    }\n                }\n            }\n        },\n        view: (view)=>{\n            const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state);\n            const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).undoManager;\n            undoManager.on(\"stack-item-added\", ({ stackItem })=>{\n                const binding = ystate.binding;\n                if (binding) {\n                    stackItem.meta.set(binding, _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).prevSel);\n                }\n            });\n            undoManager.on(\"stack-item-popped\", ({ stackItem })=>{\n                const binding = ystate.binding;\n                if (binding) {\n                    binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;\n                }\n            });\n            return {\n                destroy: ()=>{\n                    undoManager.destroy();\n                }\n            };\n        }\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy91bmRvLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDMEMsQ0FBQyxzQkFBc0I7QUFFVjtBQUNlO0FBQ1o7QUFFbkQsTUFBTVMsT0FBT0MsQ0FBQUE7SUFDbEIsTUFBTUMsY0FBY0osb0RBQWNBLENBQUNLLFFBQVEsQ0FBQ0YsT0FBT0MsV0FBVztJQUM5RCxJQUFJQSxlQUFlLE1BQU07UUFDdkJBLFlBQVlGLElBQUk7UUFDaEIsT0FBTztJQUNUO0FBQ0YsRUFBQztBQUVNLE1BQU1JLE9BQU9ILENBQUFBO0lBQ2xCLE1BQU1DLGNBQWNKLG9EQUFjQSxDQUFDSyxRQUFRLENBQUNGLE9BQU9DLFdBQVc7SUFDOUQsSUFBSUEsZUFBZSxNQUFNO1FBQ3ZCQSxZQUFZRSxJQUFJO1FBQ2hCLE9BQU87SUFDVDtBQUNGLEVBQUM7QUFFTSxNQUFNQyx3QkFBd0IsSUFBSUMsSUFBSTtJQUFDO0NBQVksRUFBQztBQUVwRCxNQUFNQyxzQkFBc0IsQ0FBQ0MsTUFBTUMsaUJBQW1CLENBQUVELENBQUFBLGdCQUFnQmQscUNBQUcsS0FDbEYsQ0FBRWMsQ0FBQUEsS0FBS0UsT0FBTyxZQUFZZiw0Q0FBVSxLQUNwQyxDQUFFYSxDQUFBQSxLQUFLRSxPQUFPLENBQUNDLElBQUksWUFBWWQscUNBQUlBLElBQ2hDVyxLQUFLRSxPQUFPLENBQUNDLElBQUksWUFBWWYsMkNBQVVBLElBQUlhLGVBQWVHLEdBQUcsQ0FBQ0osS0FBS0UsT0FBTyxDQUFDQyxJQUFJLENBQUNFLFFBQVEsQ0FBQyxLQUM1RkwsS0FBS0UsT0FBTyxDQUFDQyxJQUFJLENBQUNHLE9BQU8sS0FBSyxFQUFDO0FBRXhCLE1BQU1DLGNBQWMsQ0FBQyxFQUFFTixpQkFBaUJKLHFCQUFxQixFQUFFVyxpQkFBaUIsRUFBRSxFQUFFZCxjQUFjLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFLLElBQUlYLHFEQUFNQSxDQUFDO1FBQ2xJMEIsS0FBS25CLG9EQUFjQTtRQUNuQkcsT0FBTztZQUNMaUIsTUFBTSxDQUFDQyxVQUFVbEI7Z0JBQ2YsOENBQThDO2dCQUM5QyxNQUFNbUIsU0FBU3JCLG9EQUFjQSxDQUFDSSxRQUFRLENBQUNGO2dCQUN2QyxNQUFNb0IsZUFBZW5CLGVBQWUsSUFBSVQsNENBQVdBLENBQUMyQixPQUFPVCxJQUFJLEVBQUU7b0JBQy9ESyxnQkFBZ0IsSUFBSVYsSUFBSTt3QkFBQ1Asb0RBQWNBO3FCQUFDLENBQUN1QixNQUFNLENBQUNOO29CQUNoRE8sY0FBYyxDQUFDZixPQUFTRCxvQkFBb0JDLE1BQU1DO29CQUNsRGUsb0JBQW9CQyxDQUFBQSxLQUFNQSxHQUFHQyxJQUFJLENBQUNDLEdBQUcsQ0FBQyxvQkFBb0I7Z0JBQzVEO2dCQUNBLE9BQU87b0JBQ0x6QixhQUFhbUI7b0JBQ2JPLFNBQVM7b0JBQ1RDLFlBQVlSLGFBQWFTLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHO29CQUM1Q0MsWUFBWVgsYUFBYVksU0FBUyxDQUFDRixNQUFNLEdBQUc7Z0JBQzlDO1lBQ0Y7WUFDQTs7S0FFQyxHQUNERyxPQUFPLENBQUNULElBQUlVLEtBQUtDLFVBQVVuQztnQkFDekIsTUFBTW9DLFVBQVV0QyxvREFBY0EsQ0FBQ0ksUUFBUSxDQUFDRixPQUFPb0MsT0FBTztnQkFDdEQsTUFBTW5DLGNBQWNpQyxJQUFJakMsV0FBVztnQkFDbkMsTUFBTTJCLGFBQWEzQixZQUFZNEIsU0FBUyxDQUFDQyxNQUFNLEdBQUc7Z0JBQ2xELE1BQU1DLGFBQWE5QixZQUFZK0IsU0FBUyxDQUFDRixNQUFNLEdBQUc7Z0JBQ2xELElBQUlNLFNBQVM7b0JBQ1gsT0FBTzt3QkFDTG5DO3dCQUNBMEIsU0FBU3BDLHFFQUFvQkEsQ0FBQzZDLFNBQVNEO3dCQUN2Q1A7d0JBQ0FHO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wsSUFBSUgsZUFBZU0sSUFBSU4sVUFBVSxJQUFJRyxlQUFlRyxJQUFJSCxVQUFVLEVBQUU7d0JBQ2xFLE9BQU9NLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdKLEtBQUs7NEJBQzVCTixZQUFZM0IsWUFBWTRCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHOzRCQUMzQ0MsWUFBWTlCLFlBQVkrQixTQUFTLENBQUNGLE1BQU0sR0FBRzt3QkFDN0M7b0JBQ0YsT0FBTzt3QkFDTCxPQUFPSTtvQkFDVDtnQkFDRjtZQUNGO1FBQ0Y7UUFDQUssTUFBTUEsQ0FBQUE7WUFDSixNQUFNcEIsU0FBU3JCLG9EQUFjQSxDQUFDSSxRQUFRLENBQUNxQyxLQUFLdkMsS0FBSztZQUNqRCxNQUFNQyxjQUFjSixvREFBY0EsQ0FBQ0ssUUFBUSxDQUFDcUMsS0FBS3ZDLEtBQUssRUFBRUMsV0FBVztZQUNuRUEsWUFBWXVDLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFQyxTQUFTLEVBQUU7Z0JBQy9DLE1BQU1MLFVBQVVqQixPQUFPaUIsT0FBTztnQkFDOUIsSUFBSUEsU0FBUztvQkFDWEssVUFBVWhCLElBQUksQ0FBQ2lCLEdBQUcsQ0FBQ04sU0FBU3ZDLG9EQUFjQSxDQUFDSyxRQUFRLENBQUNxQyxLQUFLdkMsS0FBSyxFQUFFMkIsT0FBTztnQkFDekU7WUFDRjtZQUNBMUIsWUFBWXVDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFQyxTQUFTLEVBQUU7Z0JBQ2hELE1BQU1MLFVBQVVqQixPQUFPaUIsT0FBTztnQkFDOUIsSUFBSUEsU0FBUztvQkFDWEEsUUFBUU8sMEJBQTBCLEdBQUdGLFVBQVVoQixJQUFJLENBQUNDLEdBQUcsQ0FBQ1UsWUFBWUEsUUFBUU8sMEJBQTBCO2dCQUN4RztZQUNGO1lBQ0EsT0FBTztnQkFDTEMsU0FBUztvQkFDUDNDLFlBQVkyQyxPQUFPO2dCQUNyQjtZQUNGO1FBQ0Y7SUFDRixHQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2Utam91cm5hbC8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL3VuZG8tcGx1Z2luLmpzP2FiMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5pbXBvcnQgeyBnZXRSZWxhdGl2ZVNlbGVjdGlvbiB9IGZyb20gJy4vc3luYy1wbHVnaW4uanMnXG5pbXBvcnQgeyBVbmRvTWFuYWdlciwgSXRlbSwgQ29udGVudFR5cGUsIFhtbEVsZW1lbnQsIFRleHQgfSBmcm9tICd5anMnXG5pbXBvcnQgeyB5VW5kb1BsdWdpbktleSwgeVN5bmNQbHVnaW5LZXkgfSBmcm9tICcuL2tleXMuanMnXG5cbmV4cG9ydCBjb25zdCB1bmRvID0gc3RhdGUgPT4ge1xuICBjb25zdCB1bmRvTWFuYWdlciA9IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKS51bmRvTWFuYWdlclxuICBpZiAodW5kb01hbmFnZXIgIT0gbnVsbCkge1xuICAgIHVuZG9NYW5hZ2VyLnVuZG8oKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlZG8gPSBzdGF0ZSA9PiB7XG4gIGNvbnN0IHVuZG9NYW5hZ2VyID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLnVuZG9NYW5hZ2VyXG4gIGlmICh1bmRvTWFuYWdlciAhPSBudWxsKSB7XG4gICAgdW5kb01hbmFnZXIucmVkbygpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdFByb3RlY3RlZE5vZGVzID0gbmV3IFNldChbJ3BhcmFncmFwaCddKVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdERlbGV0ZUZpbHRlciA9IChpdGVtLCBwcm90ZWN0ZWROb2RlcykgPT4gIShpdGVtIGluc3RhbmNlb2YgSXRlbSkgfHxcbiEoaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHx8XG4hKGl0ZW0uY29udGVudC50eXBlIGluc3RhbmNlb2YgVGV4dCB8fFxuICAoaXRlbS5jb250ZW50LnR5cGUgaW5zdGFuY2VvZiBYbWxFbGVtZW50ICYmIHByb3RlY3RlZE5vZGVzLmhhcyhpdGVtLmNvbnRlbnQudHlwZS5ub2RlTmFtZSkpKSB8fFxuaXRlbS5jb250ZW50LnR5cGUuX2xlbmd0aCA9PT0gMFxuXG5leHBvcnQgY29uc3QgeVVuZG9QbHVnaW4gPSAoeyBwcm90ZWN0ZWROb2RlcyA9IGRlZmF1bHRQcm90ZWN0ZWROb2RlcywgdHJhY2tlZE9yaWdpbnMgPSBbXSwgdW5kb01hbmFnZXIgPSBudWxsIH0gPSB7fSkgPT4gbmV3IFBsdWdpbih7XG4gIGtleTogeVVuZG9QbHVnaW5LZXksXG4gIHN0YXRlOiB7XG4gICAgaW5pdDogKGluaXRhcmdzLCBzdGF0ZSkgPT4ge1xuICAgICAgLy8gVE9ETzogY2hlY2sgaWYgcGx1Z2luIG9yZGVyIG1hdGNoZXMgYW5kIGZpeFxuICAgICAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpXG4gICAgICBjb25zdCBfdW5kb01hbmFnZXIgPSB1bmRvTWFuYWdlciB8fCBuZXcgVW5kb01hbmFnZXIoeXN0YXRlLnR5cGUsIHtcbiAgICAgICAgdHJhY2tlZE9yaWdpbnM6IG5ldyBTZXQoW3lTeW5jUGx1Z2luS2V5XS5jb25jYXQodHJhY2tlZE9yaWdpbnMpKSxcbiAgICAgICAgZGVsZXRlRmlsdGVyOiAoaXRlbSkgPT4gZGVmYXVsdERlbGV0ZUZpbHRlcihpdGVtLCBwcm90ZWN0ZWROb2RlcyksXG4gICAgICAgIGNhcHR1cmVUcmFuc2FjdGlvbjogdHIgPT4gdHIubWV0YS5nZXQoJ2FkZFRvSGlzdG9yeScpICE9PSBmYWxzZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyOiBfdW5kb01hbmFnZXIsXG4gICAgICAgIHByZXZTZWw6IG51bGwsXG4gICAgICAgIGhhc1VuZG9PcHM6IF91bmRvTWFuYWdlci51bmRvU3RhY2subGVuZ3RoID4gMCxcbiAgICAgICAgaGFzUmVkb09wczogX3VuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIGFwcGx5OiAodHIsIHZhbCwgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLmJpbmRpbmdcbiAgICAgIGNvbnN0IHVuZG9NYW5hZ2VyID0gdmFsLnVuZG9NYW5hZ2VyXG4gICAgICBjb25zdCBoYXNVbmRvT3BzID0gdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIGNvbnN0IGhhc1JlZG9PcHMgPSB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bmRvTWFuYWdlcixcbiAgICAgICAgICBwcmV2U2VsOiBnZXRSZWxhdGl2ZVNlbGVjdGlvbihiaW5kaW5nLCBvbGRTdGF0ZSksXG4gICAgICAgICAgaGFzVW5kb09wcyxcbiAgICAgICAgICBoYXNSZWRvT3BzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNVbmRvT3BzICE9PSB2YWwuaGFzVW5kb09wcyB8fCBoYXNSZWRvT3BzICE9PSB2YWwuaGFzUmVkb09wcykge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB2YWwsIHtcbiAgICAgICAgICAgIGhhc1VuZG9PcHM6IHVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICAgICAgaGFzUmVkb09wczogdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgeyAvLyBub3RoaW5nIGNoYW5nZWRcbiAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHZpZXc6IHZpZXcgPT4ge1xuICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKS51bmRvTWFuYWdlclxuICAgIHVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLWFkZGVkJywgKHsgc3RhY2tJdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB5c3RhdGUuYmluZGluZ1xuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgc3RhY2tJdGVtLm1ldGEuc2V0KGJpbmRpbmcsIHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpLnByZXZTZWwpXG4gICAgICB9XG4gICAgfSlcbiAgICB1bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1wb3BwZWQnLCAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgYmluZGluZyA9IHlzdGF0ZS5iaW5kaW5nXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gc3RhY2tJdGVtLm1ldGEuZ2V0KGJpbmRpbmcpIHx8IGJpbmRpbmcuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbiJdLCJuYW1lcyI6WyJQbHVnaW4iLCJnZXRSZWxhdGl2ZVNlbGVjdGlvbiIsIlVuZG9NYW5hZ2VyIiwiSXRlbSIsIkNvbnRlbnRUeXBlIiwiWG1sRWxlbWVudCIsIlRleHQiLCJ5VW5kb1BsdWdpbktleSIsInlTeW5jUGx1Z2luS2V5IiwidW5kbyIsInN0YXRlIiwidW5kb01hbmFnZXIiLCJnZXRTdGF0ZSIsInJlZG8iLCJkZWZhdWx0UHJvdGVjdGVkTm9kZXMiLCJTZXQiLCJkZWZhdWx0RGVsZXRlRmlsdGVyIiwiaXRlbSIsInByb3RlY3RlZE5vZGVzIiwiY29udGVudCIsInR5cGUiLCJoYXMiLCJub2RlTmFtZSIsIl9sZW5ndGgiLCJ5VW5kb1BsdWdpbiIsInRyYWNrZWRPcmlnaW5zIiwia2V5IiwiaW5pdCIsImluaXRhcmdzIiwieXN0YXRlIiwiX3VuZG9NYW5hZ2VyIiwiY29uY2F0IiwiZGVsZXRlRmlsdGVyIiwiY2FwdHVyZVRyYW5zYWN0aW9uIiwidHIiLCJtZXRhIiwiZ2V0IiwicHJldlNlbCIsImhhc1VuZG9PcHMiLCJ1bmRvU3RhY2siLCJsZW5ndGgiLCJoYXNSZWRvT3BzIiwicmVkb1N0YWNrIiwiYXBwbHkiLCJ2YWwiLCJvbGRTdGF0ZSIsImJpbmRpbmciLCJPYmplY3QiLCJhc3NpZ24iLCJ2aWV3Iiwib24iLCJzdGFja0l0ZW0iLCJzZXQiLCJiZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiIsImRlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\n");

/***/ })

};
;