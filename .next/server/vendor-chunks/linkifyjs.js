"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/linkifyjs";
exports.ids = ["vendor-chunks/linkifyjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/linkifyjs/dist/linkify.es.js":
/*!***************************************************!*\
  !*** ./node_modules/linkifyjs/dist/linkify.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiToken: () => (/* binding */ MultiToken),\n/* harmony export */   Options: () => (/* binding */ Options),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   createTokenClass: () => (/* binding */ createTokenClass),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   multi: () => (/* binding */ multi),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   registerCustomProtocol: () => (/* binding */ registerCustomProtocol),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   registerTokenPlugin: () => (/* binding */ registerTokenPlugin),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   stringToArray: () => (/* binding */ stringToArray),\n/* harmony export */   test: () => (/* binding */ test),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = \"aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\\xf6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2\";\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = \"ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2\";\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */ const assign = (target, properties)=>{\n    for(const key in properties){\n        target[key] = properties[key];\n    }\n    return target;\n};\n/**\n * Finite State Machine generation utilities\n */ /**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */ /**\n * @typedef {{ [group: string]: true }} Flags\n */ // Keys in scanner Collections instances\nconst numeric = \"numeric\";\nconst ascii = \"ascii\";\nconst alpha = \"alpha\";\nconst asciinumeric = \"asciinumeric\";\nconst alphanumeric = \"alphanumeric\";\nconst domain = \"domain\";\nconst emoji = \"emoji\";\nconst scheme = \"scheme\";\nconst slashscheme = \"slashscheme\";\nconst whitespace = \"whitespace\";\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */ function registerGroup(name, groups) {\n    if (!(name in groups)) {\n        groups[name] = [];\n    }\n    return groups[name];\n}\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */ function addToGroups(t, flags, groups) {\n    if (flags[numeric]) {\n        flags[asciinumeric] = true;\n        flags[alphanumeric] = true;\n    }\n    if (flags[ascii]) {\n        flags[asciinumeric] = true;\n        flags[alpha] = true;\n    }\n    if (flags[asciinumeric]) {\n        flags[alphanumeric] = true;\n    }\n    if (flags[alpha]) {\n        flags[alphanumeric] = true;\n    }\n    if (flags[alphanumeric]) {\n        flags[domain] = true;\n    }\n    if (flags[emoji]) {\n        flags[domain] = true;\n    }\n    for(const k in flags){\n        const group = registerGroup(k, groups);\n        if (group.indexOf(t) < 0) {\n            group.push(t);\n        }\n    }\n}\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */ function flagsForToken(t, groups) {\n    const result = {};\n    for(const c in groups){\n        if (groups[c].indexOf(t) >= 0) {\n            result[c] = true;\n        }\n    }\n    return result;\n}\n/**\n * @template T\n * @typedef {null | T } Transition\n */ /**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */ function State(token) {\n    if (token === void 0) {\n        token = null;\n    }\n    // this.n = null; // DEBUG: State name\n    /** @type {{ [input: string]: State<T> }} j */ this.j = {}; // IMPLEMENTATION 1\n    // this.j = []; // IMPLEMENTATION 2\n    /** @type {[RegExp, State<T>][]} jr */ this.jr = [];\n    /** @type {?State<T>} jd */ this.jd = null;\n    /** @type {?T} t */ this.t = token;\n}\n/**\n * Scanner token groups\n * @type Collections<string>\n */ State.groups = {};\nState.prototype = {\n    accepts () {\n        return !!this.t;\n    },\n    /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */ go (input) {\n        const state = this;\n        const nextState = state.j[input];\n        if (nextState) {\n            return nextState;\n        }\n        for(let i = 0; i < state.jr.length; i++){\n            const regex = state.jr[i][0];\n            const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n            if (nextState && regex.test(input)) {\n                return nextState;\n            }\n        }\n        // Nowhere left to jump! Return default, if any\n        return state.jd;\n    },\n    /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */ has (input, exactOnly) {\n        if (exactOnly === void 0) {\n            exactOnly = false;\n        }\n        return exactOnly ? input in this.j : !!this.go(input);\n    },\n    /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */ ta (inputs, next, flags, groups) {\n        for(let i = 0; i < inputs.length; i++){\n            this.tt(inputs[i], next, flags, groups);\n        }\n    },\n    /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */ tr (regexp, next, flags, groups) {\n        groups = groups || State.groups;\n        let nextState;\n        if (next && next.j) {\n            nextState = next;\n        } else {\n            // Token with maybe token groups\n            nextState = new State(next);\n            if (flags && groups) {\n                addToGroups(next, flags, groups);\n            }\n        }\n        this.jr.push([\n            regexp,\n            nextState\n        ]);\n        return nextState;\n    },\n    /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */ ts (input, next, flags, groups) {\n        let state = this;\n        const len = input.length;\n        if (!len) {\n            return state;\n        }\n        for(let i = 0; i < len - 1; i++){\n            state = state.tt(input[i]);\n        }\n        return state.tt(input[len - 1], next, flags, groups);\n    },\n    /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */ tt (input, next, flags, groups) {\n        groups = groups || State.groups;\n        const state = this;\n        // Check if existing state given, just a basic transition\n        if (next && next.j) {\n            state.j[input] = next;\n            return next;\n        }\n        const t = next;\n        // Take the transition with the usual default mechanisms and use that as\n        // a template for creating the next state\n        let nextState, templateState = state.go(input);\n        if (templateState) {\n            nextState = new State();\n            assign(nextState.j, templateState.j);\n            nextState.jr.push.apply(nextState.jr, templateState.jr);\n            nextState.jd = templateState.jd;\n            nextState.t = templateState.t;\n        } else {\n            nextState = new State();\n        }\n        if (t) {\n            // Ensure newly token is in the same groups as the old token\n            if (groups) {\n                if (nextState.t && typeof nextState.t === \"string\") {\n                    const allFlags = assign(flagsForToken(nextState.t, groups), flags);\n                    addToGroups(t, allFlags, groups);\n                } else if (flags) {\n                    addToGroups(t, flags, groups);\n                }\n            }\n            nextState.t = t; // overwrite anything that was previously there\n        }\n        state.j[input] = nextState;\n        return nextState;\n    }\n};\n// Helper functions to improve minification (not exported outside linkifyjs module)\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ const ta = (state, input, next, flags, groups)=>state.ta(input, next, flags, groups);\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ const tr = (state, regexp, next, flags, groups)=>state.tr(regexp, next, flags, groups);\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */ const ts = (state, input, next, flags, groups)=>state.ts(input, next, flags, groups);\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */ const tt = (state, input, next, flags, groups)=>state.tt(input, next, flags, groups);\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/ // A valid web domain token\nconst WORD = \"WORD\"; // only contains a-z\nconst UWORD = \"UWORD\"; // contains letters other than a-z, used for IDN\n// Special case of word\nconst LOCALHOST = \"LOCALHOST\";\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = \"TLD\";\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = \"UTLD\";\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = \"SCHEME\";\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = \"SLASH_SCHEME\";\n// Any sequence of digits 0-9\nconst NUM = \"NUM\";\n// Any number of consecutive whitespace characters that are not newline\nconst WS = \"WS\";\n// New line (unix style)\nconst NL$1 = \"NL\"; // \\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = \"OPENBRACE\"; // {\nconst CLOSEBRACE = \"CLOSEBRACE\"; // }\nconst OPENBRACKET = \"OPENBRACKET\"; // [\nconst CLOSEBRACKET = \"CLOSEBRACKET\"; // ]\nconst OPENPAREN = \"OPENPAREN\"; // (\nconst CLOSEPAREN = \"CLOSEPAREN\"; // )\nconst OPENANGLEBRACKET = \"OPENANGLEBRACKET\"; // <\nconst CLOSEANGLEBRACKET = \"CLOSEANGLEBRACKET\"; // >\nconst FULLWIDTHLEFTPAREN = \"FULLWIDTHLEFTPAREN\"; // （\nconst FULLWIDTHRIGHTPAREN = \"FULLWIDTHRIGHTPAREN\"; // ）\nconst LEFTCORNERBRACKET = \"LEFTCORNERBRACKET\"; // 「\nconst RIGHTCORNERBRACKET = \"RIGHTCORNERBRACKET\"; // 」\nconst LEFTWHITECORNERBRACKET = \"LEFTWHITECORNERBRACKET\"; // 『\nconst RIGHTWHITECORNERBRACKET = \"RIGHTWHITECORNERBRACKET\"; // 』\nconst FULLWIDTHLESSTHAN = \"FULLWIDTHLESSTHAN\"; // ＜\nconst FULLWIDTHGREATERTHAN = \"FULLWIDTHGREATERTHAN\"; // ＞\n// Various symbols\nconst AMPERSAND = \"AMPERSAND\"; // &\nconst APOSTROPHE = \"APOSTROPHE\"; // '\nconst ASTERISK = \"ASTERISK\"; // *\nconst AT = \"AT\"; // @\nconst BACKSLASH = \"BACKSLASH\"; // \\\nconst BACKTICK = \"BACKTICK\"; // `\nconst CARET = \"CARET\"; // ^\nconst COLON = \"COLON\"; // :\nconst COMMA = \"COMMA\"; // ,\nconst DOLLAR = \"DOLLAR\"; // $\nconst DOT = \"DOT\"; // .\nconst EQUALS = \"EQUALS\"; // =\nconst EXCLAMATION = \"EXCLAMATION\"; // !\nconst HYPHEN = \"HYPHEN\"; // -\nconst PERCENT = \"PERCENT\"; // %\nconst PIPE = \"PIPE\"; // |\nconst PLUS = \"PLUS\"; // +\nconst POUND = \"POUND\"; // #\nconst QUERY = \"QUERY\"; // ?\nconst QUOTE = \"QUOTE\"; // \"\nconst SEMI = \"SEMI\"; // ;\nconst SLASH = \"SLASH\"; // /\nconst TILDE = \"TILDE\"; // ~\nconst UNDERSCORE = \"UNDERSCORE\"; // _\n// Emoji symbol\nconst EMOJI$1 = \"EMOJI\";\n// Default token - anything that is not one of the above\nconst SYM = \"SYM\";\nvar tk = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    WORD: WORD,\n    UWORD: UWORD,\n    LOCALHOST: LOCALHOST,\n    TLD: TLD,\n    UTLD: UTLD,\n    SCHEME: SCHEME,\n    SLASH_SCHEME: SLASH_SCHEME,\n    NUM: NUM,\n    WS: WS,\n    NL: NL$1,\n    OPENBRACE: OPENBRACE,\n    CLOSEBRACE: CLOSEBRACE,\n    OPENBRACKET: OPENBRACKET,\n    CLOSEBRACKET: CLOSEBRACKET,\n    OPENPAREN: OPENPAREN,\n    CLOSEPAREN: CLOSEPAREN,\n    OPENANGLEBRACKET: OPENANGLEBRACKET,\n    CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n    FULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n    FULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n    LEFTCORNERBRACKET: LEFTCORNERBRACKET,\n    RIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n    LEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n    RIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n    FULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n    FULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n    AMPERSAND: AMPERSAND,\n    APOSTROPHE: APOSTROPHE,\n    ASTERISK: ASTERISK,\n    AT: AT,\n    BACKSLASH: BACKSLASH,\n    BACKTICK: BACKTICK,\n    CARET: CARET,\n    COLON: COLON,\n    COMMA: COMMA,\n    DOLLAR: DOLLAR,\n    DOT: DOT,\n    EQUALS: EQUALS,\n    EXCLAMATION: EXCLAMATION,\n    HYPHEN: HYPHEN,\n    PERCENT: PERCENT,\n    PIPE: PIPE,\n    PLUS: PLUS,\n    POUND: POUND,\n    QUERY: QUERY,\n    QUOTE: QUOTE,\n    SEMI: SEMI,\n    SLASH: SLASH,\n    TILDE: TILDE,\n    UNDERSCORE: UNDERSCORE,\n    EMOJI: EMOJI$1,\n    SYM: SYM\n});\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\nvar regexp = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ASCII_LETTER: ASCII_LETTER,\n    LETTER: LETTER,\n    EMOJI: EMOJI,\n    EMOJI_VARIATION: EMOJI_VARIATION$1,\n    DIGIT: DIGIT,\n    SPACE: SPACE\n});\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/ const NL = \"\\n\"; // New line character\nconst EMOJI_VARIATION = \"️\"; // Variation selector, follows heart and others\nconst EMOJI_JOINER = \"‍\"; // zero-width joiner\nlet tlds = null, utlds = null; // don't change so only have to be computed once\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */ /**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */ /**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */ function init$2(customSchemes) {\n    if (customSchemes === void 0) {\n        customSchemes = [];\n    }\n    // Frequently used states (name argument removed during minification)\n    /** @type Collections<string> */ const groups = {}; // of tokens\n    State.groups = groups;\n    /** @type State<string> */ const Start = new State();\n    if (tlds == null) {\n        tlds = decodeTlds(encodedTlds);\n    }\n    if (utlds == null) {\n        utlds = decodeTlds(encodedUtlds);\n    }\n    // States for special URL symbols that accept immediately after start\n    tt(Start, \"'\", APOSTROPHE);\n    tt(Start, \"{\", OPENBRACE);\n    tt(Start, \"}\", CLOSEBRACE);\n    tt(Start, \"[\", OPENBRACKET);\n    tt(Start, \"]\", CLOSEBRACKET);\n    tt(Start, \"(\", OPENPAREN);\n    tt(Start, \")\", CLOSEPAREN);\n    tt(Start, \"<\", OPENANGLEBRACKET);\n    tt(Start, \">\", CLOSEANGLEBRACKET);\n    tt(Start, \"（\", FULLWIDTHLEFTPAREN);\n    tt(Start, \"）\", FULLWIDTHRIGHTPAREN);\n    tt(Start, \"「\", LEFTCORNERBRACKET);\n    tt(Start, \"」\", RIGHTCORNERBRACKET);\n    tt(Start, \"『\", LEFTWHITECORNERBRACKET);\n    tt(Start, \"』\", RIGHTWHITECORNERBRACKET);\n    tt(Start, \"＜\", FULLWIDTHLESSTHAN);\n    tt(Start, \"＞\", FULLWIDTHGREATERTHAN);\n    tt(Start, \"&\", AMPERSAND);\n    tt(Start, \"*\", ASTERISK);\n    tt(Start, \"@\", AT);\n    tt(Start, \"`\", BACKTICK);\n    tt(Start, \"^\", CARET);\n    tt(Start, \":\", COLON);\n    tt(Start, \",\", COMMA);\n    tt(Start, \"$\", DOLLAR);\n    tt(Start, \".\", DOT);\n    tt(Start, \"=\", EQUALS);\n    tt(Start, \"!\", EXCLAMATION);\n    tt(Start, \"-\", HYPHEN);\n    tt(Start, \"%\", PERCENT);\n    tt(Start, \"|\", PIPE);\n    tt(Start, \"+\", PLUS);\n    tt(Start, \"#\", POUND);\n    tt(Start, \"?\", QUERY);\n    tt(Start, '\"', QUOTE);\n    tt(Start, \"/\", SLASH);\n    tt(Start, \";\", SEMI);\n    tt(Start, \"~\", TILDE);\n    tt(Start, \"_\", UNDERSCORE);\n    tt(Start, \"\\\\\", BACKSLASH);\n    const Num = tr(Start, DIGIT, NUM, {\n        [numeric]: true\n    });\n    tr(Num, DIGIT, Num);\n    // State which emits a word token\n    const Word = tr(Start, ASCII_LETTER, WORD, {\n        [ascii]: true\n    });\n    tr(Word, ASCII_LETTER, Word);\n    // Same as previous, but specific to non-fsm.ascii alphabet words\n    const UWord = tr(Start, LETTER, UWORD, {\n        [alpha]: true\n    });\n    tr(UWord, ASCII_LETTER); // Non-accepting\n    tr(UWord, LETTER, UWord);\n    // Whitespace jumps\n    // Tokens of only non-newline whitespace are arbitrarily long\n    // If any whitespace except newline, more whitespace!\n    const Ws = tr(Start, SPACE, WS, {\n        [whitespace]: true\n    });\n    tt(Start, NL, NL$1, {\n        [whitespace]: true\n    });\n    tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n    tr(Ws, SPACE, Ws);\n    // Emoji tokens. They are not grouped by the scanner except in cases where a\n    // zero-width joiner is present\n    const Emoji = tr(Start, EMOJI, EMOJI$1, {\n        [emoji]: true\n    });\n    tr(Emoji, EMOJI, Emoji);\n    tt(Emoji, EMOJI_VARIATION, Emoji);\n    // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n    const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n    tr(EmojiJoiner, EMOJI, Emoji);\n    // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n    // Generates states for top-level domains\n    // Note that this is most accurate when tlds are in alphabetical order\n    const wordjr = [\n        [\n            ASCII_LETTER,\n            Word\n        ]\n    ];\n    const uwordjr = [\n        [\n            ASCII_LETTER,\n            null\n        ],\n        [\n            LETTER,\n            UWord\n        ]\n    ];\n    for(let i = 0; i < tlds.length; i++){\n        fastts(Start, tlds[i], TLD, WORD, wordjr);\n    }\n    for(let i = 0; i < utlds.length; i++){\n        fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n    }\n    addToGroups(TLD, {\n        tld: true,\n        ascii: true\n    }, groups);\n    addToGroups(UTLD, {\n        utld: true,\n        alpha: true\n    }, groups);\n    // Collect the states generated by different protocols. NOTE: If any new TLDs\n    // get added that are also protocols, set the token to be the same as the\n    // protocol to ensure parsing works as expected.\n    fastts(Start, \"file\", SCHEME, WORD, wordjr);\n    fastts(Start, \"mailto\", SCHEME, WORD, wordjr);\n    fastts(Start, \"http\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"https\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"ftp\", SLASH_SCHEME, WORD, wordjr);\n    fastts(Start, \"ftps\", SLASH_SCHEME, WORD, wordjr);\n    addToGroups(SCHEME, {\n        scheme: true,\n        ascii: true\n    }, groups);\n    addToGroups(SLASH_SCHEME, {\n        slashscheme: true,\n        ascii: true\n    }, groups);\n    // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n    customSchemes = customSchemes.sort((a, b)=>a[0] > b[0] ? 1 : -1);\n    for(let i = 0; i < customSchemes.length; i++){\n        const sch = customSchemes[i][0];\n        const optionalSlashSlash = customSchemes[i][1];\n        const flags = optionalSlashSlash ? {\n            [scheme]: true\n        } : {\n            [slashscheme]: true\n        };\n        if (sch.indexOf(\"-\") >= 0) {\n            flags[domain] = true;\n        } else if (!ASCII_LETTER.test(sch)) {\n            flags[numeric] = true; // numbers only\n        } else if (DIGIT.test(sch)) {\n            flags[asciinumeric] = true;\n        } else {\n            flags[ascii] = true;\n        }\n        ts(Start, sch, sch, flags);\n    }\n    // Localhost token\n    ts(Start, \"localhost\", LOCALHOST, {\n        ascii: true\n    });\n    // Set default transition for start state (some symbol)\n    Start.jd = new State(SYM);\n    return {\n        start: Start,\n        tokens: assign({\n            groups\n        }, tk)\n    };\n}\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/ function run$1(start, str) {\n    // State machine is not case sensitive, so input is tokenized in lowercased\n    // form (still returns regular case). Uses selective `toLowerCase` because\n    // lowercasing the entire string causes the length and character position to\n    // vary in some non-English strings with V8-based runtimes.\n    const iterable = stringToArray(str.replace(/[A-Z]/g, (c)=>c.toLowerCase()));\n    const charCount = iterable.length; // <= len if there are emojis, etc\n    const tokens = []; // return value\n    // cursor through the string itself, accounting for characters that have\n    // width with length 2 such as emojis\n    let cursor = 0;\n    // Cursor through the array-representation of the string\n    let charCursor = 0;\n    // Tokenize the string\n    while(charCursor < charCount){\n        let state = start;\n        let nextState = null;\n        let tokenLength = 0;\n        let latestAccepting = null;\n        let sinceAccepts = -1;\n        let charsSinceAccepts = -1;\n        while(charCursor < charCount && (nextState = state.go(iterable[charCursor]))){\n            state = nextState;\n            // Keep track of the latest accepting state\n            if (state.accepts()) {\n                sinceAccepts = 0;\n                charsSinceAccepts = 0;\n                latestAccepting = state;\n            } else if (sinceAccepts >= 0) {\n                sinceAccepts += iterable[charCursor].length;\n                charsSinceAccepts++;\n            }\n            tokenLength += iterable[charCursor].length;\n            cursor += iterable[charCursor].length;\n            charCursor++;\n        }\n        // Roll back to the latest accepting state\n        cursor -= sinceAccepts;\n        charCursor -= charsSinceAccepts;\n        tokenLength -= sinceAccepts;\n        // No more jumps, just make a new token from the last accepting one\n        tokens.push({\n            t: latestAccepting.t,\n            // token type/name\n            v: str.slice(cursor - tokenLength, cursor),\n            // string value\n            s: cursor - tokenLength,\n            // start index\n            e: cursor // end index (excluding)\n        });\n    }\n    return tokens;\n}\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */ function stringToArray(str) {\n    const result = [];\n    const len = str.length;\n    let index = 0;\n    while(index < len){\n        let first = str.charCodeAt(index);\n        let second;\n        let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n         : str.slice(index, index + 2); // two-index characters\n        result.push(char);\n        index += char.length;\n    }\n    return result;\n}\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */ function fastts(state, input, t, defaultt, jr) {\n    let next;\n    const len = input.length;\n    for(let i = 0; i < len - 1; i++){\n        const char = input[i];\n        if (state.j[char]) {\n            next = state.j[char];\n        } else {\n            next = new State(defaultt);\n            next.jr = jr.slice();\n            state.j[char] = next;\n        }\n        state = next;\n    }\n    next = new State(t);\n    next.jr = jr.slice();\n    state.j[input[len - 1]] = next;\n    return next;\n}\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */ function decodeTlds(encoded) {\n    const words = [];\n    const stack = [];\n    let i = 0;\n    let digits = \"0123456789\";\n    while(i < encoded.length){\n        let popDigitCount = 0;\n        while(digits.indexOf(encoded[i + popDigitCount]) >= 0){\n            popDigitCount++; // encountered some digits, have to pop to go one level up trie\n        }\n        if (popDigitCount > 0) {\n            words.push(stack.join(\"\")); // whatever preceded the pop digits must be a word\n            for(let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--){\n                stack.pop();\n            }\n            i += popDigitCount;\n        } else {\n            stack.push(encoded[i]); // drop down a level into the trie\n            i++;\n        }\n    }\n    return words;\n}\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */ /**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */ /**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */ /**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */ /**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */ /**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */ /**\n * @type Required<Opts>\n */ const defaults = {\n    defaultProtocol: \"http\",\n    events: null,\n    format: noop,\n    formatHref: noop,\n    nl2br: false,\n    tagName: \"a\",\n    target: null,\n    rel: null,\n    validate: true,\n    truncate: Infinity,\n    className: null,\n    attributes: null,\n    ignoreTags: [],\n    render: null\n};\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */ function Options(opts, defaultRender) {\n    if (defaultRender === void 0) {\n        defaultRender = null;\n    }\n    let o = assign({}, defaults);\n    if (opts) {\n        o = assign(o, opts instanceof Options ? opts.o : opts);\n    }\n    // Ensure all ignored tags are uppercase\n    const ignoredTags = o.ignoreTags;\n    const uppercaseIgnoredTags = [];\n    for(let i = 0; i < ignoredTags.length; i++){\n        uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n    }\n    /** @protected */ this.o = o;\n    if (defaultRender) {\n        this.defaultRender = defaultRender;\n    }\n    this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n    o: defaults,\n    /**\n   * @type string[]\n   */ ignoreTags: [],\n    /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */ defaultRender (ir) {\n        return ir;\n    },\n    /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */ check (token) {\n        return this.get(\"validate\", token.toString(), token);\n    },\n    // Private methods\n    /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */ get (key, operator, token) {\n        const isCallable = operator != null;\n        let option = this.o[key];\n        if (!option) {\n            return option;\n        }\n        if (typeof option === \"object\") {\n            option = token.t in option ? option[token.t] : defaults[key];\n            if (typeof option === \"function\" && isCallable) {\n                option = option(operator, token);\n            }\n        } else if (typeof option === \"function\" && isCallable) {\n            option = option(operator, token.t, token);\n        }\n        return option;\n    },\n    /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */ getObj (key, operator, token) {\n        let obj = this.o[key];\n        if (typeof obj === \"function\" && operator != null) {\n            obj = obj(operator, token.t, token);\n        }\n        return obj;\n    },\n    /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */ render (token) {\n        const ir = token.render(this); // intermediate representation\n        const renderFn = this.get(\"render\", null, token) || this.defaultRender;\n        return renderFn(ir, token.t, token);\n    }\n};\nfunction noop(val) {\n    return val;\n}\nvar options = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    defaults: defaults,\n    Options: Options,\n    assign: assign\n});\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/ /**\n * @param {string} value\n * @param {Token[]} tokens\n */ function MultiToken(value, tokens) {\n    this.t = \"token\";\n    this.v = value;\n    this.tk = tokens;\n}\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */ MultiToken.prototype = {\n    isLink: false,\n    /**\n   * Return the string this token represents.\n   * @return {string}\n   */ toString () {\n        return this.v;\n    },\n    /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n  */ toHref (scheme) {\n        return this.toString();\n    },\n    /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */ toFormattedString (options) {\n        const val = this.toString();\n        const truncate = options.get(\"truncate\", val, this);\n        const formatted = options.get(\"format\", val, this);\n        return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + \"…\" : formatted;\n    },\n    /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */ toFormattedHref (options) {\n        return options.get(\"formatHref\", this.toHref(options.get(\"defaultProtocol\")), this);\n    },\n    /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */ startIndex () {\n        return this.tk[0].s;\n    },\n    /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */ endIndex () {\n        return this.tk[this.tk.length - 1].e;\n    },\n    /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */ toObject (protocol) {\n        if (protocol === void 0) {\n            protocol = defaults.defaultProtocol;\n        }\n        return {\n            type: this.t,\n            value: this.toString(),\n            isLink: this.isLink,\n            href: this.toHref(protocol),\n            start: this.startIndex(),\n            end: this.endIndex()\n        };\n    },\n    /**\n   *\n   * @param {Options} options Formatting option\n   */ toFormattedObject (options) {\n        return {\n            type: this.t,\n            value: this.toFormattedString(options),\n            isLink: this.isLink,\n            href: this.toFormattedHref(options),\n            start: this.startIndex(),\n            end: this.endIndex()\n        };\n    },\n    /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */ validate (options) {\n        return options.get(\"validate\", this.toString(), this);\n    },\n    /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */ render (options) {\n        const token = this;\n        const href = this.toHref(options.get(\"defaultProtocol\"));\n        const formattedHref = options.get(\"formatHref\", href, this);\n        const tagName = options.get(\"tagName\", href, token);\n        const content = this.toFormattedString(options);\n        const attributes = {};\n        const className = options.get(\"className\", href, token);\n        const target = options.get(\"target\", href, token);\n        const rel = options.get(\"rel\", href, token);\n        const attrs = options.getObj(\"attributes\", href, token);\n        const eventListeners = options.getObj(\"events\", href, token);\n        attributes.href = formattedHref;\n        if (className) {\n            attributes.class = className;\n        }\n        if (target) {\n            attributes.target = target;\n        }\n        if (rel) {\n            attributes.rel = rel;\n        }\n        if (attrs) {\n            assign(attributes, attrs);\n        }\n        return {\n            tagName,\n            attributes,\n            content,\n            eventListeners\n        };\n    }\n};\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */ function createTokenClass(type, props) {\n    class Token extends MultiToken {\n        constructor(value, tokens){\n            super(value, tokens);\n            this.t = type;\n        }\n    }\n    for(const p in props){\n        Token.prototype[p] = props[p];\n    }\n    Token.t = type;\n    return Token;\n}\n/**\n\tRepresents a list of tokens making up a valid email address\n*/ const Email = createTokenClass(\"email\", {\n    isLink: true,\n    toHref () {\n        return \"mailto:\" + this.toString();\n    }\n});\n/**\n\tRepresents some plain text\n*/ const Text = createTokenClass(\"text\");\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/ const Nl = createTokenClass(\"nl\");\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/ const Url = createTokenClass(\"url\", {\n    isLink: true,\n    /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */ toHref (scheme) {\n        if (scheme === void 0) {\n            scheme = defaults.defaultProtocol;\n        }\n        // Check if already has a prefix scheme\n        return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n    },\n    /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */ hasProtocol () {\n        const tokens = this.tk;\n        return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n    }\n});\nvar multi = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    MultiToken: MultiToken,\n    Base: MultiToken,\n    createTokenClass: createTokenClass,\n    Email: Email,\n    Text: Text,\n    Nl: Nl,\n    Url: Url\n});\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/ const makeState = (arg)=>new State(arg);\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */ function init$1(_ref) {\n    let { groups } = _ref;\n    // Types of characters the URL can definitely end in\n    const qsAccepting = groups.domain.concat([\n        AMPERSAND,\n        ASTERISK,\n        AT,\n        BACKSLASH,\n        BACKTICK,\n        CARET,\n        DOLLAR,\n        EQUALS,\n        HYPHEN,\n        NUM,\n        PERCENT,\n        PIPE,\n        PLUS,\n        POUND,\n        SLASH,\n        SYM,\n        TILDE,\n        UNDERSCORE\n    ]);\n    // Types of tokens that can follow a URL and be part of the query string\n    // but cannot be the very last characters\n    // Characters that cannot appear in the URL at all should be excluded\n    const qsNonAccepting = [\n        APOSTROPHE,\n        COLON,\n        COMMA,\n        DOT,\n        EXCLAMATION,\n        QUERY,\n        QUOTE,\n        SEMI,\n        OPENANGLEBRACKET,\n        CLOSEANGLEBRACKET,\n        OPENBRACE,\n        CLOSEBRACE,\n        CLOSEBRACKET,\n        OPENBRACKET,\n        OPENPAREN,\n        CLOSEPAREN,\n        FULLWIDTHLEFTPAREN,\n        FULLWIDTHRIGHTPAREN,\n        LEFTCORNERBRACKET,\n        RIGHTCORNERBRACKET,\n        LEFTWHITECORNERBRACKET,\n        RIGHTWHITECORNERBRACKET,\n        FULLWIDTHLESSTHAN,\n        FULLWIDTHGREATERTHAN\n    ];\n    // For addresses without the mailto prefix\n    // Tokens allowed in the localpart of the email\n    const localpartAccepting = [\n        AMPERSAND,\n        APOSTROPHE,\n        ASTERISK,\n        BACKSLASH,\n        BACKTICK,\n        CARET,\n        DOLLAR,\n        EQUALS,\n        HYPHEN,\n        OPENBRACE,\n        CLOSEBRACE,\n        PERCENT,\n        PIPE,\n        PLUS,\n        POUND,\n        QUERY,\n        SLASH,\n        SYM,\n        TILDE,\n        UNDERSCORE\n    ];\n    // The universal starting state.\n    /**\n   * @type State<Token>\n   */ const Start = makeState();\n    const Localpart = tt(Start, TILDE); // Local part of the email address\n    ta(Localpart, localpartAccepting, Localpart);\n    ta(Localpart, groups.domain, Localpart);\n    const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();\n    ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n    ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n    ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n    ta(Domain, localpartAccepting, Localpart);\n    ta(Domain, groups.domain, Domain);\n    const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n    tt(Localpart, AT, LocalpartAt); // close to an email address now\n    // Local part of an email address can be e.g. 'http' or 'mailto'\n    tt(Scheme, AT, LocalpartAt);\n    tt(SlashScheme, AT, LocalpartAt);\n    const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n    ta(LocalpartDot, localpartAccepting, Localpart);\n    ta(LocalpartDot, groups.domain, Localpart);\n    const EmailDomain = makeState();\n    ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n    ta(EmailDomain, groups.domain, EmailDomain);\n    const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n    ta(EmailDomainDot, groups.domain, EmailDomain);\n    const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n    ta(EmailDomainDot, groups.tld, Email$1);\n    ta(EmailDomainDot, groups.utld, Email$1);\n    tt(LocalpartAt, LOCALHOST, Email$1);\n    // Hyphen can jump back to a domain name\n    const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n    ta(EmailDomainHyphen, groups.domain, EmailDomain);\n    ta(Email$1, groups.domain, EmailDomain);\n    tt(Email$1, DOT, EmailDomainDot);\n    tt(Email$1, HYPHEN, EmailDomainHyphen);\n    // Final possible email states\n    const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n    /*const EmailColonPort = */ ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n    // Account for dots and hyphens. Hyphens are usually parts of domain names\n    // (but not TLDs)\n    const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n    const DomainDot = tt(Domain, DOT); // domain followed by DOT\n    ta(DomainHyphen, groups.domain, Domain);\n    ta(DomainDot, localpartAccepting, Localpart);\n    ta(DomainDot, groups.domain, Domain);\n    const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n    ta(DomainDot, groups.tld, DomainDotTld);\n    ta(DomainDot, groups.utld, DomainDotTld);\n    ta(DomainDotTld, groups.domain, Domain);\n    ta(DomainDotTld, localpartAccepting, Localpart);\n    tt(DomainDotTld, DOT, DomainDot);\n    tt(DomainDotTld, HYPHEN, DomainHyphen);\n    tt(DomainDotTld, AT, LocalpartAt);\n    const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n    const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n    ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n    // Long URL with optional port and maybe query string\n    const Url$1 = makeState(Url);\n    // URL with extra symbols at the end, followed by an opening bracket\n    const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n    // Query strings\n    ta(Url$1, qsAccepting, Url$1);\n    ta(Url$1, qsNonAccepting, UrlNonaccept);\n    ta(UrlNonaccept, qsAccepting, Url$1);\n    ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n    // Become real URLs after `SLASH` or `COLON NUM SLASH`\n    // Here works with or without scheme:// prefix\n    tt(DomainDotTld, SLASH, Url$1);\n    tt(DomainDotTldColonPort, SLASH, Url$1);\n    // Note that domains that begin with schemes are treated slighly differently\n    const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n    const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n    const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n    const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n    // Scheme states can transition to domain states\n    ta(Scheme, groups.domain, Domain);\n    tt(Scheme, DOT, DomainDot);\n    tt(Scheme, HYPHEN, DomainHyphen);\n    ta(SlashScheme, groups.domain, Domain);\n    tt(SlashScheme, DOT, DomainDot);\n    tt(SlashScheme, HYPHEN, DomainHyphen);\n    // Force URL with scheme prefix followed by anything sane\n    ta(SchemeColon, groups.domain, Url$1);\n    tt(SchemeColon, SLASH, Url$1);\n    ta(UriPrefix, groups.domain, Url$1);\n    ta(UriPrefix, qsAccepting, Url$1);\n    tt(UriPrefix, SLASH, Url$1);\n    const bracketPairs = [\n        [\n            OPENBRACE,\n            CLOSEBRACE\n        ],\n        // {}\n        [\n            OPENBRACKET,\n            CLOSEBRACKET\n        ],\n        // []\n        [\n            OPENPAREN,\n            CLOSEPAREN\n        ],\n        // ()\n        [\n            OPENANGLEBRACKET,\n            CLOSEANGLEBRACKET\n        ],\n        // <>\n        [\n            FULLWIDTHLEFTPAREN,\n            FULLWIDTHRIGHTPAREN\n        ],\n        // （）\n        [\n            LEFTCORNERBRACKET,\n            RIGHTCORNERBRACKET\n        ],\n        // 「」\n        [\n            LEFTWHITECORNERBRACKET,\n            RIGHTWHITECORNERBRACKET\n        ],\n        // 『』\n        [\n            FULLWIDTHLESSTHAN,\n            FULLWIDTHGREATERTHAN\n        ] // ＜＞\n    ];\n    for(let i = 0; i < bracketPairs.length; i++){\n        const [OPEN, CLOSE] = bracketPairs[i];\n        const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n        // Continue not accepting for open brackets\n        tt(UrlNonaccept, OPEN, UrlOpen);\n        // Closing bracket component. This character WILL be included in the URL\n        tt(UrlOpen, CLOSE, Url$1);\n        // URL that beings with an opening bracket, followed by a symbols.\n        // Note that the final state can still be `UrlOpen` (if the URL has a\n        // single opening bracket for some reason).\n        const UrlOpenQ = makeState(Url);\n        ta(UrlOpen, qsAccepting, UrlOpenQ);\n        const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n        ta(UrlOpen, qsNonAccepting);\n        // URL that begins with an opening bracket, followed by some symbols\n        ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n        ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n        ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n        ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n        // Close brace/bracket to become regular URL\n        tt(UrlOpenQ, CLOSE, Url$1);\n        tt(UrlOpenSyms, CLOSE, Url$1);\n    }\n    tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n    tt(Start, NL$1, Nl); // single new line\n    return {\n        start: Start,\n        tokens: tk\n    };\n}\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */ function run(start, input, tokens) {\n    let len = tokens.length;\n    let cursor = 0;\n    let multis = [];\n    let textTokens = [];\n    while(cursor < len){\n        let state = start;\n        let secondState = null;\n        let nextState = null;\n        let multiLength = 0;\n        let latestAccepting = null;\n        let sinceAccepts = -1;\n        while(cursor < len && !(secondState = state.go(tokens[cursor].t))){\n            // Starting tokens with nowhere to jump to.\n            // Consider these to be just plain text\n            textTokens.push(tokens[cursor++]);\n        }\n        while(cursor < len && (nextState = secondState || state.go(tokens[cursor].t))){\n            // Get the next state\n            secondState = null;\n            state = nextState;\n            // Keep track of the latest accepting state\n            if (state.accepts()) {\n                sinceAccepts = 0;\n                latestAccepting = state;\n            } else if (sinceAccepts >= 0) {\n                sinceAccepts++;\n            }\n            cursor++;\n            multiLength++;\n        }\n        if (sinceAccepts < 0) {\n            // No accepting state was found, part of a regular text token add\n            // the first text token to the text tokens array and try again from\n            // the next\n            cursor -= multiLength;\n            if (cursor < len) {\n                textTokens.push(tokens[cursor]);\n                cursor++;\n            }\n        } else {\n            // Accepting state!\n            // First close off the textTokens (if available)\n            if (textTokens.length > 0) {\n                multis.push(initMultiToken(Text, input, textTokens));\n                textTokens = [];\n            }\n            // Roll back to the latest accepting state\n            cursor -= sinceAccepts;\n            multiLength -= sinceAccepts;\n            // Create a new multitoken\n            const Multi = latestAccepting.t;\n            const subtokens = tokens.slice(cursor - multiLength, cursor);\n            multis.push(initMultiToken(Multi, input, subtokens));\n        }\n    }\n    // Finally close off the textTokens (if available)\n    if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n    }\n    return multis;\n}\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */ function initMultiToken(Multi, input, tokens) {\n    const startIdx = tokens[0].s;\n    const endIdx = tokens[tokens.length - 1].e;\n    const value = input.slice(startIdx, endIdx);\n    return new Multi(value, tokens);\n}\nconst warn = typeof console !== \"undefined\" && console && console.warn || (()=>{});\nconst warnAdvice = \"until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.\";\n// Side-effect initialization state\nconst INIT = {\n    scanner: null,\n    parser: null,\n    tokenQueue: [],\n    pluginQueue: [],\n    customSchemes: [],\n    initialized: false\n};\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */ /**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */ /**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */ /**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */ /**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */ function reset() {\n    State.groups = {};\n    INIT.scanner = null;\n    INIT.parser = null;\n    INIT.tokenQueue = [];\n    INIT.pluginQueue = [];\n    INIT.customSchemes = [];\n    INIT.initialized = false;\n}\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */ function registerTokenPlugin(name, plugin) {\n    if (typeof plugin !== \"function\") {\n        throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n    }\n    for(let i = 0; i < INIT.tokenQueue.length; i++){\n        if (name === INIT.tokenQueue[i][0]) {\n            warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n            INIT.tokenQueue[i] = [\n                name,\n                plugin\n            ];\n            return;\n        }\n    }\n    INIT.tokenQueue.push([\n        name,\n        plugin\n    ]);\n    if (INIT.initialized) {\n        warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n    }\n}\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */ function registerPlugin(name, plugin) {\n    if (typeof plugin !== \"function\") {\n        throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n    }\n    for(let i = 0; i < INIT.pluginQueue.length; i++){\n        if (name === INIT.pluginQueue[i][0]) {\n            warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n            INIT.pluginQueue[i] = [\n                name,\n                plugin\n            ];\n            return;\n        }\n    }\n    INIT.pluginQueue.push([\n        name,\n        plugin\n    ]);\n    if (INIT.initialized) {\n        warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n    }\n}\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} protocol\n * @param {boolean} [optionalSlashSlash]\n */ function registerCustomProtocol(scheme, optionalSlashSlash) {\n    if (optionalSlashSlash === void 0) {\n        optionalSlashSlash = false;\n    }\n    if (INIT.initialized) {\n        warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n    }\n    if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n        throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n    }\n    INIT.customSchemes.push([\n        scheme,\n        optionalSlashSlash\n    ]);\n}\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */ function init() {\n    // Initialize scanner state machine and plugins\n    INIT.scanner = init$2(INIT.customSchemes);\n    for(let i = 0; i < INIT.tokenQueue.length; i++){\n        INIT.tokenQueue[i][1]({\n            scanner: INIT.scanner\n        });\n    }\n    // Initialize parser state machine and plugins\n    INIT.parser = init$1(INIT.scanner.tokens);\n    for(let i = 0; i < INIT.pluginQueue.length; i++){\n        INIT.pluginQueue[i][1]({\n            scanner: INIT.scanner,\n            parser: INIT.parser\n        });\n    }\n    INIT.initialized = true;\n}\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */ function tokenize(str) {\n    if (!INIT.initialized) {\n        init();\n    }\n    return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */ function find(str, type, opts) {\n    if (type === void 0) {\n        type = null;\n    }\n    if (opts === void 0) {\n        opts = null;\n    }\n    if (type && typeof type === \"object\") {\n        if (opts) {\n            throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n        }\n        opts = type;\n        type = null;\n    }\n    const options = new Options(opts);\n    const tokens = tokenize(str);\n    const filtered = [];\n    for(let i = 0; i < tokens.length; i++){\n        const token = tokens[i];\n        if (token.isLink && (!type || token.t === type) && options.check(token)) {\n            filtered.push(token.toFormattedObject(options));\n        }\n    }\n    return filtered;\n}\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */ function test(str, type) {\n    if (type === void 0) {\n        type = null;\n    }\n    const tokens = tokenize(str);\n    return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNERBQTREO0FBQzVELGtEQUFrRDtBQUNsRCxxREFBcUQ7QUFDckQsTUFBTUEsY0FBYztBQUNwQixzREFBc0Q7QUFDdEQsTUFBTUMsZUFBZTtBQUVyQjs7Ozs7O0NBTUMsR0FDRCxNQUFNQyxTQUFTLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssTUFBTUMsT0FBT0QsV0FBWTtRQUM1QkQsTUFBTSxDQUFDRSxJQUFJLEdBQUdELFVBQVUsQ0FBQ0MsSUFBSTtJQUMvQjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVEOzs7Q0FHQyxHQUVEOztDQUVDLEdBRUQsd0NBQXdDO0FBQ3hDLE1BQU1HLFVBQVU7QUFDaEIsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxhQUFhO0FBRW5COzs7OztDQUtDLEdBQ0QsU0FBU0MsY0FBY0MsSUFBSSxFQUFFQyxNQUFNO0lBQ2pDLElBQUksQ0FBRUQsQ0FBQUEsUUFBUUMsTUFBSyxHQUFJO1FBQ3JCQSxNQUFNLENBQUNELEtBQUssR0FBRyxFQUFFO0lBQ25CO0lBQ0EsT0FBT0MsTUFBTSxDQUFDRCxLQUFLO0FBQ3JCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTRSxZQUFZQyxDQUFDLEVBQUVDLEtBQUssRUFBRUgsTUFBTTtJQUNuQyxJQUFJRyxLQUFLLENBQUNmLFFBQVEsRUFBRTtRQUNsQmUsS0FBSyxDQUFDWixhQUFhLEdBQUc7UUFDdEJZLEtBQUssQ0FBQ1gsYUFBYSxHQUFHO0lBQ3hCO0lBQ0EsSUFBSVcsS0FBSyxDQUFDZCxNQUFNLEVBQUU7UUFDaEJjLEtBQUssQ0FBQ1os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LEVBQUVELElBQUs7UUFDdEMsTUFBTVYsUUFBUW1ILE1BQU0sQ0FBQ3pHLEVBQUU7UUFDdkIsSUFBSVYsTUFBTTBMLE1BQU0sSUFBSyxFQUFDUyxRQUFRbk0sTUFBTVYsQ0FBQyxLQUFLNk0sSUFBRyxLQUFNWixRQUFRVixLQUFLLENBQUM3SyxRQUFRO1lBQ3ZFd1IsU0FBUzdSLElBQUksQ0FBQ0ssTUFBTXNNLGlCQUFpQixDQUFDZjtRQUN4QztJQUNGO0lBQ0EsT0FBT2lHO0FBQ1Q7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxTQUFTM1EsS0FBS3dHLEdBQUcsRUFBRThFLElBQUk7SUFDckIsSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFDbkJBLE9BQU87SUFDVDtJQUNBLE1BQU1oRixTQUFTbUssU0FBU2pLO0lBQ3hCLE9BQU9GLE9BQU94RyxNQUFNLEtBQUssS0FBS3dHLE1BQU0sQ0FBQyxFQUFFLENBQUN1RSxNQUFNLElBQUssRUFBQ1MsUUFBUWhGLE1BQU0sQ0FBQyxFQUFFLENBQUM3SCxDQUFDLEtBQUs2TSxJQUFHO0FBQ2pGO0FBRStMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2Utam91cm5hbC8uL25vZGVfbW9kdWxlcy9saW5raWZ5anMvZGlzdC9saW5raWZ5LmVzLmpzP2VkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEIERPIE5PVCBFRElUIERJUkVDVExZXG4vLyBTZWUgdXBkYXRlLXRsZHMuanMgZm9yIGVuY29kaW5nL2RlY29kaW5nIGZvcm1hdFxuLy8gaHR0cHM6Ly9kYXRhLmlhbmEub3JnL1RMRC90bGRzLWFscGhhLWJ5LWRvbWFpbi50eHRcbmNvbnN0IGVuY29kZWRUbGRzID0gJ2FhYTFycDNiYjBvdHQzdmllNGMxbGUyb2dhZG81dWRoYWJpN2MwYWRlbXk1Y2VudHVyZTZvdW50YW50MHM5bzF0b3I0ZDBzMXVsdDRlMGcxcm8ydG5hNGYwbDFyaWNhNWcwYWtoYW41ZW5jeTVpMGcxcmJ1czNmb3JjZTV0ZWw1a2RuM2wwaWJhYmE0cGF5NGxmaW5hbno2c3RhdGU1eTJzYWNlM3RvbTVtMGF6b240ZXJpY2FuZXhwcmVzczdmYW1pbHkxMXgyZmFtM2ljYTNzdGVyZGFtOG5hbHl0aWNzN2Ryb2lkNXF1YW40ejJvMGwycGFydG1lbnRzOHAwbGU0cTB1YXJlbGxlOHIwYWIxbWNvNGNoaTNteTJwYTJ0MGUzczBkYTJpYTJzb2NpYXRlczl0MGhsZXRhNXRvcm5leTd1MGN0aW9uNWRpMGJsZTNvM3Nwb3N0NXRob3IzbzBzNHZpYW5jYTZ3MHMyeDBhMnowdXJlNWJhMGJ5MmlkdTNuYW1leDNuYXJlcHVibGljMTFkMWsycjBjZWxvbmE1bGF5Y2FyZDRzNWVmb290NWdhaW5zNnNlYmFsbDVrZXRiYWxsOHVoYXVzNXllcm41YjBjMXQxdmEzY2cxbjJkMWUwYXRzMnV0eTRlcjJudGxleTVybGluNHN0MGJ1eTV0MmYxZzFoMGFydGk1aTBibGUzZDFrZTJuZzBvM28xejJqMWxhY2swZnJpZGF5OW9ja2J1c3RlcjhnMW9tYmVyZzd1ZTNtMHMxdzJuMHBwYXJpYmFzOW8wYXRzM2VocmluZ2VyOGZhMm0xbmQybzBrMGluZzVzY2gydGlrMm9uNHQxdXRpcXVlNngycjBhZGVzY282aWRnZXN0b25lOW9hZHdheTVrZXIzdGhlcjV1c3NlbHM3czF0MXVpbGQwZXJzNnNpbmVzczZ5MXp6M3YxdzF5MXowaDNjYTBiMWZlMmwwbDF2aW5rbGVpbjltMGVyYTNwMm5vbjNwZXRvd241aXRhbDBvbmU4cjBhdmFuNGRzMmUwZXIwczRzMnNhMWUxaDFpbm80dDBlcmluZzVob2xpYzdiYTFuMXJlM2MxZDFlbnRlcjRvMXJuM2YwYTFkMmcxaDBhbmVsMm5lbDRyaXR5NHNlMnQyZWFwM2ludGFpNXJpc3RtYXM2b21lNHVyY2g1aTBwcmlhbmk2cmNsZTRzY28zdGFkZWw0aTBjMnkzazFsMGFpbXM0ZWFuaW5nNmljazJuaWMxcXVlNm90aGluZzV1ZDN1YjBtZWQ2bTFuMW8wYWNoM2RlczNmZmVlNGxsZWdlNG9nbmU1bTBjYXN0NG1iYW5rNHVuaXR5NnBhbnkycmUzdXRlcjVzZWM0bmRvczNzdHJ1Y3Rpb244dWx0aW5nN3RhY3QzcmFjdG9yczlva2luZzRsMXAycnNpY2E1dW50cnk0cG9uMHM0cnNlczZwYTJyMGVkaXQwY2FyZDR1bmlvbjlpY2tldDVvd24zczF1aXNlMHM2dTBpc2luZWxsYTl2MXcxeDF5MG1ydTNvdTN6MmRhYnVyM2QxbmNlM3RhMWUxaW5nM3N1bjR5MmNsazNkczJlMGFsMGVyMnMzZ3JlZTRsaXZlcnk1bDFvaXR0ZTV0YTNtb2NyYXQ2bnRhbDJpc3Q1c2kwZ240djJobDJpYW1vbmRzNmV0MmdpdGFsNXJlY3Qwb3J5N3Njb3VudDN2ZXI1aDJ5MmoxazFtMW5wMm8wY3MxdG9yNGcxbWFpbnM1dDF3bmxvYWQ3cml2ZTR0djJ1YmFpM25sb3A0cG9udDRyYmFuNXZhZzJyMnoyZWFydGgzdDJjMG8yZGVrYTN1MGNhdGlvbjhlMWcxbWFpbDNlcmNrNW5lcmd5NGdpbmVlcjBpbmc5dGVycHJpc2VzMTBwc29uNHF1aXBtZW50OHIwaWNzc29uNm5pM3MwcTF0YXRlNXQxdTByb3Zpc2lvbjhzMnZlbnRzNXhjaGFuZ2U2cGVydDNvc2VkNHJlc3M1dHJhc3BhY2UxMGZhZ2UyaWwxcndpbmRzNnRoM21pbHk0bjBzMnJtMGVyczVzaGlvbjR0M2VkZXgzZWRiYWNrNnJyYXJpM2VybzZpMGRlbGl0eTVvMmxtMm5hbDFuY2UxaWFsN3JlMHN0b25lNm1kYWxlNnNoMGluZzV0MG5lc3M2ajFrMWxpY2tyM2dodHM0cjJvcmlzdDR3ZXJzNXkybTFvMG8wZDF0YmFsbDZyZDFleDJzYWxlNHVtM3VuZGF0aW9uOHgycjBlZTFzZW5pdXM3bDFvZ2FuczRudGllcjd0cjJ1aml0c3U1bjBkMnJuaXR1cmU3dGJvbDV5aTNnYTBsMGxlcnkzbzF1cDRtZTBzM3AxcmRlbjR5MmIwaXozZDBuMmUwYTFudDBpbmc1b3JnZTVmMWcwZWUzaDFpMGZ0MHMzdmVzMmluZzVsMGFzczNlMW9iYWwybzRtMGFpbDNiaDJvMXgybjFvZGFkZHk1bGQwcG9pbnQ2ZjJvMGR5ZWFyNWcwbGU0cDF0MXYycDFxMXIwYWluZ2VyNXBoaWNzNXRpczRlZW4zaXBlM29jZXJ5NHVwNHMxdDF1MGFyZGlhbjZjY2kzZ2UyaWRlMnRhcnM1cnUzdzF5MmhhaXIybWJ1cmc1bmdvdXQ1dXMzYm8yZGZjMGJhbms3ZWFsdGgwY2FyZThscDFzaW5raTZyZTFtZXM1aXBob3A0c2FtaXRzdTd0YWNoaTV2MmswdDJtMW4xb2NrZXk0bGRpbmdzNWlkYXk1bWVkZXBvdDVnb29kczVzMGVuc2U3bmRhM3JzZTNzcGl0YWw1dDBpbmc1dDBlbHMzbWFpbDV1c2UzdzJyMXNiYzN0MXUwZ2hlczV5YXR0M3VuZGFpN2libTJjYmMyZTF1MmQxZTBlZTNmbTJrYW5vNGwxbTBhbWF0NGRiMm1vMGJpbGllbjluMGMxZHVzdHJpZXM4ZmluaXRpNW8yZzFrMXN0aXR1dGU2dXJhbmNlNGU0dDBlcm5hdGlvbmFsMTB1aXQ0dmVzdG1lbnRzMTBvMXBpcmFuZ2E3cTFyMGlzaDRzMG1haWxpNXQwYW5idWw3dDBhdTJ2M2phZ3VhcjR2YTNjYjJlMGVwMnR6dDN3ZWxyeTZpbzJsbDJtMHAybmoybzBiczF1cmc0dDF5MnAwbW9yZ2FuNnJzM3VlZ29zNG5pcGVyN2thdWZlbjVkZGkzZTBycnlob3RlbHM2bG9naXN0aWNzOXByb3BlcnRpZXMxNGZoMmcxaDFpMGExZHMybTFuZGxlNHRjaGVuNXdpM20xbjFvZWxuM21hdHN1NXNoZXI1cDBtZzJuMnIwZDFlZDN1b2tncm91cDh3MXkwb3RvNHoybGEwY2FpeGE1bWJvcmdoaW5pOGVyM25jYXN0ZXI2ZDByb3ZlcjZ4ZXNzNXNhbGxlNXQwaW5vM3JvYmU1dzB5ZXI1YjFjMWRzMmVhc2UzY2xlcmM1ZnJhazRnYWwybzJ4dXM0Z2J0M2kwZGwyZmUwaW5zdXJhbmNlOXN0eWxlN2dodGluZzZrZTJsbHkzbWl0ZWQ0bzJuY29sbjRrMnBzeTN2ZTFpbmc1azFsYzFwMm9hbjBzM2NrZXIzdXMzbDFuZG9uNHR0ZTFvM3ZlM3BsMGZpbmFuY2lhbDExcjFzMXQwZDBhM3UwbmRiZWNrNnhlMXVyeTV2MXkybWEwZHJpZDRpZjFzb240a2V1cDRuMGFnZW1lbnQ3Z28zcDFya2V0MGluZzNzNHJpb3R0NXNoYWxsczd0dGVsNWJhMmMwa2luc2V5N2QxZTBkMGlhM2V0Mmxib3VybmU3bWUxb3JpYWw2bjB1MnJja21zZDdnMWgxaWFtaTNjcm9zb2Z0N2wxbmkxdDJ0MHN1YmlzaGk5azFsMGIxczJtMGEybjFvMGJpMGxlNGRhMmUxaTFtMW5hc2gzZXkyc3RlcjVybW9uM3RnYWdlNnNjb3c0dG8wcmN5Y2xlczl2MGllNHAxcTFyMXMwZDJ0MG4xcjJ1MHNldW0zaWM0djF3MXgxeTF6Mm5hMGIxZ295YTRtZTJ0dXJhNHZ5M2JhMmMxZTBjMXQwYmFuazRmbGl4NHdvcms1dXN0YXI1dzBzMnh0MGRpcmVjdDd1czRmMGwyZzBvMmhrMmkwY28ya2Uxb24zbmphM3NzYW4xeTVsMW8wa2lhM3J0b240dzBydXozdHY0cDFyMGExdzJ0dDJ1MXljMnoyb2JpMXNlcnZlcjdmZmljZTVraW5hd2E2bGF5YW4wZ3JvdXA5ZG5hdnk1bG8zbTBlZ2E0bmUxZzFsMGluZTVvbzJwZW4zcmFjbGUzbmdlNGcwYW5pYzVpZ2luczZzYWthNHRzdWthNHQydmgzcGEwZ2UybmFzb25pYzdyaXMyczF0bmVyczRzMXkzeTJjY3czZTB0MmYwaXplcjVnMWgwYXJtYWN5NmQxaWxpcHM1b25lMnRvMGdyYXBoeTZzNHlzaW81aWNzMXRldDJ1cmVzNmQxbjBnMWsyb25lZXI1enphNGsxbDBhY2UyeTBzdGF0aW9uOXVtYmluZzVzM20xbjBjMm9obDJrZXIzbGl0aWU1cm4yc3QzcjBhbWVyaWNhNnhpM2VzczNpbWUzbzBkMHVjdGlvbnM4ZjFncmVzc2l2ZThtbzJwZXJ0aWVzM3k1dGVjdGlvbjh1MGRlbnRpYWw5czF0MXViMncwYzJ5MnFhMXBvbjN1ZWJlYzNzdDVyYWNpbmc0ZGlvNGUwYWQxbGVzdGF0ZTZ0b3IyeTRjaXBlczVkMHN0b25lNXVtYnJlbGxhOWhhYjNpc2UwbjN0MmxpYW5jZTZuMHQwYWxzNXBhaXIzb3J0M3VibGljYW44c3QwYXVyYW50OHZpZXcwczV4cm90aDZpY2gwYXJkbGk2b2gzbDFvMXAybzBja3MzZGVvM2dlcnM0b20zczB2cDN1MGdieTNocjJuMncwZTJ5dWt5dTZzYTBhcmxhbmQ2ZmUwdHk0a3VyYTRsZTFvbjNtc2NsdWI0dW5nNW5kdmlrMGNvcm9tYW50MTJvZmk0cDFybDJzMXZlMnhvM2IwaTFzMmMwYTFiMWhhZWZmbGVyN21pZHQ0b2xhcnNoaXBzOG9sM3VsZTN3YXJ6NWllbmNlNW90M2QxZTBhcmNoM3QyY3VyZTFpdHk2ZWsybGVjdDRuZXIzcnZpY2VzNnZlbjN3MXgweTNmcjJnMWgwYW5ncmlsYTZycDJ3MmVsbDNpYTFrc2hhNW9lczJwMHBpbmc1dWppM3czaTBsazJuYTFnbGVzNXRlM2oxazBpMG4yeTBwZTRsMGluZzRtMGFydDNpbGU0bjBjZjNvMGNjZXIzaWFsNGZ0YmFuazR3YXJlNmh1MmxhcjJ1dGlvbnM3bmcxeTJ5MnBhMGNlM29ydDJ0M3IwbDJzMXQwYWRhMnBsZXM0cjF0ZWJhbms0ZmFybTdjMGdyb3VwNm9ja2hvbG02cmFnZTNlM3JlYW00dWRpbzJ5M3lsZTR1MGNrczNwcGxpZXMzeTJvcnQ1cmYxZ2VyeTV6dWtpNXYxd2F0Y2g0aXNzNHgxeTBkbmV5NHN0ZW1zNnoydGFiMWlwZWk0bGsyb2JhbzRyZ2V0NHRhbW90b3JzNnIydG9vNHgwaTNjMGkyZDBrMmVhbTJjaDBub2xvZ3k4bDFtYXNlazVubmlzNHZhM2YxZzFoMGQxZWF0ZXIycmU2aWFhMmNrZXRzNWVuZGE0cHMycmVzMm9sNGowbWF4eDR4MmswbWF4eDVsMW0wYWxsNG4xbzBkYXkza3lvM29sczNwMXJheTNzaGliYTV0YWwzdXJzM3duMnlvdGEzczNyMGFkZTFpbmc0aW5pbmc1dmVsMGVyczBpbnN1cmFuY2UxNnVzdDN2MnQxdWJlMmkxbmVzM3NodTR2MHMydzF6MnVhMWJhbmszczJnMWsxbmljb20zdmVyc2l0eThvMm9sMnBzMnMxeTF6MnZhMGNhdGlvbnM3bmExZ3VhcmQ3YzFlMGdhczNudHVyZXM2cmlzaWduNW3DtmdlbnNiZXJhdGVyMnVuZzE0c2ljaGVydW5nMTB0MmcxaTBhamVzNGRlbzNnMWtpbmc0bGxhczRuMXAxcmdpbjRzYTFpb240dmExbzNsYWFuZGVyZW45bjFvZGthM2x2bzN0ZTFpbmczbzJ5YWdlNXUyd2FsZXMybWFydDR0ZXI0bmcwZ291NXRjaDBlczZlYXRoZXIwY2hhbm5lbDEyYmNhbTNlcjJzaXRlNWQwZGluZzVpYm8ycjNmMWhvc3dobzZpZW4ya2kybGxpYW1oaWxsOW4wZG93czRlMW5lcnM2bWUyb2x0ZXJza2x1d2VyMTFvZHNpZGU2cmswczJsZDN3MnMxdGMxZjN4Ym94M2Vyb3g0ZmluaXR5NmlodWFuNG4yeHgyeXozeWFjaHRzNGhvbzNtYXh1bjVuZGV4NWUxb2RvYmFzaGk3Z2Eya29oYW1hNnUwdHViZTZ0MXVuM3phMHBwb3M0cmEzZXJvM2lwMm0xb25lM3VlcmljaDZ3Mic7XG4vLyBJbnRlcm5hdGlvbmFsaXplZCBkb21haW4gbmFtZXMgY29udGFpbmluZyBub24tQVNDSUlcbmNvbnN0IGVuY29kZWRVdGxkcyA9ICfOtc67Mc+FMtCx0LMx0LXQuzPQtNC10YLQuDTQtdGOMtC60LDRgtC+0LvQuNC6NtC+0Lwz0LzQutC0MtC+0L0x0YHQutCy0LA20L7QvdC70LDQudC9NdGA0LMz0YDRg9GBMtGEMtGB0LDQudGCM9GA0LEz0YPQutGAM9Kb0LDQtzPVsNWh1bUz15nXqdeo15DXnDXXp9eV150z2KfYqNmI2LjYqNmKNdix2KfZhdmD2Yg12YTYp9ix2K/ZhjTYqNit2LHZitmGNdis2LLYp9im2LE12LPYudmI2K/ZitipNti52YTZitin2YY12YXYutix2Kg12YXYp9ix2KfYqjXbjNix2KfZhjXYqNin2LHYqjLYstin2LE02YrYqtmDM9q+2KfYsdiqNdiq2YjZhtizNNiz2YjYr9in2YYz2LHZitipNdi02KjZg9ipNNi52LHYp9mCMtioMtmF2KfZhjTZgdmE2LPYt9mK2YY22YLYt9ixM9mD2KfYq9mI2YTZitmDNtmI2YUz2YXYtdixMtmE2YrYs9mK2Kc12YjYsdmK2KrYp9mG2YrYpzfZgti5NNmH2YXYsdin2Yc12b7Yp9qp2LPYqtin2YY32oDYp9ix2Ko04KSV4KWJ4KSuM+CkqOClh+CknzPgpK3gpL7gpLDgpKQw4KSu4KWNM+Cli+CkpDXgpLjgpILgpJfgpKDgpKg14Kas4Ka+4KaC4Kay4Ka+NeCmreCmvuCmsOCmpDLgp7DgpqQ04Kit4Ki+4Kiw4KikNOCqreCqvuCqsOCqpDTgrK3grL7grLDgrKQ04K6H4K6o4K+N4K6k4K6/4K6v4K6+NuCusuCumeCvjeCuleCviDbgrprgrr/grpngr43grpXgrqrgr43grqrgr4LgrrDgr40xMeCwreCwvuCwsOCwpOCxjTXgsq3gsr7gsrDgsqQ04LSt4LS+4LSw4LSk4LSCNeC2veC2guC2muC3jzTguITguK3guKEz4LmE4LiX4LiiM+C6peC6suC6pzPhg5Lhg5Qy44G/44KT44GqM+OCouODnuOCvuODszTjgq/jg6njgqbjg4k044Kw44O844Kw44OrNOOCs+ODoDLjgrnjg4jjgqIz44K744O844OrM+ODleOCoeODg+OCt+ODp+ODszbjg53jgqTjg7Pjg4g05LiW55WMMuS4reS/oTHlm70x5ZyLMeaWh+e9kTPkuprpqazpgIoz5LyB5LiaMuS9m+WxsTLkv6Hmga8y5YGl5bq3MuWFq+WNpjLlhazlj7gx55uKMuWPsOa5vjHngaMy5ZWG5Z+OMeW6lzHmoIcy5ZiJ6YeMMOWkp+mFkuW6lzXlnKjnur8y5aSn5ou/MuWkqeS4u+aVmTPlqLHkuZAy5a626Zu7MuW5v+S4nDLlvq7ljZoy5oWI5ZaEMuaIkeeIseS9oDPmiYvmnLoy5oub6IGYMuaUv+WKoTHlupwy5paw5Yqg5Z2hMumXuzLml7blsJoy5pu457GNMuacuuaehDLmt6HpqazplKEz5ri45oiPMua+s+mWgDLngrnnnIsy56e75YqoMue7hOe7h+acuuaehDTnvZHlnYAx5bqXMeermTHnu5wy6IGU6YCaMuiwt+atjDLotK3niaky6YCa6LKpMumbhuWbojLpm7voqIrnm4jnp5E06aOe5Yip5rWmM+mjn+WTgTLppJDljoUy6aaZ5qC86YeM5ouJM+a4rzLri7frhLcx7Lu0MuyCvOyEsTLtlZzqta0yJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICogQHRlbXBsYXRlIEJcbiAqIEBwYXJhbSB7QX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0J9IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0EgJiBCfVxuICovXG5jb25zdCBhc3NpZ24gPSAodGFyZ2V0LCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICB0YXJnZXRba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSBnZW5lcmF0aW9uIHV0aWxpdGllc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBbZ3JvdXA6IHN0cmluZ106IHRydWUgfX0gRmxhZ3NcbiAqL1xuXG4vLyBLZXlzIGluIHNjYW5uZXIgQ29sbGVjdGlvbnMgaW5zdGFuY2VzXG5jb25zdCBudW1lcmljID0gJ251bWVyaWMnO1xuY29uc3QgYXNjaWkgPSAnYXNjaWknO1xuY29uc3QgYWxwaGEgPSAnYWxwaGEnO1xuY29uc3QgYXNjaWludW1lcmljID0gJ2FzY2lpbnVtZXJpYyc7XG5jb25zdCBhbHBoYW51bWVyaWMgPSAnYWxwaGFudW1lcmljJztcbmNvbnN0IGRvbWFpbiA9ICdkb21haW4nO1xuY29uc3QgZW1vamkgPSAnZW1vamknO1xuY29uc3Qgc2NoZW1lID0gJ3NjaGVtZSc7XG5jb25zdCBzbGFzaHNjaGVtZSA9ICdzbGFzaHNjaGVtZSc7XG5jb25zdCB3aGl0ZXNwYWNlID0gJ3doaXRlc3BhY2UnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzIHRvIHJlZ2lzdGVyIGluXG4gKiBAcmV0dXJucyB7VFtdfSBDdXJyZW50IGxpc3Qgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyR3JvdXAobmFtZSwgZ3JvdXBzKSB7XG4gIGlmICghKG5hbWUgaW4gZ3JvdXBzKSkge1xuICAgIGdyb3Vwc1tuYW1lXSA9IFtdO1xuICB9XG4gIHJldHVybiBncm91cHNbbmFtZV07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBhZGRcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IGdyb3Vwc1xuICogQHBhcmFtIHtGbGFnc30gZmxhZ3NcbiAqL1xuZnVuY3Rpb24gYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcykge1xuICBpZiAoZmxhZ3NbbnVtZXJpY10pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWldKSB7XG4gICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgZmxhZ3NbYWxwaGFdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWludW1lcmljXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYV0pIHtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYWxwaGFudW1lcmljXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1tlbW9qaV0pIHtcbiAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gZmxhZ3MpIHtcbiAgICBjb25zdCBncm91cCA9IHJlZ2lzdGVyR3JvdXAoaywgZ3JvdXBzKTtcbiAgICBpZiAoZ3JvdXAuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgIGdyb3VwLnB1c2godCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBjaGVja1xuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcmV0dXJucyB7RmxhZ3N9IGdyb3VwIGZsYWdzIHRoYXQgY29udGFpbiB0aGlzIHRva2VuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzRm9yVG9rZW4odCwgZ3JvdXBzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGMgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKGdyb3Vwc1tjXS5pbmRleE9mKHQpID49IDApIHtcbiAgICAgIHJlc3VsdFtjXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtudWxsIHwgVCB9IFRyYW5zaXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZSBhIGJhc2ljIHN0YXRlIG1hY2hpbmUgc3RhdGUuIGogaXMgdGhlIGxpc3Qgb2YgY2hhcmFjdGVyIHRyYW5zaXRpb25zLFxuICoganIgaXMgdGhlIGxpc3Qgb2YgcmVnZXgtbWF0Y2ggdHJhbnNpdGlvbnMsIGpkIGlzIHRoZSBkZWZhdWx0IHN0YXRlIHRvXG4gKiB0cmFuc2l0aW9uIHRvIHQgaXMgdGhlIGFjY2VwdGluZyB0b2tlbiB0eXBlLCBpZiBhbnkuIElmIHRoaXMgaXMgdGhlIHRlcm1pbmFsXG4gKiBzdGF0ZSwgdGhlbiBpdCBkb2VzIG5vdCBlbWl0IGEgdG9rZW4uXG4gKlxuICogVGhlIHRlbXBsYXRlIHR5cGUgVCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0aGlzIHN0YXRlIGFjY2VwdHMuIFRoaXNcbiAqIHNob3VsZCBiZSBhIHN0cmluZyAoc3VjaCBhcyBvZiB0aGUgdG9rZW4gZXhwb3J0cyBpbiBgdGV4dC5qc2ApIG9yIGFcbiAqIE11bHRpVG9rZW4gc3ViY2xhc3MgKGZyb20gYG11bHRpLmpzYClcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdG9rZW5dIFRva2VuIHRoYXQgdGhpcyBzdGF0ZSBlbWl0c1xuICovXG5mdW5jdGlvbiBTdGF0ZSh0b2tlbikge1xuICBpZiAodG9rZW4gPT09IHZvaWQgMCkge1xuICAgIHRva2VuID0gbnVsbDtcbiAgfVxuICAvLyB0aGlzLm4gPSBudWxsOyAvLyBERUJVRzogU3RhdGUgbmFtZVxuICAvKiogQHR5cGUge3sgW2lucHV0OiBzdHJpbmddOiBTdGF0ZTxUPiB9fSBqICovXG4gIHRoaXMuaiA9IHt9OyAvLyBJTVBMRU1FTlRBVElPTiAxXG4gIC8vIHRoaXMuaiA9IFtdOyAvLyBJTVBMRU1FTlRBVElPTiAyXG4gIC8qKiBAdHlwZSB7W1JlZ0V4cCwgU3RhdGU8VD5dW119IGpyICovXG4gIHRoaXMuanIgPSBbXTtcbiAgLyoqIEB0eXBlIHs/U3RhdGU8VD59IGpkICovXG4gIHRoaXMuamQgPSBudWxsO1xuICAvKiogQHR5cGUgez9UfSB0ICovXG4gIHRoaXMudCA9IHRva2VuO1xufVxuXG4vKipcbiAqIFNjYW5uZXIgdG9rZW4gZ3JvdXBzXG4gKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+XG4gKi9cblN0YXRlLmdyb3VwcyA9IHt9O1xuU3RhdGUucHJvdG90eXBlID0ge1xuICBhY2NlcHRzKCkge1xuICAgIHJldHVybiAhIXRoaXMudDtcbiAgfSxcbiAgLyoqXG4gICAqIEZvbGxvdyBhbiBleGlzdGluZyB0cmFuc2l0aW9uIGZyb20gdGhlIGdpdmVuIGlucHV0IHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKiBEb2VzIG5vdCBtdXRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIgb3IgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEByZXR1cm5zIHs/U3RhdGU8VD59IHRoZSBuZXh0IHN0YXRlLCBpZiBhbnlcbiAgICovXG4gIGdvKGlucHV0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpbaW5wdXRdO1xuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuanIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gc3RhdGUuanJbaV1bMF07XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5qcltpXVsxXTsgLy8gbm90ZTogbWlnaHQgYmUgZW1wdHkgdG8gcHJldmVudCBkZWZhdWx0IGp1bXBcbiAgICAgIGlmIChuZXh0U3RhdGUgJiYgcmVnZXgudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93aGVyZSBsZWZ0IHRvIGp1bXAhIFJldHVybiBkZWZhdWx0LCBpZiBhbnlcbiAgICByZXR1cm4gc3RhdGUuamQ7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYSB0cmFuc2l0aW9uIGZvciB0aGUgZ2l2ZW4gaW5wdXQuIFNldCB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIHRydWUgdG8gb25seSBsb29rIGZvciBhbiBleGFjdCBtYXRjaCAoYW5kIG5vdCBhIGRlZmF1bHQgb3JcbiAgICogcmVndWxhci1leHByZXNzaW9uLWJhc2VkIHRyYW5zaXRpb24pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4YWN0T25seVxuICAgKi9cbiAgaGFzKGlucHV0LCBleGFjdE9ubHkpIHtcbiAgICBpZiAoZXhhY3RPbmx5ID09PSB2b2lkIDApIHtcbiAgICAgIGV4YWN0T25seSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXhhY3RPbmx5ID8gaW5wdXQgaW4gdGhpcy5qIDogISF0aGlzLmdvKGlucHV0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRyYW5zaXRpb24gYWxsXCI7IGNyZWF0ZSBhIHRyYW5zaXRpb24gZnJvbSB0aGUgYXJyYXkgb2YgaXRlbXNcbiAgICogaW4gdGhlIGdpdmVuIGxpc3QgdG8gdGhlIHNhbWUgZmluYWwgcmVzdWx0aW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dHMgR3JvdXAgb2YgaW5wdXRzIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uPFQ+IHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgdG9rZW4gZ3JvdXBzXG4gICAqL1xuICB0YShpbnB1dHMsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy50dChpbnB1dHNbaV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgcmVnZXhwIHRyYW5zaXRpb25cIjsgZGVmaW5lcyBhIHRyYW5zaXRpb24gZm9yIHRoaXMgc3RhdGVcbiAgICogd2hlbiBpdCBlbmNvdW50ZXJzIGEgdG9rZW4gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgUmVndWxhciBleHByZXNzaW9uIHRyYW5zaXRpb24gKHBvcHVsYXRlIGZpcnN0KVxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBpZiAobmV4dCAmJiBuZXh0LmopIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRva2VuIHdpdGggbWF5YmUgdG9rZW4gZ3JvdXBzXG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUobmV4dCk7XG4gICAgICBpZiAoZmxhZ3MgJiYgZ3JvdXBzKSB7XG4gICAgICAgIGFkZFRvR3JvdXBzKG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmpyLnB1c2goW3JlZ2V4cCwgbmV4dFN0YXRlXSk7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgdHJhbnNpdGlvbnNcIiwgd2lsbCB0YWtlIGFzIG1hbnkgc2VxdWVudGlhbCB0cmFuc2l0aW9ucyBhc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBpbnB1dCBhbmQgcmV0dXJucyB0aGVcbiAgICogcmVzdWx0aW5nIGZpbmFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHN0YXRlID0gc3RhdGUudHQoaW5wdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUudHQoaW5wdXRbbGVuIC0gMV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uXCIsIHRoaXMgaXMgYSBtZXRob2QgZm9yIGJ1aWxkaW5nL3dvcmtpbmcgd2l0aFxuICAgKiBzdGF0ZSBtYWNoaW5lcy5cbiAgICpcbiAgICogSWYgYSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIGdpdmVuIGlucHV0LCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBJZiBhIHRva2VuIGlzIHNwZWNpZmllZCwgdGhhdCBzdGF0ZSB3aWxsIGVtaXQgdGhhdCB0b2tlbiB3aGVuIHJlYWNoZWQgYnlcbiAgICogdGhlIGxpbmtpZnkgZW5naW5lLlxuICAgKlxuICAgKiBJZiBubyBzdGF0ZSBleGlzdHMsIGl0IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBzb21lIGRlZmF1bHQgdHJhbnNpdGlvbnNcbiAgICogdGhhdCByZXNlbWJsZSBleGlzdGluZyBkZWZhdWx0IHRyYW5zaXRpb25zLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGlzIGdpdmVuIGZvciB0aGUgc2Vjb25kIGFyZ3VtZW50LCB0aGF0IHN0YXRlIHdpbGwgYmVcbiAgICogdHJhbnNpdGlvbmVkIHRvIG9uIHRoZSBnaXZlbiBpbnB1dCByZWdhcmRsZXNzIG9mIHdoYXQgdGhhdCBpbnB1dFxuICAgKiBwcmV2aW91c2x5IGRpZC5cbiAgICpcbiAgICogU3BlY2lmeSBhIHRva2VuIGdyb3VwIGZsYWdzIHRvIGRlZmluZSBncm91cHMgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8uXG4gICAqIFRoZSB0b2tlbiB3aWxsIGJlIGFkZGVkIHRvIGNvcnJlc3BvbmRpbmcgZW50aXJlcyBpbiB0aGUgZ2l2ZW4gZ3JvdXBzXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IGNoYXJhY3RlciwgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBncm91cHMgPSBncm91cHMgfHwgU3RhdGUuZ3JvdXBzO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIGV4aXN0aW5nIHN0YXRlIGdpdmVuLCBqdXN0IGEgYmFzaWMgdHJhbnNpdGlvblxuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgc3RhdGUualtpbnB1dF0gPSBuZXh0O1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGNvbnN0IHQgPSBuZXh0O1xuXG4gICAgLy8gVGFrZSB0aGUgdHJhbnNpdGlvbiB3aXRoIHRoZSB1c3VhbCBkZWZhdWx0IG1lY2hhbmlzbXMgYW5kIHVzZSB0aGF0IGFzXG4gICAgLy8gYSB0ZW1wbGF0ZSBmb3IgY3JlYXRpbmcgdGhlIG5leHQgc3RhdGVcbiAgICBsZXQgbmV4dFN0YXRlLFxuICAgICAgdGVtcGxhdGVTdGF0ZSA9IHN0YXRlLmdvKGlucHV0KTtcbiAgICBpZiAodGVtcGxhdGVTdGF0ZSkge1xuICAgICAgbmV4dFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLmosIHRlbXBsYXRlU3RhdGUuaik7XG4gICAgICBuZXh0U3RhdGUuanIucHVzaC5hcHBseShuZXh0U3RhdGUuanIsIHRlbXBsYXRlU3RhdGUuanIpO1xuICAgICAgbmV4dFN0YXRlLmpkID0gdGVtcGxhdGVTdGF0ZS5qZDtcbiAgICAgIG5leHRTdGF0ZS50ID0gdGVtcGxhdGVTdGF0ZS50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHQpIHtcbiAgICAgIC8vIEVuc3VyZSBuZXdseSB0b2tlbiBpcyBpbiB0aGUgc2FtZSBncm91cHMgYXMgdGhlIG9sZCB0b2tlblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBpZiAobmV4dFN0YXRlLnQgJiYgdHlwZW9mIG5leHRTdGF0ZS50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGFsbEZsYWdzID0gYXNzaWduKGZsYWdzRm9yVG9rZW4obmV4dFN0YXRlLnQsIGdyb3VwcyksIGZsYWdzKTtcbiAgICAgICAgICBhZGRUb0dyb3Vwcyh0LCBhbGxGbGFncywgZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncykge1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGUudCA9IHQ7IC8vIG92ZXJ3cml0ZSBhbnl0aGluZyB0aGF0IHdhcyBwcmV2aW91c2x5IHRoZXJlXG4gICAgfVxuXG4gICAgc3RhdGUualtpbnB1dF0gPSBuZXh0U3RhdGU7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyB0byBpbXByb3ZlIG1pbmlmaWNhdGlvbiAobm90IGV4cG9ydGVkIG91dHNpZGUgbGlua2lmeWpzIG1vZHVsZSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0YSA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRhKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRyID0gKHN0YXRlLCByZWdleHAsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHMgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50cyhpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKi9cbmNvbnN0IHR0ID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5UZXh0IFRva2Vuc1xuSWRlbnRpZmllcnMgZm9yIHRva2VuIG91dHB1dHMgZnJvbSB0aGUgcmVnZXhwIHNjYW5uZXJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSB2YWxpZCB3ZWIgZG9tYWluIHRva2VuXG5jb25zdCBXT1JEID0gJ1dPUkQnOyAvLyBvbmx5IGNvbnRhaW5zIGEtelxuY29uc3QgVVdPUkQgPSAnVVdPUkQnOyAvLyBjb250YWlucyBsZXR0ZXJzIG90aGVyIHRoYW4gYS16LCB1c2VkIGZvciBJRE5cblxuLy8gU3BlY2lhbCBjYXNlIG9mIHdvcmRcbmNvbnN0IExPQ0FMSE9TVCA9ICdMT0NBTEhPU1QnO1xuXG4vLyBWYWxpZCB0b3AtbGV2ZWwgZG9tYWluLCBzcGVjaWFsIGNhc2Ugb2YgV09SRCAoc2VlIHRsZHMuanMpXG5jb25zdCBUTEQgPSAnVExEJztcblxuLy8gVmFsaWQgSUROIFRMRCwgc3BlY2lhbCBjYXNlIG9mIFVXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFVUTEQgPSAnVVRMRCc7XG5cbi8vIFRoZSBzY2hlbWUgcG9ydGlvbiBvZiBhIHdlYiBVUkkgcHJvdG9jb2wuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlOiBgbWFpbHRvYCxcbi8vIGBmaWxlYCwgYW5kIHVzZXItZGVmaW5lZCBjdXN0b20gcHJvdG9jb2xzLiBMaW1pdGVkIHRvIHNjaGVtZXMgdGhhdCBjb250YWluXG4vLyBvbmx5IGxldHRlcnNcbmNvbnN0IFNDSEVNRSA9ICdTQ0hFTUUnO1xuXG4vLyBTaW1pbGFyIHRvIFNDSEVNRSwgZXhjZXB0IG1ha2VzIGRpc3RpbmN0aW9uIGZvciBzY2hlbWVzIHRoYXQgbXVzdCBhbHdheXMgYmVcbi8vIGZvbGxvd2VkIGJ5IGA6Ly9gLCBub3QganVzdCBgOmAuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlIGBodHRwYCwgYGh0dHBzYCxcbi8vIGBmdHBgLCBgZnRwc2BcbmNvbnN0IFNMQVNIX1NDSEVNRSA9ICdTTEFTSF9TQ0hFTUUnO1xuXG4vLyBBbnkgc2VxdWVuY2Ugb2YgZGlnaXRzIDAtOVxuY29uc3QgTlVNID0gJ05VTSc7XG5cbi8vIEFueSBudW1iZXIgb2YgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBuZXdsaW5lXG5jb25zdCBXUyA9ICdXUyc7XG5cbi8vIE5ldyBsaW5lICh1bml4IHN0eWxlKVxuY29uc3QgTkwkMSA9ICdOTCc7IC8vIFxcblxuXG4vLyBPcGVuaW5nL2Nsb3NpbmcgYnJhY2tldCBjbGFzc2VzXG4vLyBUT0RPOiBSZW5hbWUgT1BFTiAtPiBMRUZUIGFuZCBDTE9TRSAtPiBSSUdIVCBpbiB2NSB0byBmaXQgd2l0aCBVbmljb2RlIG5hbWVzXG4vLyBBbHNvIHJlbmFtZSBhbmdsZSBicmFja2VzIHRvIExFU1NUSEFOIGFuZCBHUkVBVEVSIFRIQU5cbmNvbnN0IE9QRU5CUkFDRSA9ICdPUEVOQlJBQ0UnOyAvLyB7XG5jb25zdCBDTE9TRUJSQUNFID0gJ0NMT1NFQlJBQ0UnOyAvLyB9XG5jb25zdCBPUEVOQlJBQ0tFVCA9ICdPUEVOQlJBQ0tFVCc7IC8vIFtcbmNvbnN0IENMT1NFQlJBQ0tFVCA9ICdDTE9TRUJSQUNLRVQnOyAvLyBdXG5jb25zdCBPUEVOUEFSRU4gPSAnT1BFTlBBUkVOJzsgLy8gKFxuY29uc3QgQ0xPU0VQQVJFTiA9ICdDTE9TRVBBUkVOJzsgLy8gKVxuY29uc3QgT1BFTkFOR0xFQlJBQ0tFVCA9ICdPUEVOQU5HTEVCUkFDS0VUJzsgLy8gPFxuY29uc3QgQ0xPU0VBTkdMRUJSQUNLRVQgPSAnQ0xPU0VBTkdMRUJSQUNLRVQnOyAvLyA+XG5jb25zdCBGVUxMV0lEVEhMRUZUUEFSRU4gPSAnRlVMTFdJRFRITEVGVFBBUkVOJzsgLy8g77yIXG5jb25zdCBGVUxMV0lEVEhSSUdIVFBBUkVOID0gJ0ZVTExXSURUSFJJR0hUUEFSRU4nOyAvLyDvvIlcbmNvbnN0IExFRlRDT1JORVJCUkFDS0VUID0gJ0xFRlRDT1JORVJCUkFDS0VUJzsgLy8g44CMXG5jb25zdCBSSUdIVENPUk5FUkJSQUNLRVQgPSAnUklHSFRDT1JORVJCUkFDS0VUJzsgLy8g44CNXG5jb25zdCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUID0gJ0xFRlRXSElURUNPUk5FUkJSQUNLRVQnOyAvLyDjgI5cbmNvbnN0IFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUID0gJ1JJR0hUV0hJVEVDT1JORVJCUkFDS0VUJzsgLy8g44CPXG5jb25zdCBGVUxMV0lEVEhMRVNTVEhBTiA9ICdGVUxMV0lEVEhMRVNTVEhBTic7IC8vIO+8nFxuY29uc3QgRlVMTFdJRFRIR1JFQVRFUlRIQU4gPSAnRlVMTFdJRFRIR1JFQVRFUlRIQU4nOyAvLyDvvJ5cblxuLy8gVmFyaW91cyBzeW1ib2xzXG5jb25zdCBBTVBFUlNBTkQgPSAnQU1QRVJTQU5EJzsgLy8gJlxuY29uc3QgQVBPU1RST1BIRSA9ICdBUE9TVFJPUEhFJzsgLy8gJ1xuY29uc3QgQVNURVJJU0sgPSAnQVNURVJJU0snOyAvLyAqXG5jb25zdCBBVCA9ICdBVCc7IC8vIEBcbmNvbnN0IEJBQ0tTTEFTSCA9ICdCQUNLU0xBU0gnOyAvLyBcXFxuY29uc3QgQkFDS1RJQ0sgPSAnQkFDS1RJQ0snOyAvLyBgXG5jb25zdCBDQVJFVCA9ICdDQVJFVCc7IC8vIF5cbmNvbnN0IENPTE9OID0gJ0NPTE9OJzsgLy8gOlxuY29uc3QgQ09NTUEgPSAnQ09NTUEnOyAvLyAsXG5jb25zdCBET0xMQVIgPSAnRE9MTEFSJzsgLy8gJFxuY29uc3QgRE9UID0gJ0RPVCc7IC8vIC5cbmNvbnN0IEVRVUFMUyA9ICdFUVVBTFMnOyAvLyA9XG5jb25zdCBFWENMQU1BVElPTiA9ICdFWENMQU1BVElPTic7IC8vICFcbmNvbnN0IEhZUEhFTiA9ICdIWVBIRU4nOyAvLyAtXG5jb25zdCBQRVJDRU5UID0gJ1BFUkNFTlQnOyAvLyAlXG5jb25zdCBQSVBFID0gJ1BJUEUnOyAvLyB8XG5jb25zdCBQTFVTID0gJ1BMVVMnOyAvLyArXG5jb25zdCBQT1VORCA9ICdQT1VORCc7IC8vICNcbmNvbnN0IFFVRVJZID0gJ1FVRVJZJzsgLy8gP1xuY29uc3QgUVVPVEUgPSAnUVVPVEUnOyAvLyBcIlxuXG5jb25zdCBTRU1JID0gJ1NFTUknOyAvLyA7XG5jb25zdCBTTEFTSCA9ICdTTEFTSCc7IC8vIC9cbmNvbnN0IFRJTERFID0gJ1RJTERFJzsgLy8gflxuY29uc3QgVU5ERVJTQ09SRSA9ICdVTkRFUlNDT1JFJzsgLy8gX1xuXG4vLyBFbW9qaSBzeW1ib2xcbmNvbnN0IEVNT0pJJDEgPSAnRU1PSkknO1xuXG4vLyBEZWZhdWx0IHRva2VuIC0gYW55dGhpbmcgdGhhdCBpcyBub3Qgb25lIG9mIHRoZSBhYm92ZVxuY29uc3QgU1lNID0gJ1NZTSc7XG5cbnZhciB0ayA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRXT1JEOiBXT1JELFxuXHRVV09SRDogVVdPUkQsXG5cdExPQ0FMSE9TVDogTE9DQUxIT1NULFxuXHRUTEQ6IFRMRCxcblx0VVRMRDogVVRMRCxcblx0U0NIRU1FOiBTQ0hFTUUsXG5cdFNMQVNIX1NDSEVNRTogU0xBU0hfU0NIRU1FLFxuXHROVU06IE5VTSxcblx0V1M6IFdTLFxuXHROTDogTkwkMSxcblx0T1BFTkJSQUNFOiBPUEVOQlJBQ0UsXG5cdENMT1NFQlJBQ0U6IENMT1NFQlJBQ0UsXG5cdE9QRU5CUkFDS0VUOiBPUEVOQlJBQ0tFVCxcblx0Q0xPU0VCUkFDS0VUOiBDTE9TRUJSQUNLRVQsXG5cdE9QRU5QQVJFTjogT1BFTlBBUkVOLFxuXHRDTE9TRVBBUkVOOiBDTE9TRVBBUkVOLFxuXHRPUEVOQU5HTEVCUkFDS0VUOiBPUEVOQU5HTEVCUkFDS0VULFxuXHRDTE9TRUFOR0xFQlJBQ0tFVDogQ0xPU0VBTkdMRUJSQUNLRVQsXG5cdEZVTExXSURUSExFRlRQQVJFTjogRlVMTFdJRFRITEVGVFBBUkVOLFxuXHRGVUxMV0lEVEhSSUdIVFBBUkVOOiBGVUxMV0lEVEhSSUdIVFBBUkVOLFxuXHRMRUZUQ09STkVSQlJBQ0tFVDogTEVGVENPUk5FUkJSQUNLRVQsXG5cdFJJR0hUQ09STkVSQlJBQ0tFVDogUklHSFRDT1JORVJCUkFDS0VULFxuXHRMRUZUV0hJVEVDT1JORVJCUkFDS0VUOiBMRUZUV0hJVEVDT1JORVJCUkFDS0VULFxuXHRSSUdIVFdISVRFQ09STkVSQlJBQ0tFVDogUklHSFRXSElURUNPUk5FUkJSQUNLRVQsXG5cdEZVTExXSURUSExFU1NUSEFOOiBGVUxMV0lEVEhMRVNTVEhBTixcblx0RlVMTFdJRFRIR1JFQVRFUlRIQU46IEZVTExXSURUSEdSRUFURVJUSEFOLFxuXHRBTVBFUlNBTkQ6IEFNUEVSU0FORCxcblx0QVBPU1RST1BIRTogQVBPU1RST1BIRSxcblx0QVNURVJJU0s6IEFTVEVSSVNLLFxuXHRBVDogQVQsXG5cdEJBQ0tTTEFTSDogQkFDS1NMQVNILFxuXHRCQUNLVElDSzogQkFDS1RJQ0ssXG5cdENBUkVUOiBDQVJFVCxcblx0Q09MT046IENPTE9OLFxuXHRDT01NQTogQ09NTUEsXG5cdERPTExBUjogRE9MTEFSLFxuXHRET1Q6IERPVCxcblx0RVFVQUxTOiBFUVVBTFMsXG5cdEVYQ0xBTUFUSU9OOiBFWENMQU1BVElPTixcblx0SFlQSEVOOiBIWVBIRU4sXG5cdFBFUkNFTlQ6IFBFUkNFTlQsXG5cdFBJUEU6IFBJUEUsXG5cdFBMVVM6IFBMVVMsXG5cdFBPVU5EOiBQT1VORCxcblx0UVVFUlk6IFFVRVJZLFxuXHRRVU9URTogUVVPVEUsXG5cdFNFTUk6IFNFTUksXG5cdFNMQVNIOiBTTEFTSCxcblx0VElMREU6IFRJTERFLFxuXHRVTkRFUlNDT1JFOiBVTkRFUlNDT1JFLFxuXHRFTU9KSTogRU1PSkkkMSxcblx0U1lNOiBTWU1cbn0pO1xuXG4vLyBOb3RlIHRoYXQgdGhlc2UgdHdvIFVuaWNvZGUgb25lcyBleHBhbmQgaW50byBhIHJlYWxseSBiaWcgb25lIHdpdGggQmFiZWxcbmNvbnN0IEFTQ0lJX0xFVFRFUiA9IC9bYS16XS87XG5jb25zdCBMRVRURVIgPSAvXFxwe0x9L3U7IC8vIEFueSBVbmljb2RlIGNoYXJhY3RlciB3aXRoIGxldHRlciBkYXRhIHR5cGVcbmNvbnN0IEVNT0pJID0gL1xccHtFbW9qaX0vdTsgLy8gQW55IFVuaWNvZGUgZW1vamkgY2hhcmFjdGVyXG5jb25zdCBFTU9KSV9WQVJJQVRJT04kMSA9IC9cXHVmZTBmLztcbmNvbnN0IERJR0lUID0gL1xcZC87XG5jb25zdCBTUEFDRSA9IC9cXHMvO1xuXG52YXIgcmVnZXhwID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEFTQ0lJX0xFVFRFUjogQVNDSUlfTEVUVEVSLFxuXHRMRVRURVI6IExFVFRFUixcblx0RU1PSkk6IEVNT0pJLFxuXHRFTU9KSV9WQVJJQVRJT046IEVNT0pJX1ZBUklBVElPTiQxLFxuXHRESUdJVDogRElHSVQsXG5cdFNQQUNFOiBTUEFDRVxufSk7XG5cbi8qKlxuXHRUaGUgc2Nhbm5lciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCB0YWtlcyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0LCBhbmRcblx0b3V0cHV0cyBhbiBhcnJheSBvZiB0b2tlbnMgaW5zdGFuY2VzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGVhc3kgVVJMIHBhcnNpbmcuXG4qL1xuY29uc3QgTkwgPSAnXFxuJzsgLy8gTmV3IGxpbmUgY2hhcmFjdGVyXG5jb25zdCBFTU9KSV9WQVJJQVRJT04gPSAnXFx1ZmUwZic7IC8vIFZhcmlhdGlvbiBzZWxlY3RvciwgZm9sbG93cyBoZWFydCBhbmQgb3RoZXJzXG5jb25zdCBFTU9KSV9KT0lORVIgPSAnXFx1MjAwZCc7IC8vIHplcm8td2lkdGggam9pbmVyXG5cbmxldCB0bGRzID0gbnVsbCxcbiAgdXRsZHMgPSBudWxsOyAvLyBkb24ndCBjaGFuZ2Ugc28gb25seSBoYXZlIHRvIGJlIGNvbXB1dGVkIG9uY2VcblxuLyoqXG4gKiBTY2FubmVyIG91dHB1dCB0b2tlbjpcbiAqIC0gYHRgIGlzIHRoZSB0b2tlbiBuYW1lIChlLmcuLCAnTlVNJywgJ0VNT0pJJywgJ1RMRCcpXG4gKiAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIHRva2VuIChlLmcuLCAnMTIzJywgJ+KdpO+4jycsICdjb20nKVxuICogLSBgc2AgaXMgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiAtIGBlYCBpcyB0aGUgZW5kIGluZGV4IG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBAdHlwZWRlZiB7e3Q6IHN0cmluZywgdjogc3RyaW5nLCBzOiBudW1iZXIsIGU6IG51bWJlcn19IFRva2VuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2NvbGxlY3Rpb246IHN0cmluZ106IFRbXSB9fSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgc2Nhbm5lciBjaGFyYWN0ZXItYmFzZWQgc3RhdGUgbWFjaGluZSBmb3IgdGhlIGdpdmVuIHN0YXJ0XG4gKiBzdGF0ZVxuICogQHBhcmFtIHtbc3RyaW5nLCBib29sZWFuXVtdfSBjdXN0b21TY2hlbWVzIExpc3Qgb2YgY3VzdG9tIHNjaGVtZXMsIHdoZXJlIGVhY2hcbiAqIGl0ZW0gaXMgYSBsZW5ndGgtMiB0dXBsZSB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IHNldCB0byB0aGUgc3RyaW5nIHNjaGVtZSwgYW5kXG4gKiB0aGUgc2Vjb25kIGVsZW1lbnQgc2V0IHRvIGB0cnVlYCBpZiB0aGUgYDovL2AgYWZ0ZXIgdGhlIHNjaGVtZSBpcyBvcHRpb25hbFxuICovXG5mdW5jdGlvbiBpbml0JDIoY3VzdG9tU2NoZW1lcykge1xuICBpZiAoY3VzdG9tU2NoZW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgY3VzdG9tU2NoZW1lcyA9IFtdO1xuICB9XG4gIC8vIEZyZXF1ZW50bHkgdXNlZCBzdGF0ZXMgKG5hbWUgYXJndW1lbnQgcmVtb3ZlZCBkdXJpbmcgbWluaWZpY2F0aW9uKVxuICAvKiogQHR5cGUgQ29sbGVjdGlvbnM8c3RyaW5nPiAqL1xuICBjb25zdCBncm91cHMgPSB7fTsgLy8gb2YgdG9rZW5zXG4gIFN0YXRlLmdyb3VwcyA9IGdyb3VwcztcbiAgLyoqIEB0eXBlIFN0YXRlPHN0cmluZz4gKi9cbiAgY29uc3QgU3RhcnQgPSBuZXcgU3RhdGUoKTtcbiAgaWYgKHRsZHMgPT0gbnVsbCkge1xuICAgIHRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRUbGRzKTtcbiAgfVxuICBpZiAodXRsZHMgPT0gbnVsbCkge1xuICAgIHV0bGRzID0gZGVjb2RlVGxkcyhlbmNvZGVkVXRsZHMpO1xuICB9XG5cbiAgLy8gU3RhdGVzIGZvciBzcGVjaWFsIFVSTCBzeW1ib2xzIHRoYXQgYWNjZXB0IGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gIHR0KFN0YXJ0LCBcIidcIiwgQVBPU1RST1BIRSk7XG4gIHR0KFN0YXJ0LCAneycsIE9QRU5CUkFDRSk7XG4gIHR0KFN0YXJ0LCAnfScsIENMT1NFQlJBQ0UpO1xuICB0dChTdGFydCwgJ1snLCBPUEVOQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXScsIENMT1NFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnKCcsIE9QRU5QQVJFTik7XG4gIHR0KFN0YXJ0LCAnKScsIENMT1NFUEFSRU4pO1xuICB0dChTdGFydCwgJzwnLCBPUEVOQU5HTEVCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICc+JywgQ0xPU0VBTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJ++8iCcsIEZVTExXSURUSExFRlRQQVJFTik7XG4gIHR0KFN0YXJ0LCAn77yJJywgRlVMTFdJRFRIUklHSFRQQVJFTik7XG4gIHR0KFN0YXJ0LCAn44CMJywgTEVGVENPUk5FUkJSQUNLRVQpO1xuICB0dChTdGFydCwgJ+OAjScsIFJJR0hUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn44COJywgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAn44CPJywgUklHSFRXSElURUNPUk5FUkJSQUNLRVQpO1xuICB0dChTdGFydCwgJ++8nCcsIEZVTExXSURUSExFU1NUSEFOKTtcbiAgdHQoU3RhcnQsICfvvJ4nLCBGVUxMV0lEVEhHUkVBVEVSVEhBTik7XG4gIHR0KFN0YXJ0LCAnJicsIEFNUEVSU0FORCk7XG4gIHR0KFN0YXJ0LCAnKicsIEFTVEVSSVNLKTtcbiAgdHQoU3RhcnQsICdAJywgQVQpO1xuICB0dChTdGFydCwgJ2AnLCBCQUNLVElDSyk7XG4gIHR0KFN0YXJ0LCAnXicsIENBUkVUKTtcbiAgdHQoU3RhcnQsICc6JywgQ09MT04pO1xuICB0dChTdGFydCwgJywnLCBDT01NQSk7XG4gIHR0KFN0YXJ0LCAnJCcsIERPTExBUik7XG4gIHR0KFN0YXJ0LCAnLicsIERPVCk7XG4gIHR0KFN0YXJ0LCAnPScsIEVRVUFMUyk7XG4gIHR0KFN0YXJ0LCAnIScsIEVYQ0xBTUFUSU9OKTtcbiAgdHQoU3RhcnQsICctJywgSFlQSEVOKTtcbiAgdHQoU3RhcnQsICclJywgUEVSQ0VOVCk7XG4gIHR0KFN0YXJ0LCAnfCcsIFBJUEUpO1xuICB0dChTdGFydCwgJysnLCBQTFVTKTtcbiAgdHQoU3RhcnQsICcjJywgUE9VTkQpO1xuICB0dChTdGFydCwgJz8nLCBRVUVSWSk7XG4gIHR0KFN0YXJ0LCAnXCInLCBRVU9URSk7XG4gIHR0KFN0YXJ0LCAnLycsIFNMQVNIKTtcbiAgdHQoU3RhcnQsICc7JywgU0VNSSk7XG4gIHR0KFN0YXJ0LCAnficsIFRJTERFKTtcbiAgdHQoU3RhcnQsICdfJywgVU5ERVJTQ09SRSk7XG4gIHR0KFN0YXJ0LCAnXFxcXCcsIEJBQ0tTTEFTSCk7XG4gIGNvbnN0IE51bSA9IHRyKFN0YXJ0LCBESUdJVCwgTlVNLCB7XG4gICAgW251bWVyaWNdOiB0cnVlXG4gIH0pO1xuICB0cihOdW0sIERJR0lULCBOdW0pO1xuXG4gIC8vIFN0YXRlIHdoaWNoIGVtaXRzIGEgd29yZCB0b2tlblxuICBjb25zdCBXb3JkID0gdHIoU3RhcnQsIEFTQ0lJX0xFVFRFUiwgV09SRCwge1xuICAgIFthc2NpaV06IHRydWVcbiAgfSk7XG4gIHRyKFdvcmQsIEFTQ0lJX0xFVFRFUiwgV29yZCk7XG5cbiAgLy8gU2FtZSBhcyBwcmV2aW91cywgYnV0IHNwZWNpZmljIHRvIG5vbi1mc20uYXNjaWkgYWxwaGFiZXQgd29yZHNcbiAgY29uc3QgVVdvcmQgPSB0cihTdGFydCwgTEVUVEVSLCBVV09SRCwge1xuICAgIFthbHBoYV06IHRydWVcbiAgfSk7XG4gIHRyKFVXb3JkLCBBU0NJSV9MRVRURVIpOyAvLyBOb24tYWNjZXB0aW5nXG4gIHRyKFVXb3JkLCBMRVRURVIsIFVXb3JkKTtcblxuICAvLyBXaGl0ZXNwYWNlIGp1bXBzXG4gIC8vIFRva2VucyBvZiBvbmx5IG5vbi1uZXdsaW5lIHdoaXRlc3BhY2UgYXJlIGFyYml0cmFyaWx5IGxvbmdcbiAgLy8gSWYgYW55IHdoaXRlc3BhY2UgZXhjZXB0IG5ld2xpbmUsIG1vcmUgd2hpdGVzcGFjZSFcbiAgY29uc3QgV3MgPSB0cihTdGFydCwgU1BBQ0UsIFdTLCB7XG4gICAgW3doaXRlc3BhY2VdOiB0cnVlXG4gIH0pO1xuICB0dChTdGFydCwgTkwsIE5MJDEsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIHR0KFdzLCBOTCk7IC8vIG5vbi1hY2NlcHRpbmcgc3RhdGUgdG8gYXZvaWQgbWl4aW5nIHdoaXRlc3BhY2VzXG4gIHRyKFdzLCBTUEFDRSwgV3MpO1xuXG4gIC8vIEVtb2ppIHRva2Vucy4gVGhleSBhcmUgbm90IGdyb3VwZWQgYnkgdGhlIHNjYW5uZXIgZXhjZXB0IGluIGNhc2VzIHdoZXJlIGFcbiAgLy8gemVyby13aWR0aCBqb2luZXIgaXMgcHJlc2VudFxuICBjb25zdCBFbW9qaSA9IHRyKFN0YXJ0LCBFTU9KSSwgRU1PSkkkMSwge1xuICAgIFtlbW9qaV06IHRydWVcbiAgfSk7XG4gIHRyKEVtb2ppLCBFTU9KSSwgRW1vamkpO1xuICB0dChFbW9qaSwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7XG4gIC8vIHR0KFN0YXJ0LCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gVGhpcyBvbmUgaXMgc2tldGNoeVxuXG4gIGNvbnN0IEVtb2ppSm9pbmVyID0gdHQoRW1vamksIEVNT0pJX0pPSU5FUik7XG4gIHRyKEVtb2ppSm9pbmVyLCBFTU9KSSwgRW1vamkpO1xuICAvLyB0dChFbW9qaUpvaW5lciwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7IC8vIGFsc28gc2tldGNoeVxuXG4gIC8vIEdlbmVyYXRlcyBzdGF0ZXMgZm9yIHRvcC1sZXZlbCBkb21haW5zXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG1vc3QgYWNjdXJhdGUgd2hlbiB0bGRzIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgY29uc3Qgd29yZGpyID0gW1tBU0NJSV9MRVRURVIsIFdvcmRdXTtcbiAgY29uc3QgdXdvcmRqciA9IFtbQVNDSUlfTEVUVEVSLCBudWxsXSwgW0xFVFRFUiwgVVdvcmRdXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB0bGRzW2ldLCBUTEQsIFdPUkQsIHdvcmRqcik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGxkcy5sZW5ndGg7IGkrKykge1xuICAgIGZhc3R0cyhTdGFydCwgdXRsZHNbaV0sIFVUTEQsIFVXT1JELCB1d29yZGpyKTtcbiAgfVxuICBhZGRUb0dyb3VwcyhUTEQsIHtcbiAgICB0bGQ6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcbiAgYWRkVG9Hcm91cHMoVVRMRCwge1xuICAgIHV0bGQ6IHRydWUsXG4gICAgYWxwaGE6IHRydWVcbiAgfSwgZ3JvdXBzKTtcblxuICAvLyBDb2xsZWN0IHRoZSBzdGF0ZXMgZ2VuZXJhdGVkIGJ5IGRpZmZlcmVudCBwcm90b2NvbHMuIE5PVEU6IElmIGFueSBuZXcgVExEc1xuICAvLyBnZXQgYWRkZWQgdGhhdCBhcmUgYWxzbyBwcm90b2NvbHMsIHNldCB0aGUgdG9rZW4gdG8gYmUgdGhlIHNhbWUgYXMgdGhlXG4gIC8vIHByb3RvY29sIHRvIGVuc3VyZSBwYXJzaW5nIHdvcmtzIGFzIGV4cGVjdGVkLlxuICBmYXN0dHMoU3RhcnQsICdmaWxlJywgU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdtYWlsdG8nLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHBzJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdmdHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGFkZFRvR3JvdXBzKFNDSEVNRSwge1xuICAgIHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhTTEFTSF9TQ0hFTUUsIHtcbiAgICBzbGFzaHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIFJlZ2lzdGVyIGN1c3RvbSBzY2hlbWVzLiBBc3N1bWVzIGVhY2ggc2NoZW1lIGlzIGFzY2lpbnVtZXJpYyB3aXRoIGh5cGhlbnNcbiAgY3VzdG9tU2NoZW1lcyA9IGN1c3RvbVNjaGVtZXMuc29ydCgoYSwgYikgPT4gYVswXSA+IGJbMF0gPyAxIDogLTEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1c3RvbVNjaGVtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY2ggPSBjdXN0b21TY2hlbWVzW2ldWzBdO1xuICAgIGNvbnN0IG9wdGlvbmFsU2xhc2hTbGFzaCA9IGN1c3RvbVNjaGVtZXNbaV1bMV07XG4gICAgY29uc3QgZmxhZ3MgPSBvcHRpb25hbFNsYXNoU2xhc2ggPyB7XG4gICAgICBbc2NoZW1lXTogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBbc2xhc2hzY2hlbWVdOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoc2NoLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFBU0NJSV9MRVRURVIudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1tudW1lcmljXSA9IHRydWU7IC8vIG51bWJlcnMgb25seVxuICAgIH0gZWxzZSBpZiAoRElHSVQudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZ3NbYXNjaWldID0gdHJ1ZTtcbiAgICB9XG4gICAgdHMoU3RhcnQsIHNjaCwgc2NoLCBmbGFncyk7XG4gIH1cblxuICAvLyBMb2NhbGhvc3QgdG9rZW5cbiAgdHMoU3RhcnQsICdsb2NhbGhvc3QnLCBMT0NBTEhPU1QsIHtcbiAgICBhc2NpaTogdHJ1ZVxuICB9KTtcblxuICAvLyBTZXQgZGVmYXVsdCB0cmFuc2l0aW9uIGZvciBzdGFydCBzdGF0ZSAoc29tZSBzeW1ib2wpXG4gIFN0YXJ0LmpkID0gbmV3IFN0YXRlKFNZTSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogYXNzaWduKHtcbiAgICAgIGdyb3Vwc1xuICAgIH0sIHRrKVxuICB9O1xufVxuXG4vKipcblx0R2l2ZW4gYSBzdHJpbmcsIHJldHVybnMgYW4gYXJyYXkgb2YgVE9LRU4gaW5zdGFuY2VzIHJlcHJlc2VudGluZyB0aGVcblx0Y29tcG9zaXRpb24gb2YgdGhhdCBzdHJpbmcuXG5cblx0QG1ldGhvZCBydW5cblx0QHBhcmFtIHtTdGF0ZTxzdHJpbmc+fSBzdGFydCBzY2FubmVyIHN0YXJ0aW5nIHN0YXRlXG5cdEBwYXJhbSB7c3RyaW5nfSBzdHIgaW5wdXQgc3RyaW5nIHRvIHNjYW5cblx0QHJldHVybiB7VG9rZW5bXX0gbGlzdCBvZiB0b2tlbnMsIGVhY2ggd2l0aCBhIHR5cGUgYW5kIHZhbHVlXG4qL1xuZnVuY3Rpb24gcnVuJDEoc3RhcnQsIHN0cikge1xuICAvLyBTdGF0ZSBtYWNoaW5lIGlzIG5vdCBjYXNlIHNlbnNpdGl2ZSwgc28gaW5wdXQgaXMgdG9rZW5pemVkIGluIGxvd2VyY2FzZWRcbiAgLy8gZm9ybSAoc3RpbGwgcmV0dXJucyByZWd1bGFyIGNhc2UpLiBVc2VzIHNlbGVjdGl2ZSBgdG9Mb3dlckNhc2VgIGJlY2F1c2VcbiAgLy8gbG93ZXJjYXNpbmcgdGhlIGVudGlyZSBzdHJpbmcgY2F1c2VzIHRoZSBsZW5ndGggYW5kIGNoYXJhY3RlciBwb3NpdGlvbiB0b1xuICAvLyB2YXJ5IGluIHNvbWUgbm9uLUVuZ2xpc2ggc3RyaW5ncyB3aXRoIFY4LWJhc2VkIHJ1bnRpbWVzLlxuICBjb25zdCBpdGVyYWJsZSA9IHN0cmluZ1RvQXJyYXkoc3RyLnJlcGxhY2UoL1tBLVpdL2csIGMgPT4gYy50b0xvd2VyQ2FzZSgpKSk7XG4gIGNvbnN0IGNoYXJDb3VudCA9IGl0ZXJhYmxlLmxlbmd0aDsgLy8gPD0gbGVuIGlmIHRoZXJlIGFyZSBlbW9qaXMsIGV0Y1xuICBjb25zdCB0b2tlbnMgPSBbXTsgLy8gcmV0dXJuIHZhbHVlXG5cbiAgLy8gY3Vyc29yIHRocm91Z2ggdGhlIHN0cmluZyBpdHNlbGYsIGFjY291bnRpbmcgZm9yIGNoYXJhY3RlcnMgdGhhdCBoYXZlXG4gIC8vIHdpZHRoIHdpdGggbGVuZ3RoIDIgc3VjaCBhcyBlbW9qaXNcbiAgbGV0IGN1cnNvciA9IDA7XG5cbiAgLy8gQ3Vyc29yIHRocm91Z2ggdGhlIGFycmF5LXJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmdcbiAgbGV0IGNoYXJDdXJzb3IgPSAwO1xuXG4gIC8vIFRva2VuaXplIHRoZSBzdHJpbmdcbiAgd2hpbGUgKGNoYXJDdXJzb3IgPCBjaGFyQ291bnQpIHtcbiAgICBsZXQgc3RhdGUgPSBzdGFydDtcbiAgICBsZXQgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBsZXQgdG9rZW5MZW5ndGggPSAwO1xuICAgIGxldCBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIGxldCBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICBsZXQgY2hhcnNTaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB3aGlsZSAoY2hhckN1cnNvciA8IGNoYXJDb3VudCAmJiAobmV4dFN0YXRlID0gc3RhdGUuZ28oaXRlcmFibGVbY2hhckN1cnNvcl0pKSkge1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHRzKCkpIHtcbiAgICAgICAgc2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgY2hhcnNTaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBsYXRlc3RBY2NlcHRpbmcgPSBzdGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2luY2VBY2NlcHRzID49IDApIHtcbiAgICAgICAgc2luY2VBY2NlcHRzICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgICAgY2hhcnNTaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIHRva2VuTGVuZ3RoICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGN1cnNvciArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICBjaGFyQ3Vyc29yKys7XG4gICAgfVxuXG4gICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgY3Vyc29yIC09IHNpbmNlQWNjZXB0cztcbiAgICBjaGFyQ3Vyc29yIC09IGNoYXJzU2luY2VBY2NlcHRzO1xuICAgIHRva2VuTGVuZ3RoIC09IHNpbmNlQWNjZXB0cztcblxuICAgIC8vIE5vIG1vcmUganVtcHMsIGp1c3QgbWFrZSBhIG5ldyB0b2tlbiBmcm9tIHRoZSBsYXN0IGFjY2VwdGluZyBvbmVcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0OiBsYXRlc3RBY2NlcHRpbmcudCxcbiAgICAgIC8vIHRva2VuIHR5cGUvbmFtZVxuICAgICAgdjogc3RyLnNsaWNlKGN1cnNvciAtIHRva2VuTGVuZ3RoLCBjdXJzb3IpLFxuICAgICAgLy8gc3RyaW5nIHZhbHVlXG4gICAgICBzOiBjdXJzb3IgLSB0b2tlbkxlbmd0aCxcbiAgICAgIC8vIHN0YXJ0IGluZGV4XG4gICAgICBlOiBjdXJzb3IgLy8gZW5kIGluZGV4IChleGNsdWRpbmcpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBTdHJpbmcgdG8gYW4gQXJyYXkgb2YgY2hhcmFjdGVycywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0IHNvbWVcbiAqIGNoYXJhY3RlcnMgbGlrZSBlbW9qaXMgdGFrZSB1cCB0d28gc3RyaW5nIGluZGV4ZXMuXG4gKlxuICogQWRhcHRlZCBmcm9tIGNvcmUtanMgKE1JVCBsaWNlbnNlKVxuICogaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi8yZDY5Y2Y1Zjk5YWIzZWEzNDYzYzM5NWRmODFlNWExNWI2OGY0OWQ5L3BhY2thZ2VzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanNcbiAqXG4gKiBAZnVuY3Rpb24gc3RyaW5nVG9BcnJheVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB7XG4gICAgbGV0IGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGxldCBzZWNvbmQ7XG4gICAgbGV0IGNoYXIgPSBmaXJzdCA8IDB4ZDgwMCB8fCBmaXJzdCA+IDB4ZGJmZiB8fCBpbmRleCArIDEgPT09IGxlbiB8fCAoc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkgPCAweGRjMDAgfHwgc2Vjb25kID4gMHhkZmZmID8gc3RyW2luZGV4XSAvLyBzaW5nbGUgY2hhcmFjdGVyXG4gICAgOiBzdHIuc2xpY2UoaW5kZXgsIGluZGV4ICsgMik7IC8vIHR3by1pbmRleCBjaGFyYWN0ZXJzXG4gICAgcmVzdWx0LnB1c2goY2hhcik7XG4gICAgaW5kZXggKz0gY2hhci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGYXN0IHZlcnNpb24gb2YgdHMgZnVuY3Rpb24gZm9yIHdoZW4gdHJhbnNpdGlvbiBkZWZhdWx0cyBhcmUgd2VsbCBrbm93blxuICogQHBhcmFtIHtTdGF0ZTxzdHJpbmc+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHR0XG4gKiBAcGFyYW0ge1tSZWdFeHAsIFN0YXRlPHN0cmluZz5dW119IGpyXG4gKiBAcmV0dXJucyB7U3RhdGU8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZmFzdHRzKHN0YXRlLCBpbnB1dCwgdCwgZGVmYXVsdHQsIGpyKSB7XG4gIGxldCBuZXh0O1xuICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgIGlmIChzdGF0ZS5qW2NoYXJdKSB7XG4gICAgICBuZXh0ID0gc3RhdGUualtjaGFyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCA9IG5ldyBTdGF0ZShkZWZhdWx0dCk7XG4gICAgICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgICAgIHN0YXRlLmpbY2hhcl0gPSBuZXh0O1xuICAgIH1cbiAgICBzdGF0ZSA9IG5leHQ7XG4gIH1cbiAgbmV4dCA9IG5ldyBTdGF0ZSh0KTtcbiAgbmV4dC5qciA9IGpyLnNsaWNlKCk7XG4gIHN0YXRlLmpbaW5wdXRbbGVuIC0gMV1dID0gbmV4dDtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVG9wLUxldmVsIERvbWFpbiBuYW1lcyBlbmNvZGVkIGluIHVwZGF0ZS10bGRzLmpzIGJhY2tcbiAqIGludG8gYSBsaXN0IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cn0gZW5jb2RlZCBlbmNvZGVkIFRMRHMgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyW119IG9yaWdpbmFsIFRMRHMgbGlzdFxuICovXG5mdW5jdGlvbiBkZWNvZGVUbGRzKGVuY29kZWQpIHtcbiAgY29uc3Qgd29yZHMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgZGlnaXRzID0gJzAxMjM0NTY3ODknO1xuICB3aGlsZSAoaSA8IGVuY29kZWQubGVuZ3RoKSB7XG4gICAgbGV0IHBvcERpZ2l0Q291bnQgPSAwO1xuICAgIHdoaWxlIChkaWdpdHMuaW5kZXhPZihlbmNvZGVkW2kgKyBwb3BEaWdpdENvdW50XSkgPj0gMCkge1xuICAgICAgcG9wRGlnaXRDb3VudCsrOyAvLyBlbmNvdW50ZXJlZCBzb21lIGRpZ2l0cywgaGF2ZSB0byBwb3AgdG8gZ28gb25lIGxldmVsIHVwIHRyaWVcbiAgICB9XG5cbiAgICBpZiAocG9wRGlnaXRDb3VudCA+IDApIHtcbiAgICAgIHdvcmRzLnB1c2goc3RhY2suam9pbignJykpOyAvLyB3aGF0ZXZlciBwcmVjZWRlZCB0aGUgcG9wIGRpZ2l0cyBtdXN0IGJlIGEgd29yZFxuICAgICAgZm9yIChsZXQgcG9wQ291bnQgPSBwYXJzZUludChlbmNvZGVkLnN1YnN0cmluZyhpLCBpICsgcG9wRGlnaXRDb3VudCksIDEwKTsgcG9wQ291bnQgPiAwOyBwb3BDb3VudC0tKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgICAgaSArPSBwb3BEaWdpdENvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKGVuY29kZWRbaV0pOyAvLyBkcm9wIGRvd24gYSBsZXZlbCBpbnRvIHRoZSB0cmllXG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiB3b3Jkcztcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSB2YWxpZCBET00gRXZlbnQgTmFtZSBzdWNoIGFzIGBjbGlja2Agb3IgYGZvY3VzYFxuICogYW5kIGVhY2ggdmFsdWUgaXMgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudCNldmVudHNcbiAqIEB0eXBlZGVmIHs/eyBbZXZlbnQ6IHN0cmluZ106IEZ1bmN0aW9uIH19IEV2ZW50TGlzdGVuZXJzXG4gKi9cblxuLyoqXG4gKiBBbGwgZm9ybWF0dGVkIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gcmVuZGVyIGEgbGluaywgaW5jbHVkaW5nIGB0YWdOYW1lYCxcbiAqIGBhdHRyaWJ1dGVzYCwgYGNvbnRlbnRgIGFuZCBgZXZlbnRMaXN0ZW5lcnNgLlxuICogQHR5cGVkZWYge3sgdGFnTmFtZTogYW55LCBhdHRyaWJ1dGVzOiB7W2F0dHI6IHN0cmluZ106IGFueX0sIGNvbnRlbnQ6IHN0cmluZyxcbiAqIGV2ZW50TGlzdGVuZXJzOiBFdmVudExpc3RlbmVycyB9fSBJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYW4gb2JqZWN0IGRlc2NyaWJlZCBieSB0aGUgdGVtcGxhdGUgdHlwZSBgT2Agb3IgYSBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYE9gXG4gKiBAdGVtcGxhdGUgT1xuICogQHR5cGVkZWYge08gfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IE8pfSBPcHRPYmpcbiAqL1xuXG4vKipcbiAqIFNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gZGVzY3JpYmVkIGJ5IHRlbXBsYXRlIHR5cGUgYEZgIG9yIGFuIG9iamVjdC5cbiAqXG4gKiBFYWNoIGtleSBpbiB0aGUgb2JqZWN0IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLiBFYWNoXG4gKiB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiB3aXRoIHRlbXBsYXRlIHR5cGUgYEZgIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiBjb3JyZXNwb25kaW5nIGxpbmsgdHlwZSBpcyBlbmNvdW50ZXJlZC5cbiAqIEB0ZW1wbGF0ZSBGXG4gKiBAdHlwZWRlZiB7RiB8IHsgW3R5cGU6IHN0cmluZ106IEZ9fSBPcHRGblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSB2YWx1ZSB3aXRoIHRlbXBsYXRlIHR5cGUgYFZgLCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgVmAgb3JcbiAqIGFuIG9iamVjdCB3aGVyZSBlYWNoIHZhbHVlIHJlc29sdmVzIHRvIGBWYC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYFZgXG4gKlxuICogRm9yIHRoZSBvYmplY3QsIGVhY2gga2V5IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLlxuICogRWFjaCB2YWx1ZSBzaG91bGQgZWl0aGVyIGhhdmUgdHlwZSBgVmAgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgVi4gVGhpc1xuICogZnVuY3Rpb24gc2ltaWxhcmx5IHRha2VzIGEgc3RyaW5nIHZhbHVlIGFuZCBhIHRva2VuLlxuICpcbiAqIEV4YW1wbGUgdmFsaWQgdHlwZXMgZm9yIGBPcHQ8c3RyaW5nPmA6XG4gKlxuICogYGBganNcbiAqICdoZWxsbydcbiAqICh2YWx1ZSwgdHlwZSwgdG9rZW4pID0+ICd3b3JsZCdcbiAqIHsgdXJsOiAnaGVsbG8nLCBlbWFpbDogKHZhbHVlLCB0b2tlbikgPT4gJ3dvcmxkJ31cbiAqIGBgYFxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtWIHwgKCh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB8IHsgW3R5cGU6IHN0cmluZ106IFYgfCAoKHZhbHVlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB9fSBPcHRcbiAqL1xuXG4vKipcbiAqIFNlZSBhdmFpbGFibGUgb3B0aW9uczogaHR0cHM6Ly9saW5raWZ5LmpzLm9yZy9kb2NzL29wdGlvbnMuaHRtbFxuICogQHR5cGVkZWYge3tcbiAqIFx0ZGVmYXVsdFByb3RvY29sPzogc3RyaW5nLFxuICogIGV2ZW50cz86IE9wdE9iajxFdmVudExpc3RlbmVycz4sXG4gKiBcdGZvcm1hdD86IE9wdDxzdHJpbmc+LFxuICogXHRmb3JtYXRIcmVmPzogT3B0PHN0cmluZz4sXG4gKiBcdG5sMmJyPzogYm9vbGVhbixcbiAqIFx0dGFnTmFtZT86IE9wdDxhbnk+LFxuICogXHR0YXJnZXQ/OiBPcHQ8c3RyaW5nPixcbiAqIFx0cmVsPzogT3B0PHN0cmluZz4sXG4gKiBcdHZhbGlkYXRlPzogT3B0PGJvb2xlYW4+LFxuICogXHR0cnVuY2F0ZT86IE9wdDxudW1iZXI+LFxuICogXHRjbGFzc05hbWU/OiBPcHQ8c3RyaW5nPixcbiAqIFx0YXR0cmlidXRlcz86IE9wdE9iajwoeyBbYXR0cjogc3RyaW5nXTogYW55IH0pPixcbiAqICBpZ25vcmVUYWdzPzogc3RyaW5nW10sXG4gKiBcdHJlbmRlcj86IE9wdEZuPCgoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnkpPlxuICogfX0gT3B0c1xuICovXG5cbi8qKlxuICogQHR5cGUgUmVxdWlyZWQ8T3B0cz5cbiAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGRlZmF1bHRQcm90b2NvbDogJ2h0dHAnLFxuICBldmVudHM6IG51bGwsXG4gIGZvcm1hdDogbm9vcCxcbiAgZm9ybWF0SHJlZjogbm9vcCxcbiAgbmwyYnI6IGZhbHNlLFxuICB0YWdOYW1lOiAnYScsXG4gIHRhcmdldDogbnVsbCxcbiAgcmVsOiBudWxsLFxuICB2YWxpZGF0ZTogdHJ1ZSxcbiAgdHJ1bmNhdGU6IEluZmluaXR5LFxuICBjbGFzc05hbWU6IG51bGwsXG4gIGF0dHJpYnV0ZXM6IG51bGwsXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICByZW5kZXI6IG51bGxcbn07XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyBmb3IgbGlua2lmeSBpbnRlcmZhY2VzIHRvIGFwcGx5IHNwZWNpZmllZFxuICoge0BsaW5rIE9wdHMgZm9ybWF0dGluZyBhbmQgcmVuZGVyaW5nIG9wdGlvbnN9LlxuICpcbiAqIEBwYXJhbSB7T3B0cyB8IE9wdGlvbnN9IFtvcHRzXSBPcHRpb24gdmFsdWUgb3ZlcnJpZGVzLlxuICogQHBhcmFtIHsoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnl9IFtkZWZhdWx0UmVuZGVyXSAoRm9yXG4gKiAgIGludGVybmFsIHVzZSkgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGhvdyB0byBnZW5lcmF0ZSBhblxuICogICBIVE1MIGVsZW1lbnQgYmFzZWQgb24gYSBsaW5rIHRva2VuJ3MgZGVyaXZlZCB0YWdOYW1lLCBhdHRyaWJ1dGVzIGFuZCBIVE1MLlxuICogICBTaW1pbGFyIHRvIHJlbmRlciBvcHRpb25cbiAqL1xuZnVuY3Rpb24gT3B0aW9ucyhvcHRzLCBkZWZhdWx0UmVuZGVyKSB7XG4gIGlmIChkZWZhdWx0UmVuZGVyID09PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0UmVuZGVyID0gbnVsbDtcbiAgfVxuICBsZXQgbyA9IGFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICBpZiAob3B0cykge1xuICAgIG8gPSBhc3NpZ24obywgb3B0cyBpbnN0YW5jZW9mIE9wdGlvbnMgPyBvcHRzLm8gOiBvcHRzKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBhbGwgaWdub3JlZCB0YWdzIGFyZSB1cHBlcmNhc2VcbiAgY29uc3QgaWdub3JlZFRhZ3MgPSBvLmlnbm9yZVRhZ3M7XG4gIGNvbnN0IHVwcGVyY2FzZUlnbm9yZWRUYWdzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWdub3JlZFRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB1cHBlcmNhc2VJZ25vcmVkVGFncy5wdXNoKGlnbm9yZWRUYWdzW2ldLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIHRoaXMubyA9IG87XG4gIGlmIChkZWZhdWx0UmVuZGVyKSB7XG4gICAgdGhpcy5kZWZhdWx0UmVuZGVyID0gZGVmYXVsdFJlbmRlcjtcbiAgfVxuICB0aGlzLmlnbm9yZVRhZ3MgPSB1cHBlcmNhc2VJZ25vcmVkVGFncztcbn1cbk9wdGlvbnMucHJvdG90eXBlID0ge1xuICBvOiBkZWZhdWx0cyxcbiAgLyoqXG4gICAqIEB0eXBlIHN0cmluZ1tdXG4gICAqL1xuICBpZ25vcmVUYWdzOiBbXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb259IGlyXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBkZWZhdWx0UmVuZGVyKGlyKSB7XG4gICAgcmV0dXJuIGlyO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGJhc2VkIG9uIHdoZXRoZXIgYSB0b2tlbiBzaG91bGQgYmUgZGlzcGxheWVkIGFzIGFcbiAgICogbGluayBiYXNlZCBvbiB0aGUgdXNlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2sodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3ZhbGlkYXRlJywgdG9rZW4udG9TdHJpbmcoKSwgdG9rZW4pO1xuICB9LFxuICAvLyBQcml2YXRlIG1ldGhvZHNcblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBvcHRpb24ncyB2YWx1ZSBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBhbmQgdGhlIGdpdmVuXG4gICAqIHBhcmFtcy4gSWYgb3BlcmF0b3IgYW5kIHRva2VuIGFyZSBzcGVjaWZpZWQgYW5kIHRoZSB0YXJnZXQgb3B0aW9uIGlzXG4gICAqIGNhbGxhYmxlLCBhdXRvbWF0aWNhbGx5IGNhbGxzIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudC5cbiAgICogQHRlbXBsYXRlIHtrZXlvZiBPcHRzfSBLXG4gICAqIEBwYXJhbSB7S30ga2V5IE5hbWUgb2Ygb3B0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wZXJhdG9yXSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGFyZ2V0IG9wdGlvbiBpZiBpdCdzIGFcbiAgICogZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIFJBVyBmdW5jdGlvbiB2YWx1ZSBnZXRzIHJldHVybmVkXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gW3Rva2VuXSBUaGUgdG9rZW4gZnJvbSBsaW5raWZ5LnRva2VuaXplXG4gICAqIEByZXR1cm5zIHtPcHRzW0tdIHwgYW55fVxuICAgKi9cbiAgZ2V0KGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgY29uc3QgaXNDYWxsYWJsZSA9IG9wZXJhdG9yICE9IG51bGw7XG4gICAgbGV0IG9wdGlvbiA9IHRoaXMub1trZXldO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbiA9IHRva2VuLnQgaW4gb3B0aW9uID8gb3B0aW9uW3Rva2VuLnRdIDogZGVmYXVsdHNba2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICYmIGlzQ2FsbGFibGUpIHtcbiAgICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICYmIGlzQ2FsbGFibGUpIHtcbiAgICAgIG9wdGlvbiA9IG9wdGlvbihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuICAvKipcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBPcHRzfSBMXG4gICAqIEBwYXJhbSB7TH0ga2V5IE5hbWUgb2Ygb3B0aW9ucyBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gW3Rva2VuXVxuICAgKiBAcmV0dXJucyB7T3B0c1tMXSB8IGFueX1cbiAgICovXG4gIGdldE9iaihrZXksIG9wZXJhdG9yLCB0b2tlbikge1xuICAgIGxldCBvYmogPSB0aGlzLm9ba2V5XTtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcGVyYXRvciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoob3BlcmF0b3IsIHRva2VuLnQsIHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIHRva2VuIHRvIGEgcmVuZGVyZWQgZWxlbWVudCB0aGF0IG1heSBiZSBhZGRlZCB0byB0aGVcbiAgICogY2FsbGluZy1pbnRlcmZhY2UncyBET01cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSB0b2tlbiBUb2tlbiB0byByZW5kZXIgdG8gYW4gSFRNTCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHthbnl9IFJlbmRlciByZXN1bHQ7IGUuZy4sIEhUTUwgc3RyaW5nLCBET00gZWxlbWVudCwgUmVhY3RcbiAgICogICBDb21wb25lbnQsIGV0Yy5cbiAgICovXG4gIHJlbmRlcih0b2tlbikge1xuICAgIGNvbnN0IGlyID0gdG9rZW4ucmVuZGVyKHRoaXMpOyAvLyBpbnRlcm1lZGlhdGUgcmVwcmVzZW50YXRpb25cbiAgICBjb25zdCByZW5kZXJGbiA9IHRoaXMuZ2V0KCdyZW5kZXInLCBudWxsLCB0b2tlbikgfHwgdGhpcy5kZWZhdWx0UmVuZGVyO1xuICAgIHJldHVybiByZW5kZXJGbihpciwgdG9rZW4udCwgdG9rZW4pO1xuICB9XG59O1xuZnVuY3Rpb24gbm9vcCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIG9wdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRPcHRpb25zOiBPcHRpb25zLFxuXHRhc3NpZ246IGFzc2lnblxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0TXVsdGktVG9rZW5zXG5cdFRva2VucyBjb21wb3NlZCBvZiBhcnJheXMgb2YgVGV4dFRva2Vuc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gTXVsdGlUb2tlbih2YWx1ZSwgdG9rZW5zKSB7XG4gIHRoaXMudCA9ICd0b2tlbic7XG4gIHRoaXMudiA9IHZhbHVlO1xuICB0aGlzLnRrID0gdG9rZW5zO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHVzZWQgZm9yIG1hbnVmYWN0dXJpbmcgdG9rZW5zIG9mIHRleHQgdG9rZW5zLiBUaGF0IGlzIHJhdGhlclxuICogdGhhbiB0aGUgdmFsdWUgZm9yIGEgdG9rZW4gYmVpbmcgYSBzbWFsbCBzdHJpbmcgb2YgdGV4dCwgaXQncyB2YWx1ZSBhbiBhcnJheVxuICogb2YgdGV4dCB0b2tlbnMuXG4gKlxuICogVXNlZCBmb3IgZ3JvdXBpbmcgdG9nZXRoZXIgVVJMcywgZW1haWxzLCBoYXNodGFncywgYW5kIG90aGVyIHBvdGVudGlhbFxuICogY3JlYXRpb25zLlxuICogQGNsYXNzIE11bHRpVG9rZW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdlxuICogQHByb3BlcnR5IHtUb2tlbltdfSB0a1xuICogQGFic3RyYWN0XG4gKi9cbk11bHRpVG9rZW4ucHJvdG90eXBlID0ge1xuICBpc0xpbms6IGZhbHNlLFxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgdGhpcyB0b2tlbiByZXByZXNlbnRzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy52O1xuICB9LFxuICAvKipcbiAgICogV2hhdCBzaG91bGQgdGhlIHZhbHVlIGZvciB0aGlzIHRva2VuIGJlIGluIHRoZSBgaHJlZmAgSFRNTCBhdHRyaWJ1dGU/XG4gICAqIFJldHVybnMgdGhlIGAudG9TdHJpbmdgIHZhbHVlIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICovXG4gIHRvSHJlZihzY2hlbWUpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbmcgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucykge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICBjb25zdCB0cnVuY2F0ZSA9IG9wdGlvbnMuZ2V0KCd0cnVuY2F0ZScsIHZhbCwgdGhpcyk7XG4gICAgY29uc3QgZm9ybWF0dGVkID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdCcsIHZhbCwgdGhpcyk7XG4gICAgcmV0dXJuIHRydW5jYXRlICYmIGZvcm1hdHRlZC5sZW5ndGggPiB0cnVuY2F0ZSA/IGZvcm1hdHRlZC5zdWJzdHJpbmcoMCwgdHJ1bmNhdGUpICsgJ+KApicgOiBmb3JtYXR0ZWQ7XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0dGVkSHJlZihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZ2V0KCdmb3JtYXRIcmVmJywgdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKSwgdGhpcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGFydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrWzBdLnM7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZW5kIGluZGV4IG9mIHRoaXMgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyAodXAgdG8gdGhpc1xuICAgKiBpbmRleCBidXQgbm90IGluY2x1ZGluZyBpdClcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGVuZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrW3RoaXMudGsubGVuZ3RoIC0gMV0uZTtcbiAgfSxcbiAgLyoqXG4gIFx0UmV0dXJucyBhbiBvYmplY3QgIG9mIHJlbGV2YW50IHZhbHVlcyBmb3IgdGhpcyB0b2tlbiwgd2hpY2ggaW5jbHVkZXMga2V5c1xuICBcdCogdHlwZSAtIEtpbmQgb2YgdG9rZW4gKCd1cmwnLCAnZW1haWwnLCBldGMuKVxuICBcdCogdmFsdWUgLSBPcmlnaW5hbCB0ZXh0XG4gIFx0KiBocmVmIC0gVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBhbmNob3IgdGFnJ3MgaHJlZlxuICBcdFx0YXR0cmlidXRlXG4gIFx0XHRAbWV0aG9kIHRvT2JqZWN0XG4gIFx0QHBhcmFtIHtzdHJpbmd9IFtwcm90b2NvbF0gYCdodHRwJ2AgYnkgZGVmYXVsdFxuICAqL1xuICB0b09iamVjdChwcm90b2NvbCkge1xuICAgIGlmIChwcm90b2NvbCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm90b2NvbCA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudCxcbiAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0hyZWYocHJvdG9jb2wpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRJbmRleCgpLFxuICAgICAgZW5kOiB0aGlzLmVuZEluZGV4KClcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbmcgb3B0aW9uXG4gICAqL1xuICB0b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudCxcbiAgICAgIHZhbHVlOiB0aGlzLnRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpLFxuICAgICAgaXNMaW5rOiB0aGlzLmlzTGluayxcbiAgICAgIGhyZWY6IHRoaXMudG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRJbmRleCgpLFxuICAgICAgZW5kOiB0aGlzLmVuZEluZGV4KClcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHRva2VuIHNob3VsZCBiZSByZW5kZXJlZCBhcyBhIGxpbmsgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ3ZhbGlkYXRlJywgdGhpcy50b1N0cmluZygpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybiBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGhvdyB0aGlzIGxpbmsgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGlubmcgb3B0aW9uc1xuICAgKi9cbiAgcmVuZGVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG4gICAgY29uc3QgaHJlZiA9IHRoaXMudG9IcmVmKG9wdGlvbnMuZ2V0KCdkZWZhdWx0UHJvdG9jb2wnKSk7XG4gICAgY29uc3QgZm9ybWF0dGVkSHJlZiA9IG9wdGlvbnMuZ2V0KCdmb3JtYXRIcmVmJywgaHJlZiwgdGhpcyk7XG4gICAgY29uc3QgdGFnTmFtZSA9IG9wdGlvbnMuZ2V0KCd0YWdOYW1lJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBvcHRpb25zLmdldCgnY2xhc3NOYW1lJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMuZ2V0KCd0YXJnZXQnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgcmVsID0gb3B0aW9ucy5nZXQoJ3JlbCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCBhdHRycyA9IG9wdGlvbnMuZ2V0T2JqKCdhdHRyaWJ1dGVzJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gb3B0aW9ucy5nZXRPYmooJ2V2ZW50cycsIGhyZWYsIHRva2VuKTtcbiAgICBhdHRyaWJ1dGVzLmhyZWYgPSBmb3JtYXR0ZWRIcmVmO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGF0dHJpYnV0ZXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAocmVsKSB7XG4gICAgICBhdHRyaWJ1dGVzLnJlbCA9IHJlbDtcbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBhc3NpZ24oYXR0cmlidXRlcywgYXR0cnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGFnTmFtZSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBjb250ZW50LFxuICAgICAgZXZlbnRMaXN0ZW5lcnNcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0b2tlbiB0aGF0IGNhbiBiZSBlbWl0dGVkIGJ5IHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgcmVhZGFibGUgdHlwZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBwcm9wZXJ0aWVzIHRvIGFzc2lnbiBvciBvdmVycmlkZSwgaW5jbHVkaW5nIGlzTGluayA9IHRydWUgb3IgZmFsc2VcbiAqIEByZXR1cm5zIHtuZXcgKHZhbHVlOiBzdHJpbmcsIHRva2VuczogVG9rZW5bXSkgPT4gTXVsdGlUb2tlbn0gbmV3IHRva2VuIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuQ2xhc3ModHlwZSwgcHJvcHMpIHtcbiAgY2xhc3MgVG9rZW4gZXh0ZW5kcyBNdWx0aVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW5zKSB7XG4gICAgICBzdXBlcih2YWx1ZSwgdG9rZW5zKTtcbiAgICAgIHRoaXMudCA9IHR5cGU7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcCBpbiBwcm9wcykge1xuICAgIFRva2VuLnByb3RvdHlwZVtwXSA9IHByb3BzW3BdO1xuICB9XG4gIFRva2VuLnQgPSB0eXBlO1xuICByZXR1cm4gVG9rZW47XG59XG5cbi8qKlxuXHRSZXByZXNlbnRzIGEgbGlzdCBvZiB0b2tlbnMgbWFraW5nIHVwIGEgdmFsaWQgZW1haWwgYWRkcmVzc1xuKi9cbmNvbnN0IEVtYWlsID0gY3JlYXRlVG9rZW5DbGFzcygnZW1haWwnLCB7XG4gIGlzTGluazogdHJ1ZSxcbiAgdG9IcmVmKCkge1xuICAgIHJldHVybiAnbWFpbHRvOicgKyB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn0pO1xuXG4vKipcblx0UmVwcmVzZW50cyBzb21lIHBsYWluIHRleHRcbiovXG5jb25zdCBUZXh0ID0gY3JlYXRlVG9rZW5DbGFzcygndGV4dCcpO1xuXG4vKipcblx0TXVsdGktbGluZWJyZWFrIHRva2VuIC0gcmVwcmVzZW50cyBhIGxpbmUgYnJlYWtcblx0QGNsYXNzIE5sXG4qL1xuY29uc3QgTmwgPSBjcmVhdGVUb2tlbkNsYXNzKCdubCcpO1xuXG4vKipcblx0UmVwcmVzZW50cyBhIGxpc3Qgb2YgdGV4dCB0b2tlbnMgbWFraW5nIHVwIGEgdmFsaWQgVVJMXG5cdEBjbGFzcyBVcmxcbiovXG5jb25zdCBVcmwgPSBjcmVhdGVUb2tlbkNsYXNzKCd1cmwnLCB7XG4gIGlzTGluazogdHJ1ZSxcbiAgLyoqXG4gIFx0TG93ZXJjYXNlcyByZWxldmFudCBwYXJ0cyBvZiB0aGUgZG9tYWluIGFuZCBhZGRzIHRoZSBwcm90b2NvbCBpZlxuICBcdHJlcXVpcmVkLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlc2NhcGUgdW5zYWZlIEhUTUwgY2hhcmFjdGVycyBpbiB0aGVcbiAgXHRVUkwuXG4gIFx0XHRAcGFyYW0ge3N0cmluZ30gW3NjaGVtZV0gZGVmYXVsdCBzY2hlbWUgKGUuZy4sICdodHRwcycpXG4gIFx0QHJldHVybiB7c3RyaW5nfSB0aGUgZnVsbCBocmVmXG4gICovXG4gIHRvSHJlZihzY2hlbWUpIHtcbiAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHtcbiAgICAgIHNjaGVtZSA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBoYXMgYSBwcmVmaXggc2NoZW1lXG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2woKSA/IHRoaXMudiA6IGAke3NjaGVtZX06Ly8ke3RoaXMudn1gO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIFVSTCB0b2tlbiBoYXMgYSBwcm90b2NvbFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzUHJvdG9jb2woKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy50aztcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vuc1swXS50ICE9PSBMT0NBTEhPU1QgJiYgdG9rZW5zWzFdLnQgPT09IENPTE9OO1xuICB9XG59KTtcblxudmFyIG11bHRpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdE11bHRpVG9rZW46IE11bHRpVG9rZW4sXG5cdEJhc2U6IE11bHRpVG9rZW4sXG5cdGNyZWF0ZVRva2VuQ2xhc3M6IGNyZWF0ZVRva2VuQ2xhc3MsXG5cdEVtYWlsOiBFbWFpbCxcblx0VGV4dDogVGV4dCxcblx0Tmw6IE5sLFxuXHRVcmw6IFVybFxufSk7XG5cbi8qKlxuXHROb3QgZXhhY3RseSBwYXJzZXIsIG1vcmUgbGlrZSB0aGUgc2Vjb25kLXN0YWdlIHNjYW5uZXIgKGFsdGhvdWdoIHdlIGNhblxuXHR0aGVvcmV0aWNhbGx5IGhvdHN3YXAgdGhlIGNvZGUgaGVyZSB3aXRoIGEgcmVhbCBwYXJzZXIgaW4gdGhlIGZ1dHVyZS4uLiBidXRcblx0Zm9yIGEgbGl0dGxlIFVSTC1maW5kaW5nIHV0aWxpdHkgYWJzdHJhY3Qgc3ludGF4IHRyZWVzIG1heSBiZSBhIGxpdHRsZVxuXHRvdmVya2lsbCkuXG5cblx0VVJMIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUklfc2NoZW1lXG5cdEVtYWlsIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbWFpbEFkZHJlc3MgKGxpbmtzIHRvIFJGQyBpblxuXHRyZWZlcmVuY2UpXG5cblx0QG1vZHVsZSBsaW5raWZ5XG5cdEBzdWJtb2R1bGUgcGFyc2VyXG5cdEBtYWluIHJ1blxuKi9cbmNvbnN0IG1ha2VTdGF0ZSA9IGFyZyA9PiBuZXcgU3RhdGUoYXJnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgcGFyc2VyIG11bHRpIHRva2VuLWJhc2VkIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7eyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGluaXQkMShfcmVmKSB7XG4gIGxldCB7XG4gICAgZ3JvdXBzXG4gIH0gPSBfcmVmO1xuICAvLyBUeXBlcyBvZiBjaGFyYWN0ZXJzIHRoZSBVUkwgY2FuIGRlZmluaXRlbHkgZW5kIGluXG4gIGNvbnN0IHFzQWNjZXB0aW5nID0gZ3JvdXBzLmRvbWFpbi5jb25jYXQoW0FNUEVSU0FORCwgQVNURVJJU0ssIEFULCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgTlVNLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdKTtcblxuICAvLyBUeXBlcyBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IGEgVVJMIGFuZCBiZSBwYXJ0IG9mIHRoZSBxdWVyeSBzdHJpbmdcbiAgLy8gYnV0IGNhbm5vdCBiZSB0aGUgdmVyeSBsYXN0IGNoYXJhY3RlcnNcbiAgLy8gQ2hhcmFjdGVycyB0aGF0IGNhbm5vdCBhcHBlYXIgaW4gdGhlIFVSTCBhdCBhbGwgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gIGNvbnN0IHFzTm9uQWNjZXB0aW5nID0gW0FQT1NUUk9QSEUsIENPTE9OLCBDT01NQSwgRE9ULCBFWENMQU1BVElPTiwgUVVFUlksIFFVT1RFLCBTRU1JLCBPUEVOQU5HTEVCUkFDS0VULCBDTE9TRUFOR0xFQlJBQ0tFVCwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBDTE9TRUJSQUNLRVQsIE9QRU5CUkFDS0VULCBPUEVOUEFSRU4sIENMT1NFUEFSRU4sIEZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTiwgTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVCwgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVQsIEZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl07XG5cbiAgLy8gRm9yIGFkZHJlc3NlcyB3aXRob3V0IHRoZSBtYWlsdG8gcHJlZml4XG4gIC8vIFRva2VucyBhbGxvd2VkIGluIHRoZSBsb2NhbHBhcnQgb2YgdGhlIGVtYWlsXG4gIGNvbnN0IGxvY2FscGFydEFjY2VwdGluZyA9IFtBTVBFUlNBTkQsIEFQT1NUUk9QSEUsIEFTVEVSSVNLLCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgUVVFUlksIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXTtcblxuICAvLyBUaGUgdW5pdmVyc2FsIHN0YXJ0aW5nIHN0YXRlLlxuICAvKipcbiAgICogQHR5cGUgU3RhdGU8VG9rZW4+XG4gICAqL1xuICBjb25zdCBTdGFydCA9IG1ha2VTdGF0ZSgpO1xuICBjb25zdCBMb2NhbHBhcnQgPSB0dChTdGFydCwgVElMREUpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzXG4gIHRhKExvY2FscGFydCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnQsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IERvbWFpbiA9IG1ha2VTdGF0ZSgpLFxuICAgIFNjaGVtZSA9IG1ha2VTdGF0ZSgpLFxuICAgIFNsYXNoU2NoZW1lID0gbWFrZVN0YXRlKCk7XG4gIHRhKFN0YXJ0LCBncm91cHMuZG9tYWluLCBEb21haW4pOyAvLyBwYXJzZWQgc3RyaW5nIGVuZHMgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZSAoQSlcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zY2hlbWUsIFNjaGVtZSk7IC8vIGUuZy4sICdtYWlsdG8nXG4gIHRhKFN0YXJ0LCBncm91cHMuc2xhc2hzY2hlbWUsIFNsYXNoU2NoZW1lKTsgLy8gZS5nLiwgJ2h0dHAnXG5cbiAgdGEoRG9tYWluLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgTG9jYWxwYXJ0QXQgPSB0dChEb21haW4sIEFUKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzIEBcblxuICB0dChMb2NhbHBhcnQsIEFULCBMb2NhbHBhcnRBdCk7IC8vIGNsb3NlIHRvIGFuIGVtYWlsIGFkZHJlc3Mgbm93XG5cbiAgLy8gTG9jYWwgcGFydCBvZiBhbiBlbWFpbCBhZGRyZXNzIGNhbiBiZSBlLmcuICdodHRwJyBvciAnbWFpbHRvJ1xuICB0dChTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBMb2NhbHBhcnREb3QgPSB0dChMb2NhbHBhcnQsIERPVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyAnLicgKGxvY2FscGFydCBjYW5ub3QgZW5kIGluIC4pXG4gIHRhKExvY2FscGFydERvdCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnREb3QsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IEVtYWlsRG9tYWluID0gbWFrZVN0YXRlKCk7XG4gIHRhKExvY2FscGFydEF0LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICBjb25zdCBFbWFpbERvbWFpbkRvdCA9IHR0KEVtYWlsRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsJDEgPSBtYWtlU3RhdGUoRW1haWwpOyAvLyBQb3NzaWJsZSBlbWFpbCBhZGRyZXNzIChjb3VsZCBoYXZlIG1vcmUgdGxkcylcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy50bGQsIEVtYWlsJDEpO1xuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIEVtYWlsJDEpO1xuICB0dChMb2NhbHBhcnRBdCwgTE9DQUxIT1NULCBFbWFpbCQxKTtcblxuICAvLyBIeXBoZW4gY2FuIGp1bXAgYmFjayB0byBhIGRvbWFpbiBuYW1lXG4gIGNvbnN0IEVtYWlsRG9tYWluSHlwaGVuID0gdHQoRW1haWxEb21haW4sIEhZUEhFTik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICB0YShFbWFpbCQxLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHR0KEVtYWlsJDEsIERPVCwgRW1haWxEb21haW5Eb3QpO1xuICB0dChFbWFpbCQxLCBIWVBIRU4sIEVtYWlsRG9tYWluSHlwaGVuKTtcblxuICAvLyBGaW5hbCBwb3NzaWJsZSBlbWFpbCBzdGF0ZXNcbiAgY29uc3QgRW1haWxDb2xvbiA9IHR0KEVtYWlsJDEsIENPTE9OKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIChwb3RlbnRpYWwgcG9ydCBudW1iZXIgaGVyZSlcbiAgLypjb25zdCBFbWFpbENvbG9uUG9ydCA9ICovXG4gIHRhKEVtYWlsQ29sb24sIGdyb3Vwcy5udW1lcmljLCBFbWFpbCk7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiBhbmQgcG9ydCBudW1iZXJcblxuICAvLyBBY2NvdW50IGZvciBkb3RzIGFuZCBoeXBoZW5zLiBIeXBoZW5zIGFyZSB1c3VhbGx5IHBhcnRzIG9mIGRvbWFpbiBuYW1lc1xuICAvLyAoYnV0IG5vdCBUTERzKVxuICBjb25zdCBEb21haW5IeXBoZW4gPSB0dChEb21haW4sIEhZUEhFTik7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBoeXBoZW5cbiAgY29uc3QgRG9tYWluRG90ID0gdHQoRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgRG9tYWluRG90VGxkID0gbWFrZVN0YXRlKFVybCk7IC8vIFNpbXBsZXN0IHBvc3NpYmxlIFVSTCB3aXRoIG5vIHF1ZXJ5IHN0cmluZ1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy50bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdFRsZCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90VGxkLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChEb21haW5Eb3RUbGQsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdHQoRG9tYWluRG90VGxkLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvbiA9IHR0KERvbWFpbkRvdFRsZCwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvblBvcnQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVExEIGZvbGxvd2VkIGJ5IGEgcG9ydCBudW1iZXJcbiAgdGEoRG9tYWluRG90VGxkQ29sb24sIGdyb3Vwcy5udW1lcmljLCBEb21haW5Eb3RUbGRDb2xvblBvcnQpO1xuXG4gIC8vIExvbmcgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBhbmQgbWF5YmUgcXVlcnkgc3RyaW5nXG4gIGNvbnN0IFVybCQxID0gbWFrZVN0YXRlKFVybCk7XG5cbiAgLy8gVVJMIHdpdGggZXh0cmEgc3ltYm9scyBhdCB0aGUgZW5kLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcbiAgY29uc3QgVXJsTm9uYWNjZXB0ID0gbWFrZVN0YXRlKCk7IC8vIFVSTCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgKHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGZpbmFsIFVSTClcblxuICAvLyBRdWVyeSBzdHJpbmdzXG4gIHRhKFVybCQxLCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmwkMSwgcXNOb25BY2NlcHRpbmcsIFVybE5vbmFjY2VwdCk7XG4gIHRhKFVybE5vbmFjY2VwdCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcblxuICAvLyBCZWNvbWUgcmVhbCBVUkxzIGFmdGVyIGBTTEFTSGAgb3IgYENPTE9OIE5VTSBTTEFTSGBcbiAgLy8gSGVyZSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgc2NoZW1lOi8vIHByZWZpeFxuICB0dChEb21haW5Eb3RUbGQsIFNMQVNILCBVcmwkMSk7XG4gIHR0KERvbWFpbkRvdFRsZENvbG9uUG9ydCwgU0xBU0gsIFVybCQxKTtcblxuICAvLyBOb3RlIHRoYXQgZG9tYWlucyB0aGF0IGJlZ2luIHdpdGggc2NoZW1lcyBhcmUgdHJlYXRlZCBzbGlnaGx5IGRpZmZlcmVudGx5XG4gIGNvbnN0IFNjaGVtZUNvbG9uID0gdHQoU2NoZW1lLCBDT0xPTik7IC8vIGUuZy4sICdtYWlsdG86J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uID0gdHQoU2xhc2hTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ2h0dHA6J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uU2xhc2ggPSB0dChTbGFzaFNjaGVtZUNvbG9uLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8nXG5cbiAgY29uc3QgVXJpUHJlZml4ID0gdHQoU2xhc2hTY2hlbWVDb2xvblNsYXNoLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8vJ1xuXG4gIC8vIFNjaGVtZSBzdGF0ZXMgY2FuIHRyYW5zaXRpb24gdG8gZG9tYWluIHN0YXRlc1xuICB0YShTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNjaGVtZSwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdGEoU2xhc2hTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNsYXNoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG5cbiAgLy8gRm9yY2UgVVJMIHdpdGggc2NoZW1lIHByZWZpeCBmb2xsb3dlZCBieSBhbnl0aGluZyBzYW5lXG4gIHRhKFNjaGVtZUNvbG9uLCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHR0KFNjaGVtZUNvbG9uLCBTTEFTSCwgVXJsJDEpO1xuICB0YShVcmlQcmVmaXgsIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdGEoVXJpUHJlZml4LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0dChVcmlQcmVmaXgsIFNMQVNILCBVcmwkMSk7XG4gIGNvbnN0IGJyYWNrZXRQYWlycyA9IFtbT1BFTkJSQUNFLCBDTE9TRUJSQUNFXSxcbiAgLy8ge31cbiAgW09QRU5CUkFDS0VULCBDTE9TRUJSQUNLRVRdLFxuICAvLyBbXVxuICBbT1BFTlBBUkVOLCBDTE9TRVBBUkVOXSxcbiAgLy8gKClcbiAgW09QRU5BTkdMRUJSQUNLRVQsIENMT1NFQU5HTEVCUkFDS0VUXSxcbiAgLy8gPD5cbiAgW0ZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTl0sXG4gIC8vIO+8iO+8iVxuICBbTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVF0sXG4gIC8vIOOAjOOAjVxuICBbTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVRdLFxuICAvLyDjgI7jgI9cbiAgW0ZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl0gLy8g77yc77yeXG4gIF07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBicmFja2V0UGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbT1BFTiwgQ0xPU0VdID0gYnJhY2tldFBhaXJzW2ldO1xuICAgIGNvbnN0IFVybE9wZW4gPSB0dChVcmwkMSwgT1BFTik7IC8vIFVSTCBmb2xsb3dlZCBieSBvcGVuIGJyYWNrZXRcblxuICAgIC8vIENvbnRpbnVlIG5vdCBhY2NlcHRpbmcgZm9yIG9wZW4gYnJhY2tldHNcbiAgICB0dChVcmxOb25hY2NlcHQsIE9QRU4sIFVybE9wZW4pO1xuXG4gICAgLy8gQ2xvc2luZyBicmFja2V0IGNvbXBvbmVudC4gVGhpcyBjaGFyYWN0ZXIgV0lMTCBiZSBpbmNsdWRlZCBpbiB0aGUgVVJMXG4gICAgdHQoVXJsT3BlbiwgQ0xPU0UsIFVybCQxKTtcblxuICAgIC8vIFVSTCB0aGF0IGJlaW5ncyB3aXRoIGFuIG9wZW5pbmcgYnJhY2tldCwgZm9sbG93ZWQgYnkgYSBzeW1ib2xzLlxuICAgIC8vIE5vdGUgdGhhdCB0aGUgZmluYWwgc3RhdGUgY2FuIHN0aWxsIGJlIGBVcmxPcGVuYCAoaWYgdGhlIFVSTCBoYXMgYVxuICAgIC8vIHNpbmdsZSBvcGVuaW5nIGJyYWNrZXQgZm9yIHNvbWUgcmVhc29uKS5cbiAgICBjb25zdCBVcmxPcGVuUSA9IG1ha2VTdGF0ZShVcmwpO1xuICAgIHRhKFVybE9wZW4sIHFzQWNjZXB0aW5nLCBVcmxPcGVuUSk7XG4gICAgY29uc3QgVXJsT3BlblN5bXMgPSBtYWtlU3RhdGUoKTsgLy8gVXJsT3BlbiBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgaXQgY2Fubm90IGVuZCBpdFxuICAgIHRhKFVybE9wZW4sIHFzTm9uQWNjZXB0aW5nKTtcblxuICAgIC8vIFVSTCB0aGF0IGJlZ2lucyB3aXRoIGFuIG9wZW5pbmcgYnJhY2tldCwgZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzXG4gICAgdGEoVXJsT3BlblEsIHFzQWNjZXB0aW5nLCBVcmxPcGVuUSk7XG4gICAgdGEoVXJsT3BlblEsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuU3ltcyk7XG4gICAgdGEoVXJsT3BlblN5bXMsIHFzQWNjZXB0aW5nLCBVcmxPcGVuUSk7XG4gICAgdGEoVXJsT3BlblN5bXMsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuU3ltcyk7XG5cbiAgICAvLyBDbG9zZSBicmFjZS9icmFja2V0IHRvIGJlY29tZSByZWd1bGFyIFVSTFxuICAgIHR0KFVybE9wZW5RLCBDTE9TRSwgVXJsJDEpO1xuICAgIHR0KFVybE9wZW5TeW1zLCBDTE9TRSwgVXJsJDEpO1xuICB9XG4gIHR0KFN0YXJ0LCBMT0NBTEhPU1QsIERvbWFpbkRvdFRsZCk7IC8vIGxvY2FsaG9zdCBpcyBhIHZhbGlkIFVSTCBzdGF0ZVxuICB0dChTdGFydCwgTkwkMSwgTmwpOyAvLyBzaW5nbGUgbmV3IGxpbmVcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBTdGFydCxcbiAgICB0b2tlbnM6IHRrXG4gIH07XG59XG5cbi8qKlxuICogUnVuIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBvbiBhIGxpc3Qgb2Ygc2Nhbm5lZCBzdHJpbmctYmFzZWQgdG9rZW5zIHRvXG4gKiBjcmVhdGUgYSBsaXN0IG9mIG11bHRpIHRva2VucywgZWFjaCBvZiB3aGljaCByZXByZXNlbnRzIGEgVVJMLCBlbWFpbCBhZGRyZXNzLFxuICogcGxhaW4gdGV4dCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7U3RhdGU8TXVsdGlUb2tlbj59IHN0YXJ0IHBhcnNlciBzdGFydCBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHRoZSBvcmlnaW5hbCBpbnB1dCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiB0b2tlbnNcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zIGxpc3Qgb2Ygc2Nhbm5lZCB0b2tlbnNcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VuW119XG4gKi9cbmZ1bmN0aW9uIHJ1bihzdGFydCwgaW5wdXQsIHRva2Vucykge1xuICBsZXQgbGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIGxldCBtdWx0aXMgPSBbXTtcbiAgbGV0IHRleHRUb2tlbnMgPSBbXTtcbiAgd2hpbGUgKGN1cnNvciA8IGxlbikge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBzZWNvbmRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG5leHRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG11bHRpTGVuZ3RoID0gMDtcbiAgICBsZXQgbGF0ZXN0QWNjZXB0aW5nID0gbnVsbDtcbiAgICBsZXQgc2luY2VBY2NlcHRzID0gLTE7XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAhKHNlY29uZFN0YXRlID0gc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBTdGFydGluZyB0b2tlbnMgd2l0aCBub3doZXJlIHRvIGp1bXAgdG8uXG4gICAgICAvLyBDb25zaWRlciB0aGVzZSB0byBiZSBqdXN0IHBsYWluIHRleHRcbiAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yKytdKTtcbiAgICB9XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAobmV4dFN0YXRlID0gc2Vjb25kU3RhdGUgfHwgc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBHZXQgdGhlIG5leHQgc3RhdGVcbiAgICAgIHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrO1xuICAgICAgbXVsdGlMZW5ndGgrKztcbiAgICB9XG4gICAgaWYgKHNpbmNlQWNjZXB0cyA8IDApIHtcbiAgICAgIC8vIE5vIGFjY2VwdGluZyBzdGF0ZSB3YXMgZm91bmQsIHBhcnQgb2YgYSByZWd1bGFyIHRleHQgdG9rZW4gYWRkXG4gICAgICAvLyB0aGUgZmlyc3QgdGV4dCB0b2tlbiB0byB0aGUgdGV4dCB0b2tlbnMgYXJyYXkgYW5kIHRyeSBhZ2FpbiBmcm9tXG4gICAgICAvLyB0aGUgbmV4dFxuICAgICAgY3Vyc29yIC09IG11bHRpTGVuZ3RoO1xuICAgICAgaWYgKGN1cnNvciA8IGxlbikge1xuICAgICAgICB0ZXh0VG9rZW5zLnB1c2godG9rZW5zW2N1cnNvcl0pO1xuICAgICAgICBjdXJzb3IrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWNjZXB0aW5nIHN0YXRlIVxuICAgICAgLy8gRmlyc3QgY2xvc2Ugb2ZmIHRoZSB0ZXh0VG9rZW5zIChpZiBhdmFpbGFibGUpXG4gICAgICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gICAgICAgIHRleHRUb2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgICAgbXVsdGlMZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbXVsdGl0b2tlblxuICAgICAgY29uc3QgTXVsdGkgPSBsYXRlc3RBY2NlcHRpbmcudDtcbiAgICAgIGNvbnN0IHN1YnRva2VucyA9IHRva2Vucy5zbGljZShjdXJzb3IgLSBtdWx0aUxlbmd0aCwgY3Vyc29yKTtcbiAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgc3VidG9rZW5zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluYWxseSBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgaWYgKHRleHRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gIH1cbiAgcmV0dXJuIG11bHRpcztcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgbmV3IG11bHRpdG9rZW4gd2l0aCBhbGwgdGhlIHJlbGV2YW50XG4gKiBmaWVsZHMgZHVyaW5nIHBhcnNpbmcuXG4gKiBAcGFyYW0ge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBNdWx0aSBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgY29uc2VjdXRpdmUgdG9rZW5zIHNjYW5uZWQgZnJvbSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VufVxuICovXG5mdW5jdGlvbiBpbml0TXVsdGlUb2tlbihNdWx0aSwgaW5wdXQsIHRva2Vucykge1xuICBjb25zdCBzdGFydElkeCA9IHRva2Vuc1swXS5zO1xuICBjb25zdCBlbmRJZHggPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmU7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIHJldHVybiBuZXcgTXVsdGkodmFsdWUsIHRva2Vucyk7XG59XG5cbmNvbnN0IHdhcm4gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gfHwgKCgpID0+IHt9KTtcbmNvbnN0IHdhcm5BZHZpY2UgPSAndW50aWwgbWFudWFsIGNhbGwgb2YgbGlua2lmeS5pbml0KCkuIFJlZ2lzdGVyIGFsbCBzY2hlbWVzIGFuZCBwbHVnaW5zIGJlZm9yZSBpbnZva2luZyBsaW5raWZ5IHRoZSBmaXJzdCB0aW1lLic7XG5cbi8vIFNpZGUtZWZmZWN0IGluaXRpYWxpemF0aW9uIHN0YXRlXG5jb25zdCBJTklUID0ge1xuICBzY2FubmVyOiBudWxsLFxuICBwYXJzZXI6IG51bGwsXG4gIHRva2VuUXVldWU6IFtdLFxuICBwbHVnaW5RdWV1ZTogW10sXG4gIGN1c3RvbVNjaGVtZXM6IFtdLFxuICBpbml0aWFsaXplZDogZmFsc2Vcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPHN0cmluZz4sXG4gKiBcdHRva2VuczogeyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfSAmIHR5cGVvZiB0a1xuICogfX0gU2Nhbm5lckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHN0YXJ0OiBTdGF0ZTxNdWx0aVRva2VuPixcbiAqIFx0dG9rZW5zOiB0eXBlb2YgbXVsdGlcbiAqIH19IFBhcnNlckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0IH0pID0+IHZvaWR9IFRva2VuUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFyZzogeyBzY2FubmVyOiBTY2FubmVySW5pdCwgcGFyc2VyOiBQYXJzZXJJbml0IH0pID0+IHZvaWR9IFBsdWdpblxuICovXG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYWxsIHBsdWdpbnMgYW5kIHJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZS1tYWNoaW5lLiBVc2VkIGZvclxuICogdGVzdGluZzsgbm90IHJlcXVpcmVkIGluIHByYWN0aWNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIFN0YXRlLmdyb3VwcyA9IHt9O1xuICBJTklULnNjYW5uZXIgPSBudWxsO1xuICBJTklULnBhcnNlciA9IG51bGw7XG4gIElOSVQudG9rZW5RdWV1ZSA9IFtdO1xuICBJTklULnBsdWdpblF1ZXVlID0gW107XG4gIElOSVQuY3VzdG9tU2NoZW1lcyA9IFtdO1xuICBJTklULmluaXRpYWxpemVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0b2tlbiBwbHVnaW4gdG8gYWxsb3cgdGhlIHNjYW5uZXIgdG8gcmVjb2duaXplIGFkZGl0aW9uYWwgdG9rZW5cbiAqIHR5cGVzIGJlZm9yZSB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgaXMgY29uc3RydWN0ZWQgZnJvbSB0aGUgcmVzdWx0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtUb2tlblBsdWdpbn0gcGx1Z2luIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgc2Nhbm5lciBzdGF0ZSBtYWNoaW5lXG4gKiBhbmQgYXZhaWxhYmxlIHNjYW5uZXIgdG9rZW5zIGFuZCBjb2xsZWN0aW9ucyBhbmQgZXh0ZW5kcyB0aGUgc3RhdGUgbWFjaGluZSB0b1xuICogcmVjb2duaXplIGFkZGl0aW9uYWwgdG9rZW5zIG9yIGdyb3Vwcy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUb2tlblBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCB0b2tlbiBwbHVnaW4gJHtwbHVnaW59IChleHBlY3RzIGZ1bmN0aW9uKWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC50b2tlblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IElOSVQudG9rZW5RdWV1ZVtpXVswXSkge1xuICAgICAgd2FybihgbGlua2lmeWpzOiB0b2tlbiBwbHVnaW4gXCIke25hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkIC0gd2lsbCBiZSBvdmVyd3JpdHRlbmApO1xuICAgICAgSU5JVC50b2tlblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIElOSVQudG9rZW5RdWV1ZS5wdXNoKFtuYW1lLCBwbHVnaW5dKTtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciB0b2tlbiBwbHVnaW4gXCIke25hbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBsaW5raWZ5IHBsdWdpblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgb2YgcGx1Z2luIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0ge1BsdWdpbn0gcGx1Z2luIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgYW5kXG4gKiBleHRlbmRzIHRoZSBwYXJzZXIgdG8gcmVjb2duaXplIGFkZGl0aW9uYWwgbGluayB0eXBlc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCBwbHVnaW4gJHtwbHVnaW59IChleHBlY3RzIGZ1bmN0aW9uKWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBJTklULnBsdWdpblF1ZXVlW2ldWzBdKSB7XG4gICAgICB3YXJuKGBsaW5raWZ5anM6IHBsdWdpbiBcIiR7bmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQgLSB3aWxsIGJlIG92ZXJ3cml0dGVuYCk7XG4gICAgICBJTklULnBsdWdpblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIElOSVQucGx1Z2luUXVldWUucHVzaChbbmFtZSwgcGx1Z2luXSk7XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgcGx1Z2luIFwiJHtuYW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBVUkxzIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIHByb3RvY29sLiBBbnl0aGluZyB3aXRoIGZvcm1hdFxuICogXCJwcm90b2NvbDovLy4uLlwiIHdpbGwgYmUgY29uc2lkZXJlZCBhIGxpbmsuIElmIGBvcHRpb25hbFNsYXNoU2xhc2hgIGlzIHNldCB0b1xuICogYHRydWVgLCBhbnl0aGluZyB3aXRoIGZvcm1hdCBcInByb3RvY29sOi4uLlwiIHdpbGwgYmUgY29uc2lkZXJlZCBhIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsU2xhc2hTbGFzaF1cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChzY2hlbWUsIG9wdGlvbmFsU2xhc2hTbGFzaCkge1xuICBpZiAob3B0aW9uYWxTbGFzaFNsYXNoID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFNsYXNoU2xhc2ggPSBmYWxzZTtcbiAgfVxuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIGN1c3RvbSBzY2hlbWUgXCIke3NjaGVtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbiAgaWYgKCEvXlswLTlhLXpdKygtWzAtOWEtel0rKSokLy50ZXN0KHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogaW5jb3JyZWN0IHNjaGVtZSBmb3JtYXQuXG4xLiBNdXN0IG9ubHkgY29udGFpbiBkaWdpdHMsIGxvd2VyY2FzZSBBU0NJSSBsZXR0ZXJzIG9yIFwiLVwiXG4yLiBDYW5ub3Qgc3RhcnQgb3IgZW5kIHdpdGggXCItXCJcbjMuIFwiLVwiIGNhbm5vdCByZXBlYXRgKTtcbiAgfVxuICBJTklULmN1c3RvbVNjaGVtZXMucHVzaChbc2NoZW1lLCBvcHRpb25hbFNsYXNoU2xhc2hdKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBsaW5raWZ5IHN0YXRlIG1hY2hpbmUuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHRoZSBmaXJzdCB0aW1lXG4gKiBsaW5raWZ5IGlzIGNhbGxlZCBvbiBhIHN0cmluZywgYnV0IG1heSBiZSBjYWxsZWQgbWFudWFsbHkgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgLy8gSW5pdGlhbGl6ZSBzY2FubmVyIHN0YXRlIG1hY2hpbmUgYW5kIHBsdWdpbnNcbiAgSU5JVC5zY2FubmVyID0gaW5pdCQyKElOSVQuY3VzdG9tU2NoZW1lcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC50b2tlblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgSU5JVC50b2tlblF1ZXVlW2ldWzFdKHtcbiAgICAgIHNjYW5uZXI6IElOSVQuc2Nhbm5lclxuICAgIH0pO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBhbmQgcGx1Z2luc1xuICBJTklULnBhcnNlciA9IGluaXQkMShJTklULnNjYW5uZXIudG9rZW5zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnBsdWdpblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgSU5JVC5wbHVnaW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXIsXG4gICAgICBwYXJzZXI6IElOSVQucGFyc2VyXG4gICAgfSk7XG4gIH1cbiAgSU5JVC5pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgaW50byB0b2tlbnMgdGhhdCByZXByZXNlbnQgbGlua2FibGUgYW5kIG5vbi1saW5rYWJsZSBzdWItY29tcG9uZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7TXVsdGlUb2tlbltdfSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc3RyKSB7XG4gIGlmICghSU5JVC5pbml0aWFsaXplZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICByZXR1cm4gcnVuKElOSVQucGFyc2VyLnN0YXJ0LCBzdHIsIHJ1biQxKElOSVQuc2Nhbm5lci5zdGFydCwgc3RyKSk7XG59XG5cbi8qKlxuICogRmluZCBhIGxpc3Qgb2YgbGlua2FibGUgaXRlbXMgaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGZpbmQgbGlua3MgaW5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgT3B0c30gW3R5cGVdIGVpdGhlciBmb3JtYXR0aW5nIG9wdGlvbnMgb3Igc3BlY2lmaWMgdHlwZSBvZlxuICogbGlua3MgdG8gZmluZCwgZS5nLiwgJ3VybCcgb3IgJ2VtYWlsJ1xuICogQHBhcmFtIHtPcHRzfSBbb3B0c10gZm9ybWF0dGluZyBvcHRpb25zIGZvciBmaW5hbCBvdXRwdXQuIENhbm5vdCBiZSBzcGVjaWZpZWRcbiAqIGlmIG9wdHMgYWxyZWFkeSBwcm92aWRlZCBpbiBgdHlwZWAgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gZmluZChzdHIsIHR5cGUsIG9wdHMpIHtcbiAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgdGhyb3cgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCBsaW5rIHR5cGUgJHt0eXBlfTsgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgIH1cbiAgICBvcHRzID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbmV3IE9wdGlvbnMob3B0cyk7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHN0cik7XG4gIGNvbnN0IGZpbHRlcmVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgaWYgKHRva2VuLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW4udCA9PT0gdHlwZSkgJiYgb3B0aW9ucy5jaGVjayh0b2tlbikpIHtcbiAgICAgIGZpbHRlcmVkLnB1c2godG9rZW4udG9Gb3JtYXR0ZWRPYmplY3Qob3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyB2YWxpZCBsaW5rYWJsZSB0ZXh0IG9mIHNvbWUgc29ydC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3RcbiAqIHRyaW0gdGhlIHRleHQgZm9yIHlvdS5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYSBzZWNvbmQgYHR5cGVgIHBhcmFtLCB3aGljaCBpcyB0aGUgdHlwZSBvZiBsaW5rIHRvIHRlc3RcbiAqIGZvci5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgbGlua2lmeS50ZXN0KHN0ciwgJ2VtYWlsJyk7XG4gKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgc3RyIGlzIGEgdmFsaWQgZW1haWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byB0ZXN0IGZvciBsaW5rc1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBvcHRpb25hbCBzcGVjaWZpYyBsaW5rIHR5cGUgdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIGJvb2xlYW4gdHJ1ZS9mYWxzZVxuICovXG5mdW5jdGlvbiB0ZXN0KHN0ciwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgcmV0dXJuIHRva2Vucy5sZW5ndGggPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW5zWzBdLnQgPT09IHR5cGUpO1xufVxuXG5leHBvcnQgeyBNdWx0aVRva2VuLCBPcHRpb25zLCBTdGF0ZSwgY3JlYXRlVG9rZW5DbGFzcywgZmluZCwgaW5pdCwgbXVsdGksIG9wdGlvbnMsIHJlZ2V4cCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVnaXN0ZXJQbHVnaW4sIHJlZ2lzdGVyVG9rZW5QbHVnaW4sIHJlc2V0LCBzdHJpbmdUb0FycmF5LCB0ZXN0LCB0b2tlbml6ZSB9O1xuIl0sIm5hbWVzIjpbImVuY29kZWRUbGRzIiwiZW5jb2RlZFV0bGRzIiwiYXNzaWduIiwidGFyZ2V0IiwicHJvcGVydGllcyIsImtleSIsIm51bWVyaWMiLCJhc2NpaSIsImFscGhhIiwiYXNjaWludW1lcmljIiwiYWxwaGFudW1lcmljIiwiZG9tYWluIiwiZW1vamkiLCJzY2hlbWUiLCJzbGFzaHNjaGVtZSIsIndoaXRlc3BhY2UiLCJyZWdpc3Rlckdyb3VwIiwibmFtZSIsImdyb3VwcyIsImFkZFRvR3JvdXBzIiwidCIsImZsYWdzIiwiayIsImdyb3VwIiwiaW5kZXhPZiIsInB1c2giLCJmbGFnc0ZvclRva2VuIiwicmVzdWx0IiwiYyIsIlN0YXRlIiwidG9rZW4iLCJqIiwianIiLCJqZCIsInByb3RvdHlwZSIsImFjY2VwdHMiLCJnbyIsImlucHV0Iiwic3RhdGUiLCJuZXh0U3RhdGUiLCJpIiwibGVuZ3RoIiwicmVnZXgiLCJ0ZXN0IiwiaGFzIiwiZXhhY3RPbmx5IiwidGEiLCJpbnB1dHMiLCJuZXh0IiwidHQiLCJ0ciIsInJlZ2V4cCIsInRzIiwibGVuIiwidGVtcGxhdGVTdGF0ZSIsImFwcGx5IiwiYWxsRmxhZ3MiLCJXT1JEIiwiVVdPUkQiLCJMT0NBTEhPU1QiLCJUTEQiLCJVVExEIiwiU0NIRU1FIiwiU0xBU0hfU0NIRU1FIiwiTlVNIiwiV1MiLCJOTCQxIiwiT1BFTkJSQUNFIiwiQ0xPU0VCUkFDRSIsIk9QRU5CUkFDS0VUIiwiQ0xPU0VCUkFDS0VUIiwiT1BFTlBBUkVOIiwiQ0xPU0VQQVJFTiIsIk9QRU5BTkdMRUJSQUNLRVQiLCJDTE9TRUFOR0xFQlJBQ0tFVCIsIkZVTExXSURUSExFRlRQQVJFTiIsIkZVTExXSURUSFJJR0hUUEFSRU4iLCJMRUZUQ09STkVSQlJBQ0tFVCIsIlJJR0hUQ09STkVSQlJBQ0tFVCIsIkxFRlRXSElURUNPUk5FUkJSQUNLRVQiLCJSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCIsIkZVTExXSURUSExFU1NUSEFOIiwiRlVMTFdJRFRIR1JFQVRFUlRIQU4iLCJBTVBFUlNBTkQiLCJBUE9TVFJPUEhFIiwiQVNURVJJU0siLCJBVCIsIkJBQ0tTTEFTSCIsIkJBQ0tUSUNLIiwiQ0FSRVQiLCJDT0xPTiIsIkNPTU1BIiwiRE9MTEFSIiwiRE9UIiwiRVFVQUxTIiwiRVhDTEFNQVRJT04iLCJIWVBIRU4iLCJQRVJDRU5UIiwiUElQRSIsIlBMVVMiLCJQT1VORCIsIlFVRVJZIiwiUVVPVEUiLCJTRU1JIiwiU0xBU0giLCJUSUxERSIsIlVOREVSU0NPUkUiLCJFTU9KSSQxIiwiU1lNIiwidGsiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJOTCIsIkVNT0pJIiwiQVNDSUlfTEVUVEVSIiwiTEVUVEVSIiwiRU1PSklfVkFSSUFUSU9OJDEiLCJESUdJVCIsIlNQQUNFIiwiRU1PSklfVkFSSUFUSU9OIiwiRU1PSklfSk9JTkVSIiwidGxkcyIsInV0bGRzIiwiaW5pdCQyIiwiY3VzdG9tU2NoZW1lcyIsIlN0YXJ0IiwiZGVjb2RlVGxkcyIsIk51bSIsIldvcmQiLCJVV29yZCIsIldzIiwiRW1vamkiLCJFbW9qaUpvaW5lciIsIndvcmRqciIsInV3b3JkanIiLCJmYXN0dHMiLCJ0bGQiLCJ1dGxkIiwic29ydCIsImEiLCJiIiwic2NoIiwib3B0aW9uYWxTbGFzaFNsYXNoIiwic3RhcnQiLCJ0b2tlbnMiLCJydW4kMSIsInN0ciIsIml0ZXJhYmxlIiwic3RyaW5nVG9BcnJheSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImNoYXJDb3VudCIsImN1cnNvciIsImNoYXJDdXJzb3IiLCJ0b2tlbkxlbmd0aCIsImxhdGVzdEFjY2VwdGluZyIsInNpbmNlQWNjZXB0cyIsImNoYXJzU2luY2VBY2NlcHRzIiwidiIsInNsaWNlIiwicyIsImUiLCJpbmRleCIsImZpcnN0IiwiY2hhckNvZGVBdCIsInNlY29uZCIsImNoYXIiLCJkZWZhdWx0dCIsImVuY29kZWQiLCJ3b3JkcyIsInN0YWNrIiwiZGlnaXRzIiwicG9wRGlnaXRDb3VudCIsImpvaW4iLCJwb3BDb3VudCIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwicG9wIiwiZGVmYXVsdHMiLCJkZWZhdWx0UHJvdG9jb2wiLCJldmVudHMiLCJmb3JtYXQiLCJub29wIiwiZm9ybWF0SHJlZiIsIm5sMmJyIiwidGFnTmFtZSIsInJlbCIsInZhbGlkYXRlIiwidHJ1bmNhdGUiLCJJbmZpbml0eSIsImNsYXNzTmFtZSIsImF0dHJpYnV0ZXMiLCJpZ25vcmVUYWdzIiwicmVuZGVyIiwiT3B0aW9ucyIsIm9wdHMiLCJkZWZhdWx0UmVuZGVyIiwibyIsImlnbm9yZWRUYWdzIiwidXBwZXJjYXNlSWdub3JlZFRhZ3MiLCJ0b1VwcGVyQ2FzZSIsImlyIiwiY2hlY2siLCJnZXQiLCJ0b1N0cmluZyIsIm9wZXJhdG9yIiwiaXNDYWxsYWJsZSIsIm9wdGlvbiIsImdldE9iaiIsIm9iaiIsInJlbmRlckZuIiwidmFsIiwib3B0aW9ucyIsIk11bHRpVG9rZW4iLCJ2YWx1ZSIsImlzTGluayIsInRvSHJlZiIsInRvRm9ybWF0dGVkU3RyaW5nIiwiZm9ybWF0dGVkIiwidG9Gb3JtYXR0ZWRIcmVmIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwidG9PYmplY3QiLCJwcm90b2NvbCIsInR5cGUiLCJocmVmIiwiZW5kIiwidG9Gb3JtYXR0ZWRPYmplY3QiLCJmb3JtYXR0ZWRIcmVmIiwiY29udGVudCIsImF0dHJzIiwiZXZlbnRMaXN0ZW5lcnMiLCJjbGFzcyIsImNyZWF0ZVRva2VuQ2xhc3MiLCJwcm9wcyIsIlRva2VuIiwiY29uc3RydWN0b3IiLCJwIiwiRW1haWwiLCJUZXh0IiwiTmwiLCJVcmwiLCJoYXNQcm90b2NvbCIsIm11bHRpIiwiQmFzZSIsIm1ha2VTdGF0ZSIsImFyZyIsImluaXQkMSIsIl9yZWYiLCJxc0FjY2VwdGluZyIsImNvbmNhdCIsInFzTm9uQWNjZXB0aW5nIiwibG9jYWxwYXJ0QWNjZXB0aW5nIiwiTG9jYWxwYXJ0IiwiRG9tYWluIiwiU2NoZW1lIiwiU2xhc2hTY2hlbWUiLCJMb2NhbHBhcnRBdCIsIkxvY2FscGFydERvdCIsIkVtYWlsRG9tYWluIiwiRW1haWxEb21haW5Eb3QiLCJFbWFpbCQxIiwiRW1haWxEb21haW5IeXBoZW4iLCJFbWFpbENvbG9uIiwiRG9tYWluSHlwaGVuIiwiRG9tYWluRG90IiwiRG9tYWluRG90VGxkIiwiRG9tYWluRG90VGxkQ29sb24iLCJEb21haW5Eb3RUbGRDb2xvblBvcnQiLCJVcmwkMSIsIlVybE5vbmFjY2VwdCIsIlNjaGVtZUNvbG9uIiwiU2xhc2hTY2hlbWVDb2xvbiIsIlNsYXNoU2NoZW1lQ29sb25TbGFzaCIsIlVyaVByZWZpeCIsImJyYWNrZXRQYWlycyIsIk9QRU4iLCJDTE9TRSIsIlVybE9wZW4iLCJVcmxPcGVuUSIsIlVybE9wZW5TeW1zIiwicnVuIiwibXVsdGlzIiwidGV4dFRva2VucyIsInNlY29uZFN0YXRlIiwibXVsdGlMZW5ndGgiLCJpbml0TXVsdGlUb2tlbiIsIk11bHRpIiwic3VidG9rZW5zIiwic3RhcnRJZHgiLCJlbmRJZHgiLCJ3YXJuIiwiY29uc29sZSIsIndhcm5BZHZpY2UiLCJJTklUIiwic2Nhbm5lciIsInBhcnNlciIsInRva2VuUXVldWUiLCJwbHVnaW5RdWV1ZSIsImluaXRpYWxpemVkIiwicmVzZXQiLCJyZWdpc3RlclRva2VuUGx1Z2luIiwicGx1Z2luIiwiRXJyb3IiLCJyZWdpc3RlclBsdWdpbiIsInJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wiLCJpbml0IiwidG9rZW5pemUiLCJmaW5kIiwiZmlsdGVyZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/linkifyjs/dist/linkify.es.js\n");

/***/ })

};
;