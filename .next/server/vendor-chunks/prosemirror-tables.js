"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-tables";
exports.ids = ["vendor-chunks/prosemirror-tables"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-tables/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-tables/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellBookmark: () => (/* binding */ CellBookmark),\n/* harmony export */   CellSelection: () => (/* binding */ CellSelection),\n/* harmony export */   ResizeState: () => (/* binding */ ResizeState),\n/* harmony export */   TableMap: () => (/* binding */ TableMap),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   __clipCells: () => (/* binding */ clipCells),\n/* harmony export */   __insertCells: () => (/* binding */ insertCells),\n/* harmony export */   __pastedCells: () => (/* binding */ pastedCells),\n/* harmony export */   addColSpan: () => (/* binding */ addColSpan),\n/* harmony export */   addColumn: () => (/* binding */ addColumn),\n/* harmony export */   addColumnAfter: () => (/* binding */ addColumnAfter),\n/* harmony export */   addColumnBefore: () => (/* binding */ addColumnBefore),\n/* harmony export */   addRow: () => (/* binding */ addRow),\n/* harmony export */   addRowAfter: () => (/* binding */ addRowAfter),\n/* harmony export */   addRowBefore: () => (/* binding */ addRowBefore),\n/* harmony export */   cellAround: () => (/* binding */ cellAround),\n/* harmony export */   colCount: () => (/* binding */ colCount),\n/* harmony export */   columnIsHeader: () => (/* binding */ columnIsHeader),\n/* harmony export */   columnResizing: () => (/* binding */ columnResizing),\n/* harmony export */   columnResizingPluginKey: () => (/* binding */ columnResizingPluginKey),\n/* harmony export */   deleteColumn: () => (/* binding */ deleteColumn),\n/* harmony export */   deleteRow: () => (/* binding */ deleteRow),\n/* harmony export */   deleteTable: () => (/* binding */ deleteTable),\n/* harmony export */   findCell: () => (/* binding */ findCell),\n/* harmony export */   fixTables: () => (/* binding */ fixTables),\n/* harmony export */   fixTablesKey: () => (/* binding */ fixTablesKey),\n/* harmony export */   goToNextCell: () => (/* binding */ goToNextCell),\n/* harmony export */   handlePaste: () => (/* binding */ handlePaste),\n/* harmony export */   inSameTable: () => (/* binding */ inSameTable),\n/* harmony export */   isInTable: () => (/* binding */ isInTable),\n/* harmony export */   mergeCells: () => (/* binding */ mergeCells),\n/* harmony export */   moveCellForward: () => (/* binding */ moveCellForward),\n/* harmony export */   nextCell: () => (/* binding */ nextCell),\n/* harmony export */   pointsAtCell: () => (/* binding */ pointsAtCell),\n/* harmony export */   removeColSpan: () => (/* binding */ removeColSpan),\n/* harmony export */   removeColumn: () => (/* binding */ removeColumn),\n/* harmony export */   removeRow: () => (/* binding */ removeRow),\n/* harmony export */   rowIsHeader: () => (/* binding */ rowIsHeader),\n/* harmony export */   selectedRect: () => (/* binding */ selectedRect),\n/* harmony export */   selectionCell: () => (/* binding */ selectionCell),\n/* harmony export */   setCellAttr: () => (/* binding */ setCellAttr),\n/* harmony export */   splitCell: () => (/* binding */ splitCell),\n/* harmony export */   splitCellWithType: () => (/* binding */ splitCellWithType),\n/* harmony export */   tableEditing: () => (/* binding */ tableEditing),\n/* harmony export */   tableEditingKey: () => (/* binding */ tableEditingKey),\n/* harmony export */   tableNodeTypes: () => (/* binding */ tableNodeTypes),\n/* harmony export */   tableNodes: () => (/* binding */ tableNodes),\n/* harmony export */   toggleHeader: () => (/* binding */ toggleHeader),\n/* harmony export */   toggleHeaderCell: () => (/* binding */ toggleHeaderCell),\n/* harmony export */   toggleHeaderColumn: () => (/* binding */ toggleHeaderColumn),\n/* harmony export */   toggleHeaderRow: () => (/* binding */ toggleHeaderRow),\n/* harmony export */   updateColumnsOnResize: () => (/* binding */ updateColumnsOnResize)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// src/index.ts\n\n// src/cellselection.ts\n\n\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n    let cache = /* @__PURE__ */ new WeakMap();\n    readFromCache = (key)=>cache.get(key);\n    addToCache = (key, value)=>{\n        cache.set(key, value);\n        return value;\n    };\n} else {\n    const cache = [];\n    const cacheSize = 10;\n    let cachePos = 0;\n    readFromCache = (key)=>{\n        for(let i = 0; i < cache.length; i += 2)if (cache[i] == key) return cache[i + 1];\n    };\n    addToCache = (key, value)=>{\n        if (cachePos == cacheSize) cachePos = 0;\n        cache[cachePos++] = key;\n        return cache[cachePos++] = value;\n    };\n}\nvar TableMap = class {\n    constructor(width, height, map, problems){\n        this.width = width;\n        this.height = height;\n        this.map = map;\n        this.problems = problems;\n    }\n    // Find the dimensions of the cell at the given position.\n    findCell(pos) {\n        for(let i = 0; i < this.map.length; i++){\n            const curPos = this.map[i];\n            if (curPos != pos) continue;\n            const left = i % this.width;\n            const top = i / this.width | 0;\n            let right = left + 1;\n            let bottom = top + 1;\n            for(let j = 1; right < this.width && this.map[i + j] == curPos; j++){\n                right++;\n            }\n            for(let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++){\n                bottom++;\n            }\n            return {\n                left,\n                top,\n                right,\n                bottom\n            };\n        }\n        throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    // Find the left side of the cell at the given position.\n    colCount(pos) {\n        for(let i = 0; i < this.map.length; i++){\n            if (this.map[i] == pos) {\n                return i % this.width;\n            }\n        }\n        throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    // Find the next cell in the given direction, starting from the cell\n    // at `pos`, if any.\n    nextCell(pos, axis, dir) {\n        const { left, right, top, bottom } = this.findCell(pos);\n        if (axis == \"horiz\") {\n            if (dir < 0 ? left == 0 : right == this.width) return null;\n            return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n        } else {\n            if (dir < 0 ? top == 0 : bottom == this.height) return null;\n            return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n        }\n    }\n    // Get the rectangle spanning the two given cells.\n    rectBetween(a, b) {\n        const { left: leftA, right: rightA, top: topA, bottom: bottomA } = this.findCell(a);\n        const { left: leftB, right: rightB, top: topB, bottom: bottomB } = this.findCell(b);\n        return {\n            left: Math.min(leftA, leftB),\n            top: Math.min(topA, topB),\n            right: Math.max(rightA, rightB),\n            bottom: Math.max(bottomA, bottomB)\n        };\n    }\n    // Return the position of all cells that have the top left corner in\n    // the given rectangle.\n    cellsInRect(rect) {\n        const result = [];\n        const seen = {};\n        for(let row = rect.top; row < rect.bottom; row++){\n            for(let col = rect.left; col < rect.right; col++){\n                const index = row * this.width + col;\n                const pos = this.map[index];\n                if (seen[pos]) continue;\n                seen[pos] = true;\n                if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n                    continue;\n                }\n                result.push(pos);\n            }\n        }\n        return result;\n    }\n    // Return the position at which the cell at the given row and column\n    // starts, or would start, if a cell started there.\n    positionAt(row, col, table) {\n        for(let i = 0, rowStart = 0;; i++){\n            const rowEnd = rowStart + table.child(i).nodeSize;\n            if (i == row) {\n                let index = col + row * this.width;\n                const rowEndIndex = (row + 1) * this.width;\n                while(index < rowEndIndex && this.map[index] < rowStart)index++;\n                return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n            }\n            rowStart = rowEnd;\n        }\n    }\n    // Find the table map for the given table node.\n    static get(table) {\n        return readFromCache(table) || addToCache(table, computeMap(table));\n    }\n};\nfunction computeMap(table) {\n    if (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name);\n    const width = findWidth(table), height = table.childCount;\n    const map = [];\n    let mapPos = 0;\n    let problems = null;\n    const colWidths = [];\n    for(let i = 0, e = width * height; i < e; i++)map[i] = 0;\n    for(let row = 0, pos = 0; row < height; row++){\n        const rowNode = table.child(row);\n        pos++;\n        for(let i = 0;; i++){\n            while(mapPos < map.length && map[mapPos] != 0)mapPos++;\n            if (i == rowNode.childCount) break;\n            const cellNode = rowNode.child(i);\n            const { colspan, rowspan, colwidth } = cellNode.attrs;\n            for(let h = 0; h < rowspan; h++){\n                if (h + row >= height) {\n                    (problems || (problems = [])).push({\n                        type: \"overlong_rowspan\",\n                        pos,\n                        n: rowspan - h\n                    });\n                    break;\n                }\n                const start = mapPos + h * width;\n                for(let w = 0; w < colspan; w++){\n                    if (map[start + w] == 0) map[start + w] = pos;\n                    else (problems || (problems = [])).push({\n                        type: \"collision\",\n                        row,\n                        pos,\n                        n: colspan - w\n                    });\n                    const colW = colwidth && colwidth[w];\n                    if (colW) {\n                        const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n                        if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n                            colWidths[widthIndex] = colW;\n                            colWidths[widthIndex + 1] = 1;\n                        } else if (prev == colW) {\n                            colWidths[widthIndex + 1]++;\n                        }\n                    }\n                }\n            }\n            mapPos += colspan;\n            pos += cellNode.nodeSize;\n        }\n        const expectedPos = (row + 1) * width;\n        let missing = 0;\n        while(mapPos < expectedPos)if (map[mapPos++] == 0) missing++;\n        if (missing) (problems || (problems = [])).push({\n            type: \"missing\",\n            row,\n            n: missing\n        });\n        pos++;\n    }\n    const tableMap = new TableMap(width, height, map, problems);\n    let badWidths = false;\n    for(let i = 0; !badWidths && i < colWidths.length; i += 2)if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n    if (badWidths) findBadColWidths(tableMap, colWidths, table);\n    return tableMap;\n}\nfunction findWidth(table) {\n    let width = -1;\n    let hasRowSpan = false;\n    for(let row = 0; row < table.childCount; row++){\n        const rowNode = table.child(row);\n        let rowWidth = 0;\n        if (hasRowSpan) for(let j = 0; j < row; j++){\n            const prevRow = table.child(j);\n            for(let i = 0; i < prevRow.childCount; i++){\n                const cell = prevRow.child(i);\n                if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n            }\n        }\n        for(let i = 0; i < rowNode.childCount; i++){\n            const cell = rowNode.child(i);\n            rowWidth += cell.attrs.colspan;\n            if (cell.attrs.rowspan > 1) hasRowSpan = true;\n        }\n        if (width == -1) width = rowWidth;\n        else if (width != rowWidth) width = Math.max(width, rowWidth);\n    }\n    return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n    if (!map.problems) map.problems = [];\n    const seen = {};\n    for(let i = 0; i < map.map.length; i++){\n        const pos = map.map[i];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const node = table.nodeAt(pos);\n        if (!node) {\n            throw new RangeError(`No cell with offset ${pos} found`);\n        }\n        let updated = null;\n        const attrs = node.attrs;\n        for(let j = 0; j < attrs.colspan; j++){\n            const col = (i + j) % map.width;\n            const colWidth = colWidths[col * 2];\n            if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n        }\n        if (updated) map.problems.unshift({\n            type: \"colwidth mismatch\",\n            pos,\n            colwidth: updated\n        });\n    }\n}\nfunction freshColWidth(attrs) {\n    if (attrs.colwidth) return attrs.colwidth.slice();\n    const result = [];\n    for(let i = 0; i < attrs.colspan; i++)result.push(0);\n    return result;\n}\n// src/util.ts\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n    if (typeof dom === \"string\") {\n        return {};\n    }\n    const widthAttr = dom.getAttribute(\"data-colwidth\");\n    const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s)=>Number(s)) : null;\n    const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n    const result = {\n        colspan,\n        rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n        colwidth: widths && widths.length == colspan ? widths : null\n    };\n    for(const prop in extraAttrs){\n        const getter = extraAttrs[prop].getFromDOM;\n        const value = getter && getter(dom);\n        if (value != null) {\n            result[prop] = value;\n        }\n    }\n    return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n    const attrs = {};\n    if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n    if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n    if (node.attrs.colwidth) attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n    for(const prop in extraAttrs){\n        const setter = extraAttrs[prop].setDOMAttr;\n        if (setter) setter(node.attrs[prop], attrs);\n    }\n    return attrs;\n}\nfunction tableNodes(options) {\n    const extraAttrs = options.cellAttributes || {};\n    const cellAttrs = {\n        colspan: {\n            default: 1\n        },\n        rowspan: {\n            default: 1\n        },\n        colwidth: {\n            default: null\n        }\n    };\n    for(const prop in extraAttrs)cellAttrs[prop] = {\n        default: extraAttrs[prop].default\n    };\n    return {\n        table: {\n            content: \"table_row+\",\n            tableRole: \"table\",\n            isolating: true,\n            group: options.tableGroup,\n            parseDOM: [\n                {\n                    tag: \"table\"\n                }\n            ],\n            toDOM () {\n                return [\n                    \"table\",\n                    [\n                        \"tbody\",\n                        0\n                    ]\n                ];\n            }\n        },\n        table_row: {\n            content: \"(table_cell | table_header)*\",\n            tableRole: \"row\",\n            parseDOM: [\n                {\n                    tag: \"tr\"\n                }\n            ],\n            toDOM () {\n                return [\n                    \"tr\",\n                    0\n                ];\n            }\n        },\n        table_cell: {\n            content: options.cellContent,\n            attrs: cellAttrs,\n            tableRole: \"cell\",\n            isolating: true,\n            parseDOM: [\n                {\n                    tag: \"td\",\n                    getAttrs: (dom)=>getCellAttrs(dom, extraAttrs)\n                }\n            ],\n            toDOM (node) {\n                return [\n                    \"td\",\n                    setCellAttrs(node, extraAttrs),\n                    0\n                ];\n            }\n        },\n        table_header: {\n            content: options.cellContent,\n            attrs: cellAttrs,\n            tableRole: \"header_cell\",\n            isolating: true,\n            parseDOM: [\n                {\n                    tag: \"th\",\n                    getAttrs: (dom)=>getCellAttrs(dom, extraAttrs)\n                }\n            ],\n            toDOM (node) {\n                return [\n                    \"th\",\n                    setCellAttrs(node, extraAttrs),\n                    0\n                ];\n            }\n        }\n    };\n}\nfunction tableNodeTypes(schema) {\n    let result = schema.cached.tableNodeTypes;\n    if (!result) {\n        result = schema.cached.tableNodeTypes = {};\n        for(const name in schema.nodes){\n            const type = schema.nodes[name], role = type.spec.tableRole;\n            if (role) result[role] = type;\n        }\n    }\n    return result;\n}\n// src/util.ts\nvar tableEditingKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n    for(let d = $pos.depth - 1; d > 0; d--)if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1));\n    return null;\n}\nfunction cellWrapping($pos) {\n    for(let d = $pos.depth; d > 0; d--){\n        const role = $pos.node(d).type.spec.tableRole;\n        if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n    }\n    return null;\n}\nfunction isInTable(state) {\n    const $head = state.selection.$head;\n    for(let d = $head.depth; d > 0; d--)if ($head.node(d).type.spec.tableRole == \"row\") return true;\n    return false;\n}\nfunction selectionCell(state) {\n    const sel = state.selection;\n    if (\"$anchorCell\" in sel && sel.$anchorCell) {\n        return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n    } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n        return sel.$anchor;\n    }\n    const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n    if ($cell) {\n        return $cell;\n    }\n    throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n    for(let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++){\n        const role = after.type.spec.tableRole;\n        if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n    }\n    for(let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--){\n        const role = before.type.spec.tableRole;\n        if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize);\n    }\n}\nfunction pointsAtCell($pos) {\n    return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n    return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n    return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n    return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n    return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n    const table = $pos.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $pos.start(-1);\n    const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n    return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n    const result = {\n        ...attrs,\n        colspan: attrs.colspan - n\n    };\n    if (result.colwidth) {\n        result.colwidth = result.colwidth.slice();\n        result.colwidth.splice(pos, n);\n        if (!result.colwidth.some((w)=>w > 0)) result.colwidth = null;\n    }\n    return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n    const result = {\n        ...attrs,\n        colspan: attrs.colspan + n\n    };\n    if (result.colwidth) {\n        result.colwidth = result.colwidth.slice();\n        for(let i = 0; i < n; i++)result.colwidth.splice(pos, 0, 0);\n    }\n    return result;\n}\nfunction columnIsHeader(map, table, col) {\n    const headerCell = tableNodeTypes(table.type.schema).header_cell;\n    for(let row = 0; row < map.height; row++)if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n    return true;\n}\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    // A table selection is identified by its anchor and head cells. The\n    // positions given to this constructor should point _before_ two\n    // cells in the same table. They may be the same, to select a single\n    // cell.\n    constructor($anchorCell, $headCell = $anchorCell){\n        const table = $anchorCell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $anchorCell.start(-1);\n        const rect = map.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);\n        const doc = $anchorCell.node(0);\n        const cells = map.cellsInRect(rect).filter((p)=>p != $headCell.pos - tableStart);\n        cells.unshift($headCell.pos - tableStart);\n        const ranges = cells.map((pos)=>{\n            const cell = table.nodeAt(pos);\n            if (!cell) {\n                throw RangeError(`No cell with offset ${pos} found`);\n            }\n            const from = tableStart + pos + 1;\n            return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n        });\n        super(ranges[0].$from, ranges[0].$to, ranges);\n        this.$anchorCell = $anchorCell;\n        this.$headCell = $headCell;\n    }\n    map(doc, mapping) {\n        const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n        const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n        if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n            const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n            if (tableChanged && this.isRowSelection()) return _CellSelection.rowSelection($anchorCell, $headCell);\n            else if (tableChanged && this.isColSelection()) return _CellSelection.colSelection($anchorCell, $headCell);\n            else return new _CellSelection($anchorCell, $headCell);\n        }\n        return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchorCell, $headCell);\n    }\n    // Returns a rectangular slice of table rows containing the selected\n    // cells.\n    content() {\n        const table = this.$anchorCell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = this.$anchorCell.start(-1);\n        const rect = map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);\n        const seen = {};\n        const rows = [];\n        for(let row = rect.top; row < rect.bottom; row++){\n            const rowContent = [];\n            for(let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++){\n                const pos = map.map[index];\n                if (seen[pos]) continue;\n                seen[pos] = true;\n                const cellRect = map.findCell(pos);\n                let cell = table.nodeAt(pos);\n                if (!cell) {\n                    throw RangeError(`No cell with offset ${pos} found`);\n                }\n                const extraLeft = rect.left - cellRect.left;\n                const extraRight = cellRect.right - rect.right;\n                if (extraLeft > 0 || extraRight > 0) {\n                    let attrs = cell.attrs;\n                    if (extraLeft > 0) {\n                        attrs = removeColSpan(attrs, 0, extraLeft);\n                    }\n                    if (extraRight > 0) {\n                        attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n                    }\n                    if (cellRect.left < rect.left) {\n                        cell = cell.type.createAndFill(attrs);\n                        if (!cell) {\n                            throw RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`);\n                        }\n                    } else {\n                        cell = cell.type.create(attrs, cell.content);\n                    }\n                }\n                if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n                    const attrs = {\n                        ...cell.attrs,\n                        rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n                    };\n                    if (cellRect.top < rect.top) {\n                        cell = cell.type.createAndFill(attrs);\n                    } else {\n                        cell = cell.type.create(attrs, cell.content);\n                    }\n                }\n                rowContent.push(cell);\n            }\n            rows.push(table.child(row).copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(rowContent)));\n        }\n        const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment), 1, 1);\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty) {\n        const mapFrom = tr.steps.length, ranges = this.ranges;\n        for(let i = 0; i < ranges.length; i++){\n            const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty : content);\n        }\n        const sel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n        if (sel) tr.setSelection(sel);\n    }\n    replaceWith(tr, node) {\n        this.replace(tr, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n    }\n    forEachCell(f) {\n        const table = this.$anchorCell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = this.$anchorCell.start(-1);\n        const cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));\n        for(let i = 0; i < cells.length; i++){\n            f(table.nodeAt(cells[i]), tableStart + cells[i]);\n        }\n    }\n    // True if this selection goes all the way from the top to the\n    // bottom of the table.\n    isColSelection() {\n        const anchorTop = this.$anchorCell.index(-1);\n        const headTop = this.$headCell.index(-1);\n        if (Math.min(anchorTop, headTop) > 0) return false;\n        const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n        const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n        return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n    }\n    // Returns the smallest column selection that covers the given anchor\n    // and head cell.\n    static colSelection($anchorCell, $headCell = $anchorCell) {\n        const table = $anchorCell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $anchorCell.start(-1);\n        const anchorRect = map.findCell($anchorCell.pos - tableStart);\n        const headRect = map.findCell($headCell.pos - tableStart);\n        const doc = $anchorCell.node(0);\n        if (anchorRect.top <= headRect.top) {\n            if (anchorRect.top > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n            if (headRect.bottom < map.height) $headCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n        } else {\n            if (headRect.top > 0) $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n            if (anchorRect.bottom < map.height) $anchorCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n        }\n        return new _CellSelection($anchorCell, $headCell);\n    }\n    // True if this selection goes all the way from the left to the\n    // right of the table.\n    isRowSelection() {\n        const table = this.$anchorCell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = this.$anchorCell.start(-1);\n        const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n        const headLeft = map.colCount(this.$headCell.pos - tableStart);\n        if (Math.min(anchorLeft, headLeft) > 0) return false;\n        const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n        const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n        return Math.max(anchorRight, headRight) == map.width;\n    }\n    eq(other) {\n        return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n    }\n    // Returns the smallest row selection that covers the given anchor\n    // and head cell.\n    static rowSelection($anchorCell, $headCell = $anchorCell) {\n        const table = $anchorCell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $anchorCell.start(-1);\n        const anchorRect = map.findCell($anchorCell.pos - tableStart);\n        const headRect = map.findCell($headCell.pos - tableStart);\n        const doc = $anchorCell.node(0);\n        if (anchorRect.left <= headRect.left) {\n            if (anchorRect.left > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.top * map.width]);\n            if (headRect.right < map.width) $headCell = doc.resolve(tableStart + map.map[map.width * (headRect.top + 1) - 1]);\n        } else {\n            if (headRect.left > 0) $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n            if (anchorRect.right < map.width) $anchorCell = doc.resolve(tableStart + map.map[map.width * (anchorRect.top + 1) - 1]);\n        }\n        return new _CellSelection($anchorCell, $headCell);\n    }\n    toJSON() {\n        return {\n            type: \"cell\",\n            anchor: this.$anchorCell.pos,\n            head: this.$headCell.pos\n        };\n    }\n    static fromJSON(doc, json) {\n        return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    static create(doc, anchorCell, headCell = anchorCell) {\n        return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n    }\n    getBookmark() {\n        return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n    }\n};\nCellSelection.prototype.visible = false;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n    constructor(anchor, head){\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n        if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);\n        else return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($headCell, 1);\n    }\n};\nfunction drawCellSelection(state) {\n    if (!(state.selection instanceof CellSelection)) return null;\n    const cells = [];\n    state.selection.forEachCell((node, pos)=>{\n        cells.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(pos, pos + node.nodeSize, {\n            class: \"selectedCell\"\n        }));\n    });\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n    if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false;\n    let afterFrom = $from.pos;\n    let beforeTo = $to.pos;\n    let depth = $from.depth;\n    for(; depth >= 0; depth--, afterFrom++)if ($from.after(depth + 1) < $from.end(depth)) break;\n    for(let d = $to.depth; d >= 0; d--, beforeTo--)if ($to.before(d + 1) > $to.start(d)) break;\n    return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n    let fromCellBoundaryNode;\n    let toCellBoundaryNode;\n    for(let i = $from.depth; i > 0; i--){\n        const node = $from.node(i);\n        if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n            fromCellBoundaryNode = node;\n            break;\n        }\n    }\n    for(let i = $to.depth; i > 0; i--){\n        const node = $to.node(i);\n        if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n            toCellBoundaryNode = node;\n            break;\n        }\n    }\n    return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n    const sel = (tr || state).selection;\n    const doc = (tr || state).doc;\n    let normalize;\n    let role;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && (role = sel.node.type.spec.tableRole)) {\n        if (role == \"cell\" || role == \"header_cell\") {\n            normalize = CellSelection.create(doc, sel.from);\n        } else if (role == \"row\") {\n            const $cell = doc.resolve(sel.from + 1);\n            normalize = CellSelection.rowSelection($cell, $cell);\n        } else if (!allowTableNodeSelection) {\n            const map = TableMap.get(sel.node);\n            const start = sel.from + 1;\n            const lastCell = start + map.map[map.width * map.height - 1];\n            normalize = CellSelection.create(doc, start + 1, lastCell);\n        }\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isCellBoundarySelection(sel)) {\n        normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.from);\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isTextSelectionAcrossCells(sel)) {\n        normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n    }\n    if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n    return tr;\n}\n// src/fixtables.ts\n\nvar fixTablesKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n    const oldSize = old.childCount, curSize = cur.childCount;\n    outer: for(let i = 0, j = 0; i < curSize; i++){\n        const child = cur.child(i);\n        for(let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++){\n            if (old.child(scan) == child) {\n                j = scan + 1;\n                offset += child.nodeSize;\n                continue outer;\n            }\n        }\n        f(child, offset);\n        if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);\n        else child.nodesBetween(0, child.content.size, f, offset + 1);\n        offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n    let tr;\n    const check = (node, pos)=>{\n        if (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr);\n    };\n    if (!oldState) state.doc.descendants(check);\n    else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n    return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n    const map = TableMap.get(table);\n    if (!map.problems) return tr;\n    if (!tr) tr = state.tr;\n    const mustAdd = [];\n    for(let i = 0; i < map.height; i++)mustAdd.push(0);\n    for(let i = 0; i < map.problems.length; i++){\n        const prob = map.problems[i];\n        if (prob.type == \"collision\") {\n            const cell = table.nodeAt(prob.pos);\n            if (!cell) continue;\n            const attrs = cell.attrs;\n            for(let j = 0; j < attrs.rowspan; j++)mustAdd[prob.row + j] += prob.n;\n            tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));\n        } else if (prob.type == \"missing\") {\n            mustAdd[prob.row] += prob.n;\n        } else if (prob.type == \"overlong_rowspan\") {\n            const cell = table.nodeAt(prob.pos);\n            if (!cell) continue;\n            tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n                ...cell.attrs,\n                rowspan: cell.attrs.rowspan - prob.n\n            });\n        } else if (prob.type == \"colwidth mismatch\") {\n            const cell = table.nodeAt(prob.pos);\n            if (!cell) continue;\n            tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n                ...cell.attrs,\n                colwidth: prob.colwidth\n            });\n        }\n    }\n    let first, last;\n    for(let i = 0; i < mustAdd.length; i++)if (mustAdd[i]) {\n        if (first == null) first = i;\n        last = i;\n    }\n    for(let i = 0, pos = tablePos + 1; i < map.height; i++){\n        const row = table.child(i);\n        const end = pos + row.nodeSize;\n        const add = mustAdd[i];\n        if (add > 0) {\n            let role = \"cell\";\n            if (row.firstChild) {\n                role = row.firstChild.type.spec.tableRole;\n            }\n            const nodes = [];\n            for(let j = 0; j < add; j++){\n                const node = tableNodeTypes(state.schema)[role].createAndFill();\n                if (node) nodes.push(node);\n            }\n            const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n            tr.insert(tr.mapping.map(side), nodes);\n        }\n        pos = end;\n    }\n    return tr.setMeta(fixTablesKey, {\n        fixTables: true\n    });\n}\n// src/input.ts\n\n\n\n// src/copypaste.ts\n\n\nfunction pastedCells(slice) {\n    if (!slice.size) return null;\n    let { content, openStart, openEnd } = slice;\n    while(content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")){\n        openStart--;\n        openEnd--;\n        content = content.child(0).content;\n    }\n    const first = content.child(0);\n    const role = first.type.spec.tableRole;\n    const schema = first.type.schema, rows = [];\n    if (role == \"row\") {\n        for(let i = 0; i < content.childCount; i++){\n            let cells = content.child(i).content;\n            const left = i ? 0 : Math.max(0, openStart - 1);\n            const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n            if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells, left, right)).content;\n            rows.push(cells);\n        }\n    } else if (role == \"cell\" || role == \"header_cell\") {\n        rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)).content : content);\n    } else {\n        return null;\n    }\n    return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n    const widths = [];\n    for(let i = 0; i < rows.length; i++){\n        const row = rows[i];\n        for(let j = row.childCount - 1; j >= 0; j--){\n            const { rowspan, colspan } = row.child(j).attrs;\n            for(let r = i; r < i + rowspan; r++)widths[r] = (widths[r] || 0) + colspan;\n        }\n    }\n    let width = 0;\n    for(let r = 0; r < widths.length; r++)width = Math.max(width, widths[r]);\n    for(let r = 0; r < widths.length; r++){\n        if (r >= rows.length) rows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty);\n        if (widths[r] < width) {\n            const empty = tableNodeTypes(schema).cell.createAndFill();\n            const cells = [];\n            for(let i = widths[r]; i < width; i++){\n                cells.push(empty);\n            }\n            rows[r] = rows[r].append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n        }\n    }\n    return {\n        height: rows.length,\n        width,\n        rows\n    };\n}\nfunction fitSlice(nodeType, slice) {\n    const node = nodeType.createAndFill();\n    const tr = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.Transform(node).replace(0, node.content.size, slice);\n    return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n    if (width != newWidth) {\n        const added = [];\n        const newRows = [];\n        for(let row = 0; row < rows.length; row++){\n            const frag = rows[row], cells = [];\n            for(let col = added[row] || 0, i = 0; col < newWidth; i++){\n                let cell = frag.child(i % frag.childCount);\n                if (col + cell.attrs.colspan > newWidth) cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n                cells.push(cell);\n                col += cell.attrs.colspan;\n                for(let j = 1; j < cell.attrs.rowspan; j++)added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n            }\n            newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n        }\n        rows = newRows;\n        width = newWidth;\n    }\n    if (height != newHeight) {\n        const newRows = [];\n        for(let row = 0, i = 0; row < newHeight; row++, i++){\n            const cells = [], source = rows[i % height];\n            for(let j = 0; j < source.childCount; j++){\n                let cell = source.child(j);\n                if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create({\n                    ...cell.attrs,\n                    rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n                }, cell.content);\n                cells.push(cell);\n            }\n            newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n        }\n        rows = newRows;\n        height = newHeight;\n    }\n    return {\n        width,\n        height,\n        rows\n    };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n    const schema = tr.doc.type.schema;\n    const types = tableNodeTypes(schema);\n    let empty;\n    let emptyHead;\n    if (width > map.width) {\n        for(let row = 0, rowEnd = 0; row < map.height; row++){\n            const rowNode = table.child(row);\n            rowEnd += rowNode.nodeSize;\n            const cells = [];\n            let add;\n            if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());\n            else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n            for(let i = map.width; i < width; i++)cells.push(add);\n            tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n        }\n    }\n    if (height > map.height) {\n        const cells = [];\n        for(let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++){\n            const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n            cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n        }\n        const emptyRow = types.row.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells)), rows = [];\n        for(let i = map.height; i < height; i++)rows.push(emptyRow);\n        tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n    }\n    return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n    if (top == 0 || top == map.height) return false;\n    let found = false;\n    for(let col = left; col < right; col++){\n        const index = top * map.width + col, pos = map.map[index];\n        if (map.map[index - map.width] == pos) {\n            found = true;\n            const cell = table.nodeAt(pos);\n            const { top: cellTop, left: cellLeft } = map.findCell(pos);\n            tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n                ...cell.attrs,\n                rowspan: top - cellTop\n            });\n            tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill({\n                ...cell.attrs,\n                rowspan: cellTop + cell.attrs.rowspan - top\n            }));\n            col += cell.attrs.colspan - 1;\n        }\n    }\n    return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n    if (left == 0 || left == map.width) return false;\n    let found = false;\n    for(let row = top; row < bottom; row++){\n        const index = row * map.width + left, pos = map.map[index];\n        if (map.map[index - 1] == pos) {\n            found = true;\n            const cell = table.nodeAt(pos);\n            const cellLeft = map.colCount(pos);\n            const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n            tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n            tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n            row += cell.attrs.rowspan - 1;\n        }\n    }\n    return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n    let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n    if (!table) {\n        throw new Error(\"No table found\");\n    }\n    let map = TableMap.get(table);\n    const { top, left } = rect;\n    const right = left + cells.width, bottom = top + cells.height;\n    const tr = state.tr;\n    let mapFrom = 0;\n    function recomp() {\n        table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n        if (!table) {\n            throw new Error(\"No table found\");\n        }\n        map = TableMap.get(table);\n        mapFrom = tr.mapping.maps.length;\n    }\n    if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n    if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n    if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n    if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n    if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n    for(let row = top; row < bottom; row++){\n        const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n        tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells.rows[row - top], 0, 0));\n    }\n    recomp();\n    tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n    dispatch(tr);\n}\n// src/input.ts\nvar handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__.keydownHandler)({\n    ArrowLeft: arrow(\"horiz\", -1),\n    ArrowRight: arrow(\"horiz\", 1),\n    ArrowUp: arrow(\"vert\", -1),\n    ArrowDown: arrow(\"vert\", 1),\n    \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n    \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n    \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n    \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n    Backspace: deleteCellSelection,\n    \"Mod-Backspace\": deleteCellSelection,\n    Delete: deleteCellSelection,\n    \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n    if (selection.eq(state.selection)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n    return true;\n}\nfunction arrow(axis, dir) {\n    return (state, dispatch, view)=>{\n        if (!view) return false;\n        const sel = state.selection;\n        if (sel instanceof CellSelection) {\n            return maybeSetSelection(state, dispatch, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(sel.$headCell, dir));\n        }\n        if (axis != \"horiz\" && !sel.empty) return false;\n        const end = atEndOfCell(view, axis, dir);\n        if (end == null) return false;\n        if (axis == \"horiz\") {\n            return maybeSetSelection(state, dispatch, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve(sel.head + dir), dir));\n        } else {\n            const $cell = state.doc.resolve(end);\n            const $next = nextCell($cell, axis, dir);\n            let newSel;\n            if ($next) newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($next, 1);\n            else if (dir < 0) newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.before(-1)), -1);\n            else newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.after(-1)), 1);\n            return maybeSetSelection(state, dispatch, newSel);\n        }\n    };\n}\nfunction shiftArrow(axis, dir) {\n    return (state, dispatch, view)=>{\n        if (!view) return false;\n        const sel = state.selection;\n        let cellSel;\n        if (sel instanceof CellSelection) {\n            cellSel = sel;\n        } else {\n            const end = atEndOfCell(view, axis, dir);\n            if (end == null) return false;\n            cellSel = new CellSelection(state.doc.resolve(end));\n        }\n        const $head = nextCell(cellSel.$headCell, axis, dir);\n        if (!$head) return false;\n        return maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));\n    };\n}\nfunction deleteCellSelection(state, dispatch) {\n    const sel = state.selection;\n    if (!(sel instanceof CellSelection)) return false;\n    if (dispatch) {\n        const tr = state.tr;\n        const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n        sel.forEachCell((cell, pos)=>{\n            if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(baseContent, 0, 0));\n        });\n        if (tr.docChanged) dispatch(tr);\n    }\n    return true;\n}\nfunction handleTripleClick(view, pos) {\n    const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n    if (!$cell) return false;\n    view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n    return true;\n}\nfunction handlePaste(view, _, slice) {\n    if (!isInTable(view.state)) return false;\n    let cells = pastedCells(slice);\n    const sel = view.state.selection;\n    if (sel instanceof CellSelection) {\n        if (!cells) cells = {\n            width: 1,\n            height: 1,\n            rows: [\n                prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))\n            ]\n        };\n        const table = sel.$anchorCell.node(-1);\n        const start = sel.$anchorCell.start(-1);\n        const rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n        cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n        insertCells(view.state, view.dispatch, start, rect, cells);\n        return true;\n    } else if (cells) {\n        const $cell = selectionCell(view.state);\n        const start = $cell.start(-1);\n        insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction handleMouseDown(view, startEvent) {\n    var _a;\n    if (startEvent.ctrlKey || startEvent.metaKey) return;\n    const startDOMCell = domInCell(view, startEvent.target);\n    let $anchor;\n    if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n        setCellSelection(view.state.selection.$anchorCell, startEvent);\n        startEvent.preventDefault();\n    } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n        setCellSelection($anchor, startEvent);\n        startEvent.preventDefault();\n    } else if (!startDOMCell) {\n        return;\n    }\n    function setCellSelection($anchor2, event) {\n        let $head = cellUnderMouse(view, event);\n        const starting = tableEditingKey.getState(view.state) == null;\n        if (!$head || !inSameTable($anchor2, $head)) {\n            if (starting) $head = $anchor2;\n            else return;\n        }\n        const selection = new CellSelection($anchor2, $head);\n        if (starting || !view.state.selection.eq(selection)) {\n            const tr = view.state.tr.setSelection(selection);\n            if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n            view.dispatch(tr);\n        }\n    }\n    function stop() {\n        view.root.removeEventListener(\"mouseup\", stop);\n        view.root.removeEventListener(\"dragstart\", stop);\n        view.root.removeEventListener(\"mousemove\", move);\n        if (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n    }\n    function move(_event) {\n        const event = _event;\n        const anchor = tableEditingKey.getState(view.state);\n        let $anchor2;\n        if (anchor != null) {\n            $anchor2 = view.state.doc.resolve(anchor);\n        } else if (domInCell(view, event.target) != startDOMCell) {\n            $anchor2 = cellUnderMouse(view, startEvent);\n            if (!$anchor2) return stop();\n        }\n        if ($anchor2) setCellSelection($anchor2, event);\n    }\n    view.root.addEventListener(\"mouseup\", stop);\n    view.root.addEventListener(\"dragstart\", stop);\n    view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) return null;\n    const { $head } = view.state.selection;\n    for(let d = $head.depth - 1; d >= 0; d--){\n        const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n        if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n        if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n            const cellPos = $head.before(d);\n            const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n            return view.endOfTextblock(dirStr) ? cellPos : null;\n        }\n    }\n    return null;\n}\nfunction domInCell(view, dom) {\n    for(; dom && dom != view.dom; dom = dom.parentNode){\n        if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n            return dom;\n        }\n    }\n    return null;\n}\nfunction cellUnderMouse(view, event) {\n    const mousePos = view.posAtCoords({\n        left: event.clientX,\n        top: event.clientY\n    });\n    if (!mousePos) return null;\n    return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n// src/columnresizing.ts\n\n\n// src/tableview.ts\nvar TableView = class {\n    constructor(node, cellMinWidth){\n        this.node = node;\n        this.cellMinWidth = cellMinWidth;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"tableWrapper\";\n        this.table = this.dom.appendChild(document.createElement(\"table\"));\n        this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n        updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n        this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n    }\n    update(node) {\n        if (node.type != this.node.type) return false;\n        this.node = node;\n        updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n        return true;\n    }\n    ignoreMutation(record) {\n        return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n    }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n    var _a;\n    let totalWidth = 0;\n    let fixedWidth = true;\n    let nextDOM = colgroup.firstChild;\n    const row = node.firstChild;\n    if (!row) return;\n    for(let i = 0, col = 0; i < row.childCount; i++){\n        const { colspan, colwidth } = row.child(i).attrs;\n        for(let j = 0; j < colspan; j++, col++){\n            const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n            const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) fixedWidth = false;\n            if (!nextDOM) {\n                colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n            } else {\n                if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n                nextDOM = nextDOM.nextSibling;\n            }\n        }\n    }\n    while(nextDOM){\n        const after = nextDOM.nextSibling;\n        (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n        nextDOM = after;\n    }\n    if (fixedWidth) {\n        table.style.width = totalWidth + \"px\";\n        table.style.minWidth = \"\";\n    } else {\n        table.style.width = \"\";\n        table.style.minWidth = totalWidth + \"px\";\n    }\n}\n// src/columnresizing.ts\nvar columnResizingPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tableColumnResizing\");\nfunction columnResizing({ handleWidth = 5, cellMinWidth = 25, View = TableView, lastColumnResizable = true } = {}) {\n    const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: columnResizingPluginKey,\n        state: {\n            init (_, state) {\n                plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view)=>new View(node, cellMinWidth, view);\n                return new ResizeState(-1, false);\n            },\n            apply (tr, prev) {\n                return prev.apply(tr);\n            }\n        },\n        props: {\n            attributes: (state)=>{\n                const pluginState = columnResizingPluginKey.getState(state);\n                return pluginState && pluginState.activeHandle > -1 ? {\n                    class: \"resize-cursor\"\n                } : {};\n            },\n            handleDOMEvents: {\n                mousemove: (view, event)=>{\n                    handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);\n                },\n                mouseleave: (view)=>{\n                    handleMouseLeave(view);\n                },\n                mousedown: (view, event)=>{\n                    handleMouseDown2(view, event, cellMinWidth);\n                }\n            },\n            decorations: (state)=>{\n                const pluginState = columnResizingPluginKey.getState(state);\n                if (pluginState && pluginState.activeHandle > -1) {\n                    return handleDecorations(state, pluginState.activeHandle);\n                }\n            },\n            nodeViews: {}\n        }\n    });\n    return plugin;\n}\nvar ResizeState = class _ResizeState {\n    constructor(activeHandle, dragging){\n        this.activeHandle = activeHandle;\n        this.dragging = dragging;\n    }\n    apply(tr) {\n        const state = this;\n        const action = tr.getMeta(columnResizingPluginKey);\n        if (action && action.setHandle != null) return new _ResizeState(action.setHandle, false);\n        if (action && action.setDragging !== void 0) return new _ResizeState(state.activeHandle, action.setDragging);\n        if (state.activeHandle > -1 && tr.docChanged) {\n            let handle = tr.mapping.map(state.activeHandle, -1);\n            if (!pointsAtCell(tr.doc.resolve(handle))) {\n                handle = -1;\n            }\n            return new _ResizeState(handle, state.dragging);\n        }\n        return state;\n    }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (!pluginState) return;\n    if (!pluginState.dragging) {\n        const target = domCellAround(event.target);\n        let cell = -1;\n        if (target) {\n            const { left, right } = target.getBoundingClientRect();\n            if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, \"left\", handleWidth);\n            else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, \"right\", handleWidth);\n        }\n        if (cell != pluginState.activeHandle) {\n            if (!lastColumnResizable && cell !== -1) {\n                const $cell = view.state.doc.resolve(cell);\n                const table = $cell.node(-1);\n                const map = TableMap.get(table);\n                const tableStart = $cell.start(-1);\n                const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n                if (col == map.width - 1) {\n                    return;\n                }\n            }\n            updateHandle(view, cell);\n        }\n    }\n}\nfunction handleMouseLeave(view) {\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n    const pluginState = columnResizingPluginKey.getState(view.state);\n    if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging) return false;\n    const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n    const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n    view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n        setDragging: {\n            startX: event.clientX,\n            startWidth: width\n        }\n    }));\n    function finish(event2) {\n        window.removeEventListener(\"mouseup\", finish);\n        window.removeEventListener(\"mousemove\", move);\n        const pluginState2 = columnResizingPluginKey.getState(view.state);\n        if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n            updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));\n            view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n                setDragging: null\n            }));\n        }\n    }\n    function move(event2) {\n        if (!event2.which) return finish(event2);\n        const pluginState2 = columnResizingPluginKey.getState(view.state);\n        if (!pluginState2) return;\n        if (pluginState2.dragging) {\n            const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n            displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n        }\n    }\n    window.addEventListener(\"mouseup\", finish);\n    window.addEventListener(\"mousemove\", move);\n    event.preventDefault();\n    return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n    const width = colwidth && colwidth[colwidth.length - 1];\n    if (width) return width;\n    const dom = view.domAtPos(cellPos);\n    const node = dom.node.childNodes[dom.offset];\n    let domWidth = node.offsetWidth, parts = colspan;\n    if (colwidth) {\n        for(let i = 0; i < colspan; i++)if (colwidth[i]) {\n            domWidth -= colwidth[i];\n            parts--;\n        }\n    }\n    return domWidth / parts;\n}\nfunction domCellAround(target) {\n    while(target && target.nodeName != \"TD\" && target.nodeName != \"TH\")target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n    return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n    const offset = side == \"right\" ? -handleWidth : handleWidth;\n    const found = view.posAtCoords({\n        left: event.clientX + offset,\n        top: event.clientY\n    });\n    if (!found) return -1;\n    const { pos } = found;\n    const $cell = cellAround(view.state.doc.resolve(pos));\n    if (!$cell) return -1;\n    if (side == \"right\") return $cell.pos;\n    const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n    const index = map.map.indexOf($cell.pos - start);\n    return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n    const offset = event.clientX - dragging.startX;\n    return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n    view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n        setHandle: value\n    }));\n}\nfunction updateColumnWidth(view, cell, width) {\n    const $cell = view.state.doc.resolve(cell);\n    const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n    const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n    const tr = view.state.tr;\n    for(let row = 0; row < map.height; row++){\n        const mapIndex = row * map.width + col;\n        if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n        const pos = map.map[mapIndex];\n        const attrs = table.nodeAt(pos).attrs;\n        const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n        if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n        const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n        colwidth[index] = width;\n        tr.setNodeMarkup(start + pos, null, {\n            ...attrs,\n            colwidth\n        });\n    }\n    if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n    const $cell = view.state.doc.resolve(cell);\n    const table = $cell.node(-1), start = $cell.start(-1);\n    const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n    let dom = view.domAtPos($cell.start(-1)).node;\n    while(dom && dom.nodeName != \"TABLE\"){\n        dom = dom.parentNode;\n    }\n    if (!dom) return;\n    updateColumnsOnResize(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\nfunction zeroes(n) {\n    return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n    const decorations = [];\n    const $cell = state.doc.resolve(cell);\n    const table = $cell.node(-1);\n    if (!table) {\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.empty;\n    }\n    const map = TableMap.get(table);\n    const start = $cell.start(-1);\n    const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n    for(let row = 0; row < map.height; row++){\n        const index = col + row * map.width - 1;\n        if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n            const cellPos = map.map[index];\n            const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n            const dom = document.createElement(\"div\");\n            dom.className = \"column-resize-handle\";\n            decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(pos, dom));\n        }\n    }\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations);\n}\n// src/commands.ts\n\n\nfunction selectedRect(state) {\n    const sel = state.selection;\n    const $pos = selectionCell(state);\n    const table = $pos.node(-1);\n    const tableStart = $pos.start(-1);\n    const map = TableMap.get(table);\n    const rect = sel instanceof CellSelection ? map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map.findCell($pos.pos - tableStart);\n    return {\n        ...rect,\n        tableStart,\n        map,\n        table\n    };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n    let refColumn = col > 0 ? -1 : 0;\n    if (columnIsHeader(map, table, col + refColumn)) {\n        refColumn = col == 0 || col == map.width ? null : 0;\n    }\n    for(let row = 0; row < map.height; row++){\n        const index = row * map.width + col;\n        if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n            const pos = map.map[index];\n            const cell = table.nodeAt(pos);\n            tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos)));\n            row += cell.attrs.rowspan - 1;\n        } else {\n            const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n            const pos = map.positionAt(row, col, table);\n            tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n        }\n    }\n    return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addColumn(state.tr, rect, rect.left));\n    }\n    return true;\n}\nfunction addColumnAfter(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addColumn(state.tr, rect, rect.right));\n    }\n    return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n    const mapStart = tr.mapping.maps.length;\n    for(let row = 0; row < map.height;){\n        const index = row * map.width + col;\n        const pos = map.map[index];\n        const cell = table.nodeAt(pos);\n        const attrs = cell.attrs;\n        if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n            tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map.colCount(pos)));\n        } else {\n            const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n            tr.delete(start, start + cell.nodeSize);\n        }\n        row += attrs.rowspan;\n    }\n}\nfunction deleteColumn(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        const tr = state.tr;\n        if (rect.left == 0 && rect.right == rect.map.width) return false;\n        for(let i = rect.right - 1;; i--){\n            removeColumn(tr, rect, i);\n            if (i == rect.left) break;\n            const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n            if (!table) {\n                throw RangeError(\"No table found\");\n            }\n            rect.table = table;\n            rect.map = TableMap.get(table);\n        }\n        dispatch(tr);\n    }\n    return true;\n}\nfunction rowIsHeader(map, table, row) {\n    var _a;\n    const headerCell = tableNodeTypes(table.type.schema).header_cell;\n    for(let col = 0; col < map.width; col++)if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell) return false;\n    return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n    var _a;\n    let rowPos = tableStart;\n    for(let i = 0; i < row; i++)rowPos += table.child(i).nodeSize;\n    const cells = [];\n    let refRow = row > 0 ? -1 : 0;\n    if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n    for(let col = 0, index = map.width * row; col < map.width; col++, index++){\n        if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n            const pos = map.map[index];\n            const attrs = table.nodeAt(pos).attrs;\n            tr.setNodeMarkup(tableStart + pos, null, {\n                ...attrs,\n                rowspan: attrs.rowspan + 1\n            });\n            col += attrs.colspan - 1;\n        } else {\n            const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n            const node = type == null ? void 0 : type.createAndFill();\n            if (node) cells.push(node);\n        }\n    }\n    tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n    return tr;\n}\nfunction addRowBefore(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addRow(state.tr, rect, rect.top));\n    }\n    return true;\n}\nfunction addRowAfter(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state);\n        dispatch(addRow(state.tr, rect, rect.bottom));\n    }\n    return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n    let rowPos = 0;\n    for(let i = 0; i < row; i++)rowPos += table.child(i).nodeSize;\n    const nextRow = rowPos + table.child(row).nodeSize;\n    const mapFrom = tr.mapping.maps.length;\n    tr.delete(rowPos + tableStart, nextRow + tableStart);\n    const seen = /* @__PURE__ */ new Set();\n    for(let col = 0, index = row * map.width; col < map.width; col++, index++){\n        const pos = map.map[index];\n        if (seen.has(pos)) continue;\n        seen.add(pos);\n        if (row > 0 && pos == map.map[index - map.width]) {\n            const attrs = table.nodeAt(pos).attrs;\n            tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n                ...attrs,\n                rowspan: attrs.rowspan - 1\n            });\n            col += attrs.colspan - 1;\n        } else if (row < map.height && pos == map.map[index + map.width]) {\n            const cell = table.nodeAt(pos);\n            const attrs = cell.attrs;\n            const copy = cell.type.create({\n                ...attrs,\n                rowspan: cell.attrs.rowspan - 1\n            }, cell.content);\n            const newPos = map.positionAt(row + 1, col, table);\n            tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n            col += attrs.colspan - 1;\n        }\n    }\n}\nfunction deleteRow(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n        const rect = selectedRect(state), tr = state.tr;\n        if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n        for(let i = rect.bottom - 1;; i--){\n            removeRow(tr, rect, i);\n            if (i == rect.top) break;\n            const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n            if (!table) {\n                throw RangeError(\"No table found\");\n            }\n            rect.table = table;\n            rect.map = TableMap.get(rect.table);\n        }\n        dispatch(tr);\n    }\n    return true;\n}\nfunction isEmpty(cell) {\n    const c = cell.content;\n    return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n    let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n    let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n    for(let i = rect.top; i < rect.bottom; i++){\n        if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n        indexLeft += width;\n        indexRight += width;\n    }\n    for(let i = rect.left; i < rect.right; i++){\n        if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n        indexTop++;\n        indexBottom++;\n    }\n    return false;\n}\nfunction mergeCells(state, dispatch) {\n    const sel = state.selection;\n    if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n    const rect = selectedRect(state), { map } = rect;\n    if (cellsOverlapRectangle(map, rect)) return false;\n    if (dispatch) {\n        const tr = state.tr;\n        const seen = {};\n        let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n        let mergedPos;\n        let mergedCell;\n        for(let row = rect.top; row < rect.bottom; row++){\n            for(let col = rect.left; col < rect.right; col++){\n                const cellPos = map.map[row * map.width + col];\n                const cell = rect.table.nodeAt(cellPos);\n                if (seen[cellPos] || !cell) continue;\n                seen[cellPos] = true;\n                if (mergedPos == null) {\n                    mergedPos = cellPos;\n                    mergedCell = cell;\n                } else {\n                    if (!isEmpty(cell)) content = content.append(cell.content);\n                    const mapped = tr.mapping.map(cellPos + rect.tableStart);\n                    tr.delete(mapped, mapped + cell.nodeSize);\n                }\n            }\n        }\n        if (mergedPos == null || mergedCell == null) {\n            return true;\n        }\n        tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n            ...addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan),\n            rowspan: rect.bottom - rect.top\n        });\n        if (content.size) {\n            const end = mergedPos + 1 + mergedCell.content.size;\n            const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n            tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n        }\n        tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n        dispatch(tr);\n    }\n    return true;\n}\nfunction splitCell(state, dispatch) {\n    const nodeTypes = tableNodeTypes(state.schema);\n    return splitCellWithType(({ node })=>{\n        return nodeTypes[node.type.spec.tableRole];\n    })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n    return (state, dispatch)=>{\n        var _a;\n        const sel = state.selection;\n        let cellNode;\n        let cellPos;\n        if (!(sel instanceof CellSelection)) {\n            cellNode = cellWrapping(sel.$from);\n            if (!cellNode) return false;\n            cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n        } else {\n            if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n            cellNode = sel.$anchorCell.nodeAfter;\n            cellPos = sel.$anchorCell.pos;\n        }\n        if (cellNode == null || cellPos == null) {\n            return false;\n        }\n        if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n            return false;\n        }\n        if (dispatch) {\n            let baseAttrs = cellNode.attrs;\n            const attrs = [];\n            const colwidth = baseAttrs.colwidth;\n            if (baseAttrs.rowspan > 1) baseAttrs = {\n                ...baseAttrs,\n                rowspan: 1\n            };\n            if (baseAttrs.colspan > 1) baseAttrs = {\n                ...baseAttrs,\n                colspan: 1\n            };\n            const rect = selectedRect(state), tr = state.tr;\n            for(let i = 0; i < rect.right - rect.left; i++)attrs.push(colwidth ? {\n                ...baseAttrs,\n                colwidth: colwidth && colwidth[i] ? [\n                    colwidth[i]\n                ] : null\n            } : baseAttrs);\n            let lastCell;\n            for(let row = rect.top; row < rect.bottom; row++){\n                let pos = rect.map.positionAt(row, rect.left, rect.table);\n                if (row == rect.top) pos += cellNode.nodeSize;\n                for(let col = rect.left, i = 0; col < rect.right; col++, i++){\n                    if (col == rect.left && row == rect.top) continue;\n                    tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n                        node: cellNode,\n                        row,\n                        col\n                    }).createAndFill(attrs[i]));\n                }\n            }\n            tr.setNodeMarkup(cellPos, getCellType({\n                node: cellNode,\n                row: rect.top,\n                col: rect.left\n            }), attrs[0]);\n            if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell ? tr.doc.resolve(lastCell) : void 0));\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction setCellAttr(name, value) {\n    return function(state, dispatch) {\n        if (!isInTable(state)) return false;\n        const $cell = selectionCell(state);\n        if ($cell.nodeAfter.attrs[name] === value) return false;\n        if (dispatch) {\n            const tr = state.tr;\n            if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos)=>{\n                if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, {\n                    ...node.attrs,\n                    [name]: value\n                });\n            });\n            else tr.setNodeMarkup($cell.pos, null, {\n                ...$cell.nodeAfter.attrs,\n                [name]: value\n            });\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction deprecated_toggleHeader(type) {\n    return function(state, dispatch) {\n        if (!isInTable(state)) return false;\n        if (dispatch) {\n            const types = tableNodeTypes(state.schema);\n            const rect = selectedRect(state), tr = state.tr;\n            const cells = rect.map.cellsInRect(type == \"column\" ? {\n                left: rect.left,\n                top: 0,\n                right: rect.right,\n                bottom: rect.map.height\n            } : type == \"row\" ? {\n                left: 0,\n                top: rect.top,\n                right: rect.map.width,\n                bottom: rect.bottom\n            } : rect);\n            const nodes = cells.map((pos)=>rect.table.nodeAt(pos));\n            for(let i = 0; i < cells.length; i++)if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n            if (tr.steps.length == 0) for(let i = 0; i < cells.length; i++)tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n    const cellPositions = rect.map.cellsInRect({\n        left: 0,\n        top: 0,\n        right: type == \"row\" ? rect.map.width : 1,\n        bottom: type == \"column\" ? rect.map.height : 1\n    });\n    for(let i = 0; i < cellPositions.length; i++){\n        const cell = rect.table.nodeAt(cellPositions[i]);\n        if (cell && cell.type !== types.header_cell) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction toggleHeader(type, options) {\n    options = options || {\n        useDeprecatedLogic: false\n    };\n    if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n    return function(state, dispatch) {\n        if (!isInTable(state)) return false;\n        if (dispatch) {\n            const types = tableNodeTypes(state.schema);\n            const rect = selectedRect(state), tr = state.tr;\n            const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n            const isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n            const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n            const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n            const cellsRect = type == \"column\" ? {\n                left: 0,\n                top: selectionStartsAt,\n                right: 1,\n                bottom: rect.map.height\n            } : type == \"row\" ? {\n                left: selectionStartsAt,\n                top: 0,\n                right: rect.map.width,\n                bottom: 1\n            } : rect;\n            const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n            rect.map.cellsInRect(cellsRect).forEach((relativeCellPos)=>{\n                const cellPos = relativeCellPos + rect.tableStart;\n                const cell = tr.doc.nodeAt(cellPos);\n                if (cell) {\n                    tr.setNodeMarkup(cellPos, newType, cell.attrs);\n                }\n            });\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n    useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n    useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n    useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n    if (dir < 0) {\n        const before = $cell.nodeBefore;\n        if (before) return $cell.pos - before.nodeSize;\n        for(let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--){\n            const rowNode = $cell.node(-1).child(row);\n            const lastChild = rowNode.lastChild;\n            if (lastChild) {\n                return rowEnd - 1 - lastChild.nodeSize;\n            }\n            rowEnd -= rowNode.nodeSize;\n        }\n    } else {\n        if ($cell.index() < $cell.parent.childCount - 1) {\n            return $cell.pos + $cell.nodeAfter.nodeSize;\n        }\n        const table = $cell.node(-1);\n        for(let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++){\n            const rowNode = table.child(row);\n            if (rowNode.childCount) return rowStart + 1;\n            rowStart += rowNode.nodeSize;\n        }\n    }\n    return null;\n}\nfunction goToNextCell(direction) {\n    return function(state, dispatch) {\n        if (!isInTable(state)) return false;\n        const cell = findNextCell(selectionCell(state), direction);\n        if (cell == null) return false;\n        if (dispatch) {\n            const $cell = state.doc.resolve(cell);\n            dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction deleteTable(state, dispatch) {\n    const $pos = state.selection.$anchor;\n    for(let d = $pos.depth; d > 0; d--){\n        const node = $pos.node(d);\n        if (node.type.spec.tableRole == \"table\") {\n            if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n            return true;\n        }\n    }\n    return false;\n}\n// src/index.ts\nfunction tableEditing({ allowTableNodeSelection = false } = {}) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: tableEditingKey,\n        // This piece of state is used to remember when a mouse-drag\n        // cell-selection is happening, so that it can continue even as\n        // transactions (which might move its anchor cell) come in.\n        state: {\n            init () {\n                return null;\n            },\n            apply (tr, cur) {\n                const set = tr.getMeta(tableEditingKey);\n                if (set != null) return set == -1 ? null : set;\n                if (cur == null || !tr.docChanged) return cur;\n                const { deleted, pos } = tr.mapping.mapResult(cur);\n                return deleted ? null : pos;\n            }\n        },\n        props: {\n            decorations: drawCellSelection,\n            handleDOMEvents: {\n                mousedown: handleMouseDown\n            },\n            createSelectionBetween (view) {\n                return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n            },\n            handleTripleClick,\n            handleKeyDown,\n            handlePaste\n        },\n        appendTransaction (_, oldState, state) {\n            return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdGFibGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUN1QztBQUV0RCx1QkFBdUI7QUFDNkI7QUFNekI7QUFDa0M7QUFFN0Qsa0JBQWtCO0FBQ2xCLElBQUlXO0FBQ0osSUFBSUM7QUFDSixJQUFJLE9BQU9DLFdBQVcsYUFBYTtJQUNqQyxJQUFJQyxRQUFRLGFBQWEsR0FBRyxJQUFJRDtJQUNoQ0YsZ0JBQWdCLENBQUNJLE1BQVFELE1BQU1FLEdBQUcsQ0FBQ0Q7SUFDbkNILGFBQWEsQ0FBQ0csS0FBS0U7UUFDakJILE1BQU1JLEdBQUcsQ0FBQ0gsS0FBS0U7UUFDZixPQUFPQTtJQUNUO0FBQ0YsT0FBTztJQUNMLE1BQU1ILFFBQVEsRUFBRTtJQUNoQixNQUFNSyxZQUFZO0lBQ2xCLElBQUlDLFdBQVc7SUFDZlQsZ0JBQWdCLENBQUNJO1FBQ2YsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlQLE1BQU1RLE1BQU0sRUFBRUQsS0FBSyxFQUNyQyxJQUFJUCxLQUFLLENBQUNPLEVBQUUsSUFBSU4sS0FDZCxPQUFPRCxLQUFLLENBQUNPLElBQUksRUFBRTtJQUN6QjtJQUNBVCxhQUFhLENBQUNHLEtBQUtFO1FBQ2pCLElBQUlHLFlBQVlELFdBQ2RDLFdBQVc7UUFDYk4sS0FBSyxDQUFDTSxXQUFXLEdBQUdMO1FBQ3BCLE9BQU9ELEtBQUssQ0FBQ00sV0FBVyxHQUFHSDtJQUM3QjtBQUNGO0FBQ0EsSUFBSU0sV0FBVztJQUNiQyxZQUFZQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxRQUFRLENBQUU7UUFDeEMsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFB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LEdBQUduQixPQUFPLENBQUNpVixTQUFTLENBQUMxUTtnQkFDOUMsT0FBT3lRLFVBQVUsT0FBTzVmO1lBQzFCO1FBQ0Y7UUFDQTJZLE9BQU87WUFDTGMsYUFBYXZMO1lBQ2JnTCxpQkFBaUI7Z0JBQ2ZLLFdBQVc5RTtZQUNiO1lBQ0FxTCx3QkFBdUIvTCxJQUFJO2dCQUN6QixPQUFPdk0sZ0JBQWdCZ08sUUFBUSxDQUFDekIsS0FBSzlMLEtBQUssS0FBSyxPQUFPOEwsS0FBSzlMLEtBQUssQ0FBQ0UsU0FBUyxHQUFHO1lBQy9FO1lBQ0FtTTtZQUNBbkI7WUFDQW9CO1FBQ0Y7UUFDQXdMLG1CQUFrQnZMLENBQUMsRUFBRTVFLFFBQVEsRUFBRTNILEtBQUs7WUFDbEMsT0FBTzBHLG1CQUNMMUcsT0FDQTBILFVBQVUxSCxPQUFPMkgsV0FDakJoQjtRQUVKO0lBQ0Y7QUFDRjtBQXNERSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlLWpvdXJuYWwvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdGFibGVzL2Rpc3QvaW5kZXguanM/MzhhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4yIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5cbi8vIHNyYy9jZWxsc2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBGcmFnbWVudCwgU2xpY2UgfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7XG4gIE5vZGVTZWxlY3Rpb24gYXMgTm9kZVNlbGVjdGlvbjIsXG4gIFNlbGVjdGlvbixcbiAgU2VsZWN0aW9uUmFuZ2UsXG4gIFRleHRTZWxlY3Rpb25cbn0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcblxuLy8gc3JjL3RhYmxlbWFwLnRzXG52YXIgcmVhZEZyb21DYWNoZTtcbnZhciBhZGRUb0NhY2hlO1xuaWYgKHR5cGVvZiBXZWFrTWFwICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgbGV0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIHJlYWRGcm9tQ2FjaGUgPSAoa2V5KSA9PiBjYWNoZS5nZXQoa2V5KTtcbiAgYWRkVG9DYWNoZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0gZWxzZSB7XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IGNhY2hlU2l6ZSA9IDEwO1xuICBsZXQgY2FjaGVQb3MgPSAwO1xuICByZWFkRnJvbUNhY2hlID0gKGtleSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICBpZiAoY2FjaGVbaV0gPT0ga2V5KVxuICAgICAgICByZXR1cm4gY2FjaGVbaSArIDFdO1xuICB9O1xuICBhZGRUb0NhY2hlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoY2FjaGVQb3MgPT0gY2FjaGVTaXplKVxuICAgICAgY2FjaGVQb3MgPSAwO1xuICAgIGNhY2hlW2NhY2hlUG9zKytdID0ga2V5O1xuICAgIHJldHVybiBjYWNoZVtjYWNoZVBvcysrXSA9IHZhbHVlO1xuICB9O1xufVxudmFyIFRhYmxlTWFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBtYXAsIHByb2JsZW1zKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMucHJvYmxlbXMgPSBwcm9ibGVtcztcbiAgfVxuICAvLyBGaW5kIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgZmluZENlbGwocG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VyUG9zID0gdGhpcy5tYXBbaV07XG4gICAgICBpZiAoY3VyUG9zICE9IHBvcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBsZWZ0ID0gaSAlIHRoaXMud2lkdGg7XG4gICAgICBjb25zdCB0b3AgPSBpIC8gdGhpcy53aWR0aCB8IDA7XG4gICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIGxldCBib3R0b20gPSB0b3AgKyAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IHJpZ2h0IDwgdGhpcy53aWR0aCAmJiB0aGlzLm1hcFtpICsgal0gPT0gY3VyUG9zOyBqKyspIHtcbiAgICAgICAgcmlnaHQrKztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAxOyBib3R0b20gPCB0aGlzLmhlaWdodCAmJiB0aGlzLm1hcFtpICsgdGhpcy53aWR0aCAqIGpdID09IGN1clBvczsgaisrKSB7XG4gICAgICAgIGJvdHRvbSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICB9XG4gIC8vIEZpbmQgdGhlIGxlZnQgc2lkZSBvZiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbENvdW50KHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm1hcFtpXSA9PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGkgJSB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgfVxuICAvLyBGaW5kIHRoZSBuZXh0IGNlbGwgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgY2VsbFxuICAvLyBhdCBgcG9zYCwgaWYgYW55LlxuICBuZXh0Q2VsbChwb3MsIGF4aXMsIGRpcikge1xuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSB0aGlzLmZpbmRDZWxsKHBvcyk7XG4gICAgaWYgKGF4aXMgPT0gXCJob3JpelwiKSB7XG4gICAgICBpZiAoZGlyIDwgMCA/IGxlZnQgPT0gMCA6IHJpZ2h0ID09IHRoaXMud2lkdGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMubWFwW3RvcCAqIHRoaXMud2lkdGggKyAoZGlyIDwgMCA/IGxlZnQgLSAxIDogcmlnaHQpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpciA8IDAgPyB0b3AgPT0gMCA6IGJvdHRvbSA9PSB0aGlzLmhlaWdodClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5tYXBbbGVmdCArIHRoaXMud2lkdGggKiAoZGlyIDwgMCA/IHRvcCAtIDEgOiBib3R0b20pXTtcbiAgICB9XG4gIH1cbiAgLy8gR2V0IHRoZSByZWN0YW5nbGUgc3Bhbm5pbmcgdGhlIHR3byBnaXZlbiBjZWxscy5cbiAgcmVjdEJldHdlZW4oYSwgYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGxlZnRBLFxuICAgICAgcmlnaHQ6IHJpZ2h0QSxcbiAgICAgIHRvcDogdG9wQSxcbiAgICAgIGJvdHRvbTogYm90dG9tQVxuICAgIH0gPSB0aGlzLmZpbmRDZWxsKGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGxlZnRCLFxuICAgICAgcmlnaHQ6IHJpZ2h0QixcbiAgICAgIHRvcDogdG9wQixcbiAgICAgIGJvdHRvbTogYm90dG9tQlxuICAgIH0gPSB0aGlzLmZpbmRDZWxsKGIpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBNYXRoLm1pbihsZWZ0QSwgbGVmdEIpLFxuICAgICAgdG9wOiBNYXRoLm1pbih0b3BBLCB0b3BCKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChyaWdodEEsIHJpZ2h0QiksXG4gICAgICBib3R0b206IE1hdGgubWF4KGJvdHRvbUEsIGJvdHRvbUIpXG4gICAgfTtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIGFsbCBjZWxscyB0aGF0IGhhdmUgdGhlIHRvcCBsZWZ0IGNvcm5lciBpblxuICAvLyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICBjZWxsc0luUmVjdChyZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIGZvciAobGV0IHJvdyA9IHJlY3QudG9wOyByb3cgPCByZWN0LmJvdHRvbTsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IHJlY3QubGVmdDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByb3cgKiB0aGlzLndpZHRoICsgY29sO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLm1hcFtpbmRleF07XG4gICAgICAgIGlmIChzZWVuW3Bvc10pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHNlZW5bcG9zXSA9IHRydWU7XG4gICAgICAgIGlmIChjb2wgPT0gcmVjdC5sZWZ0ICYmIGNvbCAmJiB0aGlzLm1hcFtpbmRleCAtIDFdID09IHBvcyB8fCByb3cgPT0gcmVjdC50b3AgJiYgcm93ICYmIHRoaXMubWFwW2luZGV4IC0gdGhpcy53aWR0aF0gPT0gcG9zKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocG9zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiByb3cgYW5kIGNvbHVtblxuICAvLyBzdGFydHMsIG9yIHdvdWxkIHN0YXJ0LCBpZiBhIGNlbGwgc3RhcnRlZCB0aGVyZS5cbiAgcG9zaXRpb25BdChyb3csIGNvbCwgdGFibGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcm93U3RhcnQgPSAwOyA7IGkrKykge1xuICAgICAgY29uc3Qgcm93RW5kID0gcm93U3RhcnQgKyB0YWJsZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgIGlmIChpID09IHJvdykge1xuICAgICAgICBsZXQgaW5kZXggPSBjb2wgKyByb3cgKiB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCByb3dFbmRJbmRleCA9IChyb3cgKyAxKSAqIHRoaXMud2lkdGg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHJvd0VuZEluZGV4ICYmIHRoaXMubWFwW2luZGV4XSA8IHJvd1N0YXJ0KVxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSByb3dFbmRJbmRleCA/IHJvd0VuZCAtIDEgOiB0aGlzLm1hcFtpbmRleF07XG4gICAgICB9XG4gICAgICByb3dTdGFydCA9IHJvd0VuZDtcbiAgICB9XG4gIH1cbiAgLy8gRmluZCB0aGUgdGFibGUgbWFwIGZvciB0aGUgZ2l2ZW4gdGFibGUgbm9kZS5cbiAgc3RhdGljIGdldCh0YWJsZSkge1xuICAgIHJldHVybiByZWFkRnJvbUNhY2hlKHRhYmxlKSB8fCBhZGRUb0NhY2hlKHRhYmxlLCBjb21wdXRlTWFwKHRhYmxlKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjb21wdXRlTWFwKHRhYmxlKSB7XG4gIGlmICh0YWJsZS50eXBlLnNwZWMudGFibGVSb2xlICE9IFwidGFibGVcIilcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vdCBhIHRhYmxlIG5vZGU6IFwiICsgdGFibGUudHlwZS5uYW1lKTtcbiAgY29uc3Qgd2lkdGggPSBmaW5kV2lkdGgodGFibGUpLCBoZWlnaHQgPSB0YWJsZS5jaGlsZENvdW50O1xuICBjb25zdCBtYXAgPSBbXTtcbiAgbGV0IG1hcFBvcyA9IDA7XG4gIGxldCBwcm9ibGVtcyA9IG51bGw7XG4gIGNvbnN0IGNvbFdpZHRocyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgZSA9IHdpZHRoICogaGVpZ2h0OyBpIDwgZTsgaSsrKVxuICAgIG1hcFtpXSA9IDA7XG4gIGZvciAobGV0IHJvdyA9IDAsIHBvcyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCByb3dOb2RlID0gdGFibGUuY2hpbGQocm93KTtcbiAgICBwb3MrKztcbiAgICBmb3IgKGxldCBpID0gMDsgOyBpKyspIHtcbiAgICAgIHdoaWxlIChtYXBQb3MgPCBtYXAubGVuZ3RoICYmIG1hcFttYXBQb3NdICE9IDApXG4gICAgICAgIG1hcFBvcysrO1xuICAgICAgaWYgKGkgPT0gcm93Tm9kZS5jaGlsZENvdW50KVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IGNlbGxOb2RlID0gcm93Tm9kZS5jaGlsZChpKTtcbiAgICAgIGNvbnN0IHsgY29sc3Bhbiwgcm93c3BhbiwgY29sd2lkdGggfSA9IGNlbGxOb2RlLmF0dHJzO1xuICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCByb3dzcGFuOyBoKyspIHtcbiAgICAgICAgaWYgKGggKyByb3cgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIm92ZXJsb25nX3Jvd3NwYW5cIixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIG46IHJvd3NwYW4gLSBoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBtYXBQb3MgKyBoICogd2lkdGg7XG4gICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgY29sc3BhbjsgdysrKSB7XG4gICAgICAgICAgaWYgKG1hcFtzdGFydCArIHddID09IDApXG4gICAgICAgICAgICBtYXBbc3RhcnQgKyB3XSA9IHBvcztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb2xsaXNpb25cIixcbiAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgIG46IGNvbHNwYW4gLSB3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjb2xXID0gY29sd2lkdGggJiYgY29sd2lkdGhbd107XG4gICAgICAgICAgaWYgKGNvbFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoSW5kZXggPSAoc3RhcnQgKyB3KSAlIHdpZHRoICogMiwgcHJldiA9IGNvbFdpZHRoc1t3aWR0aEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgcHJldiAhPSBjb2xXICYmIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0gPT0gMSkge1xuICAgICAgICAgICAgICBjb2xXaWR0aHNbd2lkdGhJbmRleF0gPSBjb2xXO1xuICAgICAgICAgICAgICBjb2xXaWR0aHNbd2lkdGhJbmRleCArIDFdID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldiA9PSBjb2xXKSB7XG4gICAgICAgICAgICAgIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcFBvcyArPSBjb2xzcGFuO1xuICAgICAgcG9zICs9IGNlbGxOb2RlLm5vZGVTaXplO1xuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZFBvcyA9IChyb3cgKyAxKSAqIHdpZHRoO1xuICAgIGxldCBtaXNzaW5nID0gMDtcbiAgICB3aGlsZSAobWFwUG9zIDwgZXhwZWN0ZWRQb3MpXG4gICAgICBpZiAobWFwW21hcFBvcysrXSA9PSAwKVxuICAgICAgICBtaXNzaW5nKys7XG4gICAgaWYgKG1pc3NpbmcpXG4gICAgICAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHsgdHlwZTogXCJtaXNzaW5nXCIsIHJvdywgbjogbWlzc2luZyB9KTtcbiAgICBwb3MrKztcbiAgfVxuICBjb25zdCB0YWJsZU1hcCA9IG5ldyBUYWJsZU1hcCh3aWR0aCwgaGVpZ2h0LCBtYXAsIHByb2JsZW1zKTtcbiAgbGV0IGJhZFdpZHRocyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgIWJhZFdpZHRocyAmJiBpIDwgY29sV2lkdGhzLmxlbmd0aDsgaSArPSAyKVxuICAgIGlmIChjb2xXaWR0aHNbaV0gIT0gbnVsbCAmJiBjb2xXaWR0aHNbaSArIDFdIDwgaGVpZ2h0KVxuICAgICAgYmFkV2lkdGhzID0gdHJ1ZTtcbiAgaWYgKGJhZFdpZHRocylcbiAgICBmaW5kQmFkQ29sV2lkdGhzKHRhYmxlTWFwLCBjb2xXaWR0aHMsIHRhYmxlKTtcbiAgcmV0dXJuIHRhYmxlTWFwO1xufVxuZnVuY3Rpb24gZmluZFdpZHRoKHRhYmxlKSB7XG4gIGxldCB3aWR0aCA9IC0xO1xuICBsZXQgaGFzUm93U3BhbiA9IGZhbHNlO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0YWJsZS5jaGlsZENvdW50OyByb3crKykge1xuICAgIGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuICAgIGxldCByb3dXaWR0aCA9IDA7XG4gICAgaWYgKGhhc1Jvd1NwYW4pXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdzsgaisrKSB7XG4gICAgICAgIGNvbnN0IHByZXZSb3cgPSB0YWJsZS5jaGlsZChqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Um93LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNlbGwgPSBwcmV2Um93LmNoaWxkKGkpO1xuICAgICAgICAgIGlmIChqICsgY2VsbC5hdHRycy5yb3dzcGFuID4gcm93KVxuICAgICAgICAgICAgcm93V2lkdGggKz0gY2VsbC5hdHRycy5jb2xzcGFuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dOb2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgY2VsbCA9IHJvd05vZGUuY2hpbGQoaSk7XG4gICAgICByb3dXaWR0aCArPSBjZWxsLmF0dHJzLmNvbHNwYW47XG4gICAgICBpZiAoY2VsbC5hdHRycy5yb3dzcGFuID4gMSlcbiAgICAgICAgaGFzUm93U3BhbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3aWR0aCA9PSAtMSlcbiAgICAgIHdpZHRoID0gcm93V2lkdGg7XG4gICAgZWxzZSBpZiAod2lkdGggIT0gcm93V2lkdGgpXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCByb3dXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIHdpZHRoO1xufVxuZnVuY3Rpb24gZmluZEJhZENvbFdpZHRocyhtYXAsIGNvbFdpZHRocywgdGFibGUpIHtcbiAgaWYgKCFtYXAucHJvYmxlbXMpXG4gICAgbWFwLnByb2JsZW1zID0gW107XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFtpXTtcbiAgICBpZiAoc2Vlbltwb3NdKVxuICAgICAgY29udGludWU7XG4gICAgc2Vlbltwb3NdID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgIGNvbnN0IGF0dHJzID0gbm9kZS5hdHRycztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJzLmNvbHNwYW47IGorKykge1xuICAgICAgY29uc3QgY29sID0gKGkgKyBqKSAlIG1hcC53aWR0aDtcbiAgICAgIGNvbnN0IGNvbFdpZHRoID0gY29sV2lkdGhzW2NvbCAqIDJdO1xuICAgICAgaWYgKGNvbFdpZHRoICE9IG51bGwgJiYgKCFhdHRycy5jb2x3aWR0aCB8fCBhdHRycy5jb2x3aWR0aFtqXSAhPSBjb2xXaWR0aCkpXG4gICAgICAgICh1cGRhdGVkIHx8ICh1cGRhdGVkID0gZnJlc2hDb2xXaWR0aChhdHRycykpKVtqXSA9IGNvbFdpZHRoO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZClcbiAgICAgIG1hcC5wcm9ibGVtcy51bnNoaWZ0KHtcbiAgICAgICAgdHlwZTogXCJjb2x3aWR0aCBtaXNtYXRjaFwiLFxuICAgICAgICBwb3MsXG4gICAgICAgIGNvbHdpZHRoOiB1cGRhdGVkXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnJlc2hDb2xXaWR0aChhdHRycykge1xuICBpZiAoYXR0cnMuY29sd2lkdGgpXG4gICAgcmV0dXJuIGF0dHJzLmNvbHdpZHRoLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmNvbHNwYW47IGkrKylcbiAgICByZXN1bHQucHVzaCgwKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwudHNcbmltcG9ydCB7IFBsdWdpbktleSB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuXG4vLyBzcmMvc2NoZW1hLnRzXG5mdW5jdGlvbiBnZXRDZWxsQXR0cnMoZG9tLCBleHRyYUF0dHJzKSB7XG4gIGlmICh0eXBlb2YgZG9tID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHdpZHRoQXR0ciA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbHdpZHRoXCIpO1xuICBjb25zdCB3aWR0aHMgPSB3aWR0aEF0dHIgJiYgL15cXGQrKCxcXGQrKSokLy50ZXN0KHdpZHRoQXR0cikgPyB3aWR0aEF0dHIuc3BsaXQoXCIsXCIpLm1hcCgocykgPT4gTnVtYmVyKHMpKSA6IG51bGw7XG4gIGNvbnN0IGNvbHNwYW4gPSBOdW1iZXIoZG9tLmdldEF0dHJpYnV0ZShcImNvbHNwYW5cIikgfHwgMSk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBjb2xzcGFuLFxuICAgIHJvd3NwYW46IE51bWJlcihkb20uZ2V0QXR0cmlidXRlKFwicm93c3BhblwiKSB8fCAxKSxcbiAgICBjb2x3aWR0aDogd2lkdGhzICYmIHdpZHRocy5sZW5ndGggPT0gY29sc3BhbiA/IHdpZHRocyA6IG51bGxcbiAgfTtcbiAgZm9yIChjb25zdCBwcm9wIGluIGV4dHJhQXR0cnMpIHtcbiAgICBjb25zdCBnZXR0ZXIgPSBleHRyYUF0dHJzW3Byb3BdLmdldEZyb21ET007XG4gICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgJiYgZ2V0dGVyKGRvbSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0Q2VsbEF0dHJzKG5vZGUsIGV4dHJhQXR0cnMpIHtcbiAgY29uc3QgYXR0cnMgPSB7fTtcbiAgaWYgKG5vZGUuYXR0cnMuY29sc3BhbiAhPSAxKVxuICAgIGF0dHJzLmNvbHNwYW4gPSBub2RlLmF0dHJzLmNvbHNwYW47XG4gIGlmIChub2RlLmF0dHJzLnJvd3NwYW4gIT0gMSlcbiAgICBhdHRycy5yb3dzcGFuID0gbm9kZS5hdHRycy5yb3dzcGFuO1xuICBpZiAobm9kZS5hdHRycy5jb2x3aWR0aClcbiAgICBhdHRyc1tcImRhdGEtY29sd2lkdGhcIl0gPSBub2RlLmF0dHJzLmNvbHdpZHRoLmpvaW4oXCIsXCIpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycykge1xuICAgIGNvbnN0IHNldHRlciA9IGV4dHJhQXR0cnNbcHJvcF0uc2V0RE9NQXR0cjtcbiAgICBpZiAoc2V0dGVyKVxuICAgICAgc2V0dGVyKG5vZGUuYXR0cnNbcHJvcF0sIGF0dHJzKTtcbiAgfVxuICByZXR1cm4gYXR0cnM7XG59XG5mdW5jdGlvbiB0YWJsZU5vZGVzKG9wdGlvbnMpIHtcbiAgY29uc3QgZXh0cmFBdHRycyA9IG9wdGlvbnMuY2VsbEF0dHJpYnV0ZXMgfHwge307XG4gIGNvbnN0IGNlbGxBdHRycyA9IHtcbiAgICBjb2xzcGFuOiB7IGRlZmF1bHQ6IDEgfSxcbiAgICByb3dzcGFuOiB7IGRlZmF1bHQ6IDEgfSxcbiAgICBjb2x3aWR0aDogeyBkZWZhdWx0OiBudWxsIH1cbiAgfTtcbiAgZm9yIChjb25zdCBwcm9wIGluIGV4dHJhQXR0cnMpXG4gICAgY2VsbEF0dHJzW3Byb3BdID0geyBkZWZhdWx0OiBleHRyYUF0dHJzW3Byb3BdLmRlZmF1bHQgfTtcbiAgcmV0dXJuIHtcbiAgICB0YWJsZToge1xuICAgICAgY29udGVudDogXCJ0YWJsZV9yb3crXCIsXG4gICAgICB0YWJsZVJvbGU6IFwidGFibGVcIixcbiAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgIGdyb3VwOiBvcHRpb25zLnRhYmxlR3JvdXAsXG4gICAgICBwYXJzZURPTTogW3sgdGFnOiBcInRhYmxlXCIgfV0sXG4gICAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIFtcInRhYmxlXCIsIFtcInRib2R5XCIsIDBdXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlX3Jvdzoge1xuICAgICAgY29udGVudDogXCIodGFibGVfY2VsbCB8IHRhYmxlX2hlYWRlcikqXCIsXG4gICAgICB0YWJsZVJvbGU6IFwicm93XCIsXG4gICAgICBwYXJzZURPTTogW3sgdGFnOiBcInRyXCIgfV0sXG4gICAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIFtcInRyXCIsIDBdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVfY2VsbDoge1xuICAgICAgY29udGVudDogb3B0aW9ucy5jZWxsQ29udGVudCxcbiAgICAgIGF0dHJzOiBjZWxsQXR0cnMsXG4gICAgICB0YWJsZVJvbGU6IFwiY2VsbFwiLFxuICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgcGFyc2VET006IFtcbiAgICAgICAgeyB0YWc6IFwidGRcIiwgZ2V0QXR0cnM6IChkb20pID0+IGdldENlbGxBdHRycyhkb20sIGV4dHJhQXR0cnMpIH1cbiAgICAgIF0sXG4gICAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBbXCJ0ZFwiLCBzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycyksIDBdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVfaGVhZGVyOiB7XG4gICAgICBjb250ZW50OiBvcHRpb25zLmNlbGxDb250ZW50LFxuICAgICAgYXR0cnM6IGNlbGxBdHRycyxcbiAgICAgIHRhYmxlUm9sZTogXCJoZWFkZXJfY2VsbFwiLFxuICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgcGFyc2VET006IFtcbiAgICAgICAgeyB0YWc6IFwidGhcIiwgZ2V0QXR0cnM6IChkb20pID0+IGdldENlbGxBdHRycyhkb20sIGV4dHJhQXR0cnMpIH1cbiAgICAgIF0sXG4gICAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBbXCJ0aFwiLCBzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycyksIDBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkge1xuICBsZXQgcmVzdWx0ID0gc2NoZW1hLmNhY2hlZC50YWJsZU5vZGVUeXBlcztcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBzY2hlbWEuY2FjaGVkLnRhYmxlTm9kZVR5cGVzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYS5ub2Rlc1tuYW1lXSwgcm9sZSA9IHR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgICBpZiAocm9sZSlcbiAgICAgICAgcmVzdWx0W3JvbGVdID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwudHNcbnZhciB0YWJsZUVkaXRpbmdLZXkgPSBuZXcgUGx1Z2luS2V5KFwic2VsZWN0aW5nQ2VsbHNcIik7XG5mdW5jdGlvbiBjZWxsQXJvdW5kKCRwb3MpIHtcbiAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID4gMDsgZC0tKVxuICAgIGlmICgkcG9zLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiKVxuICAgICAgcmV0dXJuICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MuYmVmb3JlKGQgKyAxKSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2VsbFdyYXBwaW5nKCRwb3MpIHtcbiAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPiAwOyBkLS0pIHtcbiAgICBjb25zdCByb2xlID0gJHBvcy5ub2RlKGQpLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgaWYgKHJvbGUgPT09IFwiY2VsbFwiIHx8IHJvbGUgPT09IFwiaGVhZGVyX2NlbGxcIilcbiAgICAgIHJldHVybiAkcG9zLm5vZGUoZCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0luVGFibGUoc3RhdGUpIHtcbiAgY29uc3QgJGhlYWQgPSBzdGF0ZS5zZWxlY3Rpb24uJGhlYWQ7XG4gIGZvciAobGV0IGQgPSAkaGVhZC5kZXB0aDsgZCA+IDA7IGQtLSlcbiAgICBpZiAoJGhlYWQubm9kZShkKS50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uQ2VsbChzdGF0ZSkge1xuICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChcIiRhbmNob3JDZWxsXCIgaW4gc2VsICYmIHNlbC4kYW5jaG9yQ2VsbCkge1xuICAgIHJldHVybiBzZWwuJGFuY2hvckNlbGwucG9zID4gc2VsLiRoZWFkQ2VsbC5wb3MgPyBzZWwuJGFuY2hvckNlbGwgOiBzZWwuJGhlYWRDZWxsO1xuICB9IGVsc2UgaWYgKFwibm9kZVwiIGluIHNlbCAmJiBzZWwubm9kZSAmJiBzZWwubm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09IFwiY2VsbFwiKSB7XG4gICAgcmV0dXJuIHNlbC4kYW5jaG9yO1xuICB9XG4gIGNvbnN0ICRjZWxsID0gY2VsbEFyb3VuZChzZWwuJGhlYWQpIHx8IGNlbGxOZWFyKHNlbC4kaGVhZCk7XG4gIGlmICgkY2VsbCkge1xuICAgIHJldHVybiAkY2VsbDtcbiAgfVxuICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCBmb3VuZCBhcm91bmQgcG9zaXRpb24gJHtzZWwuaGVhZH1gKTtcbn1cbmZ1bmN0aW9uIGNlbGxOZWFyKCRwb3MpIHtcbiAgZm9yIChsZXQgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgcG9zID0gJHBvcy5wb3M7IGFmdGVyOyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQsIHBvcysrKSB7XG4gICAgY29uc3Qgcm9sZSA9IGFmdGVyLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpXG4gICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICB9XG4gIGZvciAobGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgcG9zID0gJHBvcy5wb3M7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCwgcG9zLS0pIHtcbiAgICBjb25zdCByb2xlID0gYmVmb3JlLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpXG4gICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZShwb3MgLSBiZWZvcmUubm9kZVNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBwb2ludHNBdENlbGwoJHBvcykge1xuICByZXR1cm4gJHBvcy5wYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiICYmICEhJHBvcy5ub2RlQWZ0ZXI7XG59XG5mdW5jdGlvbiBtb3ZlQ2VsbEZvcndhcmQoJHBvcykge1xuICByZXR1cm4gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5wb3MgKyAkcG9zLm5vZGVBZnRlci5ub2RlU2l6ZSk7XG59XG5mdW5jdGlvbiBpblNhbWVUYWJsZSgkY2VsbEEsICRjZWxsQikge1xuICByZXR1cm4gJGNlbGxBLmRlcHRoID09ICRjZWxsQi5kZXB0aCAmJiAkY2VsbEEucG9zID49ICRjZWxsQi5zdGFydCgtMSkgJiYgJGNlbGxBLnBvcyA8PSAkY2VsbEIuZW5kKC0xKTtcbn1cbmZ1bmN0aW9uIGZpbmRDZWxsKCRwb3MpIHtcbiAgcmV0dXJuIFRhYmxlTWFwLmdldCgkcG9zLm5vZGUoLTEpKS5maW5kQ2VsbCgkcG9zLnBvcyAtICRwb3Muc3RhcnQoLTEpKTtcbn1cbmZ1bmN0aW9uIGNvbENvdW50KCRwb3MpIHtcbiAgcmV0dXJuIFRhYmxlTWFwLmdldCgkcG9zLm5vZGUoLTEpKS5jb2xDb3VudCgkcG9zLnBvcyAtICRwb3Muc3RhcnQoLTEpKTtcbn1cbmZ1bmN0aW9uIG5leHRDZWxsKCRwb3MsIGF4aXMsIGRpcikge1xuICBjb25zdCB0YWJsZSA9ICRwb3Mubm9kZSgtMSk7XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHRhYmxlU3RhcnQgPSAkcG9zLnN0YXJ0KC0xKTtcbiAgY29uc3QgbW92ZWQgPSBtYXAubmV4dENlbGwoJHBvcy5wb3MgLSB0YWJsZVN0YXJ0LCBheGlzLCBkaXIpO1xuICByZXR1cm4gbW92ZWQgPT0gbnVsbCA/IG51bGwgOiAkcG9zLm5vZGUoMCkucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbW92ZWQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ29sU3BhbihhdHRycywgcG9zLCBuID0gMSkge1xuICBjb25zdCByZXN1bHQgPSB7IC4uLmF0dHJzLCBjb2xzcGFuOiBhdHRycy5jb2xzcGFuIC0gbiB9O1xuICBpZiAocmVzdWx0LmNvbHdpZHRoKSB7XG4gICAgcmVzdWx0LmNvbHdpZHRoID0gcmVzdWx0LmNvbHdpZHRoLnNsaWNlKCk7XG4gICAgcmVzdWx0LmNvbHdpZHRoLnNwbGljZShwb3MsIG4pO1xuICAgIGlmICghcmVzdWx0LmNvbHdpZHRoLnNvbWUoKHcpID0+IHcgPiAwKSlcbiAgICAgIHJlc3VsdC5jb2x3aWR0aCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFkZENvbFNwYW4oYXR0cnMsIHBvcywgbiA9IDEpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5hdHRycywgY29sc3BhbjogYXR0cnMuY29sc3BhbiArIG4gfTtcbiAgaWYgKHJlc3VsdC5jb2x3aWR0aCkge1xuICAgIHJlc3VsdC5jb2x3aWR0aCA9IHJlc3VsdC5jb2x3aWR0aC5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgcmVzdWx0LmNvbHdpZHRoLnNwbGljZShwb3MsIDAsIDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb2x1bW5Jc0hlYWRlcihtYXAsIHRhYmxlLCBjb2wpIHtcbiAgY29uc3QgaGVhZGVyQ2VsbCA9IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5oZWFkZXJfY2VsbDtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspXG4gICAgaWYgKHRhYmxlLm5vZGVBdChtYXAubWFwW2NvbCArIHJvdyAqIG1hcC53aWR0aF0pLnR5cGUgIT0gaGVhZGVyQ2VsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9jZWxsc2VsZWN0aW9uLnRzXG52YXIgQ2VsbFNlbGVjdGlvbiA9IGNsYXNzIF9DZWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgLy8gQSB0YWJsZSBzZWxlY3Rpb24gaXMgaWRlbnRpZmllZCBieSBpdHMgYW5jaG9yIGFuZCBoZWFkIGNlbGxzLiBUaGVcbiAgLy8gcG9zaXRpb25zIGdpdmVuIHRvIHRoaXMgY29uc3RydWN0b3Igc2hvdWxkIHBvaW50IF9iZWZvcmVfIHR3b1xuICAvLyBjZWxscyBpbiB0aGUgc2FtZSB0YWJsZS4gVGhleSBtYXkgYmUgdGhlIHNhbWUsIHRvIHNlbGVjdCBhIHNpbmdsZVxuICAvLyBjZWxsLlxuICBjb25zdHJ1Y3RvcigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsID0gJGFuY2hvckNlbGwpIHtcbiAgICBjb25zdCB0YWJsZSA9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9ICRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCByZWN0ID0gbWFwLnJlY3RCZXR3ZWVuKFxuICAgICAgJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCxcbiAgICAgICRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCBkb2MgPSAkYW5jaG9yQ2VsbC5ub2RlKDApO1xuICAgIGNvbnN0IGNlbGxzID0gbWFwLmNlbGxzSW5SZWN0KHJlY3QpLmZpbHRlcigocCkgPT4gcCAhPSAkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY2VsbHMudW5zaGlmdCgkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgcmFuZ2VzID0gY2VsbHMubWFwKChwb3MpID0+IHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgIGlmICghY2VsbCkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJvbSA9IHRhYmxlU3RhcnQgKyBwb3MgKyAxO1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShcbiAgICAgICAgZG9jLnJlc29sdmUoZnJvbSksXG4gICAgICAgIGRvYy5yZXNvbHZlKGZyb20gKyBjZWxsLmNvbnRlbnQuc2l6ZSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgc3VwZXIocmFuZ2VzWzBdLiRmcm9tLCByYW5nZXNbMF0uJHRvLCByYW5nZXMpO1xuICAgIHRoaXMuJGFuY2hvckNlbGwgPSAkYW5jaG9yQ2VsbDtcbiAgICB0aGlzLiRoZWFkQ2VsbCA9ICRoZWFkQ2VsbDtcbiAgfVxuICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgY29uc3QgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLiRhbmNob3JDZWxsLnBvcykpO1xuICAgIGNvbnN0ICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuJGhlYWRDZWxsLnBvcykpO1xuICAgIGlmIChwb2ludHNBdENlbGwoJGFuY2hvckNlbGwpICYmIHBvaW50c0F0Q2VsbCgkaGVhZENlbGwpICYmIGluU2FtZVRhYmxlKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpKSB7XG4gICAgICBjb25zdCB0YWJsZUNoYW5nZWQgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpICE9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgICAgaWYgKHRhYmxlQ2hhbmdlZCAmJiB0aGlzLmlzUm93U2VsZWN0aW9uKCkpXG4gICAgICAgIHJldHVybiBfQ2VsbFNlbGVjdGlvbi5yb3dTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gICAgICBlbHNlIGlmICh0YWJsZUNoYW5nZWQgJiYgdGhpcy5pc0NvbFNlbGVjdGlvbigpKVxuICAgICAgICByZXR1cm4gX0NlbGxTZWxlY3Rpb24uY29sU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICB9XG4gIC8vIFJldHVybnMgYSByZWN0YW5ndWxhciBzbGljZSBvZiB0YWJsZSByb3dzIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkXG4gIC8vIGNlbGxzLlxuICBjb250ZW50KCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSB0aGlzLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCByZWN0ID0gbWFwLnJlY3RCZXR3ZWVuKFxuICAgICAgdGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0LFxuICAgICAgdGhpcy4kaGVhZENlbGwucG9zIC0gdGFibGVTdGFydFxuICAgICk7XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICBmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG4gICAgICBjb25zdCByb3dDb250ZW50ID0gW107XG4gICAgICBmb3IgKGxldCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIHJlY3QubGVmdCwgY29sID0gcmVjdC5sZWZ0OyBjb2wgPCByZWN0LnJpZ2h0OyBjb2wrKywgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICAgICAgaWYgKHNlZW5bcG9zXSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc2Vlbltwb3NdID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2VsbFJlY3QgPSBtYXAuZmluZENlbGwocG9zKTtcbiAgICAgICAgbGV0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYUxlZnQgPSByZWN0LmxlZnQgLSBjZWxsUmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCBleHRyYVJpZ2h0ID0gY2VsbFJlY3QucmlnaHQgLSByZWN0LnJpZ2h0O1xuICAgICAgICBpZiAoZXh0cmFMZWZ0ID4gMCB8fCBleHRyYVJpZ2h0ID4gMCkge1xuICAgICAgICAgIGxldCBhdHRycyA9IGNlbGwuYXR0cnM7XG4gICAgICAgICAgaWYgKGV4dHJhTGVmdCA+IDApIHtcbiAgICAgICAgICAgIGF0dHJzID0gcmVtb3ZlQ29sU3BhbihhdHRycywgMCwgZXh0cmFMZWZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICBhdHRycyA9IHJlbW92ZUNvbFNwYW4oXG4gICAgICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgICAgICBhdHRycy5jb2xzcGFuIC0gZXh0cmFSaWdodCxcbiAgICAgICAgICAgICAgZXh0cmFSaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNlbGxSZWN0LmxlZnQgPCByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbChhdHRycyk7XG4gICAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICBgQ291bGQgbm90IGNyZWF0ZSBjZWxsIHdpdGggYXR0cnMgJHtKU09OLnN0cmluZ2lmeShhdHRycyl9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZShhdHRycywgY2VsbC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxSZWN0LnRvcCA8IHJlY3QudG9wIHx8IGNlbGxSZWN0LmJvdHRvbSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICAgICAgcm93c3BhbjogTWF0aC5taW4oY2VsbFJlY3QuYm90dG9tLCByZWN0LmJvdHRvbSkgLSBNYXRoLm1heChjZWxsUmVjdC50b3AsIHJlY3QudG9wKVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGNlbGxSZWN0LnRvcCA8IHJlY3QudG9wKSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZUFuZEZpbGwoYXR0cnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZShhdHRycywgY2VsbC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm93Q29udGVudC5wdXNoKGNlbGwpO1xuICAgICAgfVxuICAgICAgcm93cy5wdXNoKHRhYmxlLmNoaWxkKHJvdykuY29weShGcmFnbWVudC5mcm9tKHJvd0NvbnRlbnQpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pc0NvbFNlbGVjdGlvbigpICYmIHRoaXMuaXNSb3dTZWxlY3Rpb24oKSA/IHRhYmxlIDogcm93cztcbiAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oZnJhZ21lbnQpLCAxLCAxKTtcbiAgfVxuICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICBjb25zdCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgdHIucmVwbGFjZShcbiAgICAgICAgbWFwcGluZy5tYXAoJGZyb20ucG9zKSxcbiAgICAgICAgbWFwcGluZy5tYXAoJHRvLnBvcyksXG4gICAgICAgIGkgPyBTbGljZS5lbXB0eSA6IGNvbnRlbnRcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShcbiAgICAgIHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHRoaXMudG8pKSxcbiAgICAgIC0xXG4gICAgKTtcbiAgICBpZiAoc2VsKVxuICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gIH1cbiAgcmVwbGFjZVdpdGgodHIsIG5vZGUpIHtcbiAgICB0aGlzLnJlcGxhY2UodHIsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG4gIH1cbiAgZm9yRWFjaENlbGwoZikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSB0aGlzLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCBjZWxscyA9IG1hcC5jZWxsc0luUmVjdChcbiAgICAgIG1hcC5yZWN0QmV0d2VlbihcbiAgICAgICAgdGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0LFxuICAgICAgICB0aGlzLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICAgICApXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmKHRhYmxlLm5vZGVBdChjZWxsc1tpXSksIHRhYmxlU3RhcnQgKyBjZWxsc1tpXSk7XG4gICAgfVxuICB9XG4gIC8vIFRydWUgaWYgdGhpcyBzZWxlY3Rpb24gZ29lcyBhbGwgdGhlIHdheSBmcm9tIHRoZSB0b3AgdG8gdGhlXG4gIC8vIGJvdHRvbSBvZiB0aGUgdGFibGUuXG4gIGlzQ29sU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IGFuY2hvclRvcCA9IHRoaXMuJGFuY2hvckNlbGwuaW5kZXgoLTEpO1xuICAgIGNvbnN0IGhlYWRUb3AgPSB0aGlzLiRoZWFkQ2VsbC5pbmRleCgtMSk7XG4gICAgaWYgKE1hdGgubWluKGFuY2hvclRvcCwgaGVhZFRvcCkgPiAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFuY2hvckJvdHRvbSA9IGFuY2hvclRvcCArIHRoaXMuJGFuY2hvckNlbGwubm9kZUFmdGVyLmF0dHJzLnJvd3NwYW47XG4gICAgY29uc3QgaGVhZEJvdHRvbSA9IGhlYWRUb3AgKyB0aGlzLiRoZWFkQ2VsbC5ub2RlQWZ0ZXIuYXR0cnMucm93c3BhbjtcbiAgICByZXR1cm4gTWF0aC5tYXgoYW5jaG9yQm90dG9tLCBoZWFkQm90dG9tKSA9PSB0aGlzLiRoZWFkQ2VsbC5ub2RlKC0xKS5jaGlsZENvdW50O1xuICB9XG4gIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IGNvbHVtbiBzZWxlY3Rpb24gdGhhdCBjb3ZlcnMgdGhlIGdpdmVuIGFuY2hvclxuICAvLyBhbmQgaGVhZCBjZWxsLlxuICBzdGF0aWMgY29sU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwgPSAkYW5jaG9yQ2VsbCkge1xuICAgIGNvbnN0IHRhYmxlID0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IGFuY2hvclJlY3QgPSBtYXAuZmluZENlbGwoJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgaGVhZFJlY3QgPSBtYXAuZmluZENlbGwoJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGRvYyA9ICRhbmNob3JDZWxsLm5vZGUoMCk7XG4gICAgaWYgKGFuY2hvclJlY3QudG9wIDw9IGhlYWRSZWN0LnRvcCkge1xuICAgICAgaWYgKGFuY2hvclJlY3QudG9wID4gMClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFthbmNob3JSZWN0LmxlZnRdKTtcbiAgICAgIGlmIChoZWFkUmVjdC5ib3R0b20gPCBtYXAuaGVpZ2h0KVxuICAgICAgICAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAobWFwLmhlaWdodCAtIDEpICsgaGVhZFJlY3QucmlnaHQgLSAxXVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGVhZFJlY3QudG9wID4gMClcbiAgICAgICAgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbaGVhZFJlY3QubGVmdF0pO1xuICAgICAgaWYgKGFuY2hvclJlY3QuYm90dG9tIDwgbWFwLmhlaWdodClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAobWFwLmhlaWdodCAtIDEpICsgYW5jaG9yUmVjdC5yaWdodCAtIDFdXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gIH1cbiAgLy8gVHJ1ZSBpZiB0aGlzIHNlbGVjdGlvbiBnb2VzIGFsbCB0aGUgd2F5IGZyb20gdGhlIGxlZnQgdG8gdGhlXG4gIC8vIHJpZ2h0IG9mIHRoZSB0YWJsZS5cbiAgaXNSb3dTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9IHRoaXMuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IGFuY2hvckxlZnQgPSBtYXAuY29sQ291bnQodGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBoZWFkTGVmdCA9IG1hcC5jb2xDb3VudCh0aGlzLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBpZiAoTWF0aC5taW4oYW5jaG9yTGVmdCwgaGVhZExlZnQpID4gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBhbmNob3JSaWdodCA9IGFuY2hvckxlZnQgKyB0aGlzLiRhbmNob3JDZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuO1xuICAgIGNvbnN0IGhlYWRSaWdodCA9IGhlYWRMZWZ0ICsgdGhpcy4kaGVhZENlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW47XG4gICAgcmV0dXJuIE1hdGgubWF4KGFuY2hvclJpZ2h0LCBoZWFkUmlnaHQpID09IG1hcC53aWR0aDtcbiAgfVxuICBlcShvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIF9DZWxsU2VsZWN0aW9uICYmIG90aGVyLiRhbmNob3JDZWxsLnBvcyA9PSB0aGlzLiRhbmNob3JDZWxsLnBvcyAmJiBvdGhlci4kaGVhZENlbGwucG9zID09IHRoaXMuJGhlYWRDZWxsLnBvcztcbiAgfVxuICAvLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCByb3cgc2VsZWN0aW9uIHRoYXQgY292ZXJzIHRoZSBnaXZlbiBhbmNob3JcbiAgLy8gYW5kIGhlYWQgY2VsbC5cbiAgc3RhdGljIHJvd1NlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsID0gJGFuY2hvckNlbGwpIHtcbiAgICBjb25zdCB0YWJsZSA9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9ICRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCBhbmNob3JSZWN0ID0gbWFwLmZpbmRDZWxsKCRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGhlYWRSZWN0ID0gbWFwLmZpbmRDZWxsKCRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBkb2MgPSAkYW5jaG9yQ2VsbC5ub2RlKDApO1xuICAgIGlmIChhbmNob3JSZWN0LmxlZnQgPD0gaGVhZFJlY3QubGVmdCkge1xuICAgICAgaWYgKGFuY2hvclJlY3QubGVmdCA+IDApXG4gICAgICAgICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUoXG4gICAgICAgICAgdGFibGVTdGFydCArIG1hcC5tYXBbYW5jaG9yUmVjdC50b3AgKiBtYXAud2lkdGhdXG4gICAgICAgICk7XG4gICAgICBpZiAoaGVhZFJlY3QucmlnaHQgPCBtYXAud2lkdGgpXG4gICAgICAgICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKFxuICAgICAgICAgIHRhYmxlU3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIChoZWFkUmVjdC50b3AgKyAxKSAtIDFdXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoZWFkUmVjdC5sZWZ0ID4gMClcbiAgICAgICAgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbaGVhZFJlY3QudG9wICogbWFwLndpZHRoXSk7XG4gICAgICBpZiAoYW5jaG9yUmVjdC5yaWdodCA8IG1hcC53aWR0aClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAoYW5jaG9yUmVjdC50b3AgKyAxKSAtIDFdXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgIGFuY2hvcjogdGhpcy4kYW5jaG9yQ2VsbC5wb3MsXG4gICAgICBoZWFkOiB0aGlzLiRoZWFkQ2VsbC5wb3NcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvckNlbGwsIGhlYWRDZWxsID0gYW5jaG9yQ2VsbCkge1xuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oZG9jLnJlc29sdmUoYW5jaG9yQ2VsbCksIGRvYy5yZXNvbHZlKGhlYWRDZWxsKSk7XG4gIH1cbiAgZ2V0Qm9va21hcmsoKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsQm9va21hcmsodGhpcy4kYW5jaG9yQ2VsbC5wb3MsIHRoaXMuJGhlYWRDZWxsLnBvcyk7XG4gIH1cbn07XG5DZWxsU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwiY2VsbFwiLCBDZWxsU2VsZWN0aW9uKTtcbnZhciBDZWxsQm9va21hcmsgPSBjbGFzcyBfQ2VsbEJvb2ttYXJrIHtcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBoZWFkKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgfVxuICBtYXAobWFwcGluZykge1xuICAgIHJldHVybiBuZXcgX0NlbGxCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICB9XG4gIHJlc29sdmUoZG9jKSB7XG4gICAgY29uc3QgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKHRoaXMuaGVhZCk7XG4gICAgaWYgKCRhbmNob3JDZWxsLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgJGhlYWRDZWxsLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgJGFuY2hvckNlbGwuaW5kZXgoKSA8ICRhbmNob3JDZWxsLnBhcmVudC5jaGlsZENvdW50ICYmICRoZWFkQ2VsbC5pbmRleCgpIDwgJGhlYWRDZWxsLnBhcmVudC5jaGlsZENvdW50ICYmIGluU2FtZVRhYmxlKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpKVxuICAgICAgcmV0dXJuIG5ldyBDZWxsU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZENlbGwsIDEpO1xuICB9XG59O1xuZnVuY3Rpb24gZHJhd0NlbGxTZWxlY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIHN0YXRlLnNlbGVjdGlvbi5mb3JFYWNoQ2VsbCgobm9kZSwgcG9zKSA9PiB7XG4gICAgY2VsbHMucHVzaChcbiAgICAgIERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHsgY2xhc3M6IFwic2VsZWN0ZWRDZWxsXCIgfSlcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgY2VsbHMpO1xufVxuZnVuY3Rpb24gaXNDZWxsQm91bmRhcnlTZWxlY3Rpb24oeyAkZnJvbSwgJHRvIH0pIHtcbiAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zIHx8ICRmcm9tLnBvcyA8ICRmcm9tLnBvcyAtIDYpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgYWZ0ZXJGcm9tID0gJGZyb20ucG9zO1xuICBsZXQgYmVmb3JlVG8gPSAkdG8ucG9zO1xuICBsZXQgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgZm9yICg7IGRlcHRoID49IDA7IGRlcHRoLS0sIGFmdGVyRnJvbSsrKVxuICAgIGlmICgkZnJvbS5hZnRlcihkZXB0aCArIDEpIDwgJGZyb20uZW5kKGRlcHRoKSlcbiAgICAgIGJyZWFrO1xuICBmb3IgKGxldCBkID0gJHRvLmRlcHRoOyBkID49IDA7IGQtLSwgYmVmb3JlVG8tLSlcbiAgICBpZiAoJHRvLmJlZm9yZShkICsgMSkgPiAkdG8uc3RhcnQoZCkpXG4gICAgICBicmVhaztcbiAgcmV0dXJuIGFmdGVyRnJvbSA9PSBiZWZvcmVUbyAmJiAvcm93fHRhYmxlLy50ZXN0KCRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuc3BlYy50YWJsZVJvbGUpO1xufVxuZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uQWNyb3NzQ2VsbHMoeyAkZnJvbSwgJHRvIH0pIHtcbiAgbGV0IGZyb21DZWxsQm91bmRhcnlOb2RlO1xuICBsZXQgdG9DZWxsQm91bmRhcnlOb2RlO1xuICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgICAgZnJvbUNlbGxCb3VuZGFyeU5vZGUgPSBub2RlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAkdG8uZGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gJHRvLm5vZGUoaSk7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PT0gXCJjZWxsXCIgfHwgbm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICAgIHRvQ2VsbEJvdW5kYXJ5Tm9kZSA9IG5vZGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb21DZWxsQm91bmRhcnlOb2RlICE9PSB0b0NlbGxCb3VuZGFyeU5vZGUgJiYgJHRvLnBhcmVudE9mZnNldCA9PT0gMDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihzdGF0ZSwgdHIsIGFsbG93VGFibGVOb2RlU2VsZWN0aW9uKSB7XG4gIGNvbnN0IHNlbCA9ICh0ciB8fCBzdGF0ZSkuc2VsZWN0aW9uO1xuICBjb25zdCBkb2MgPSAodHIgfHwgc3RhdGUpLmRvYztcbiAgbGV0IG5vcm1hbGl6ZTtcbiAgbGV0IHJvbGU7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uMiAmJiAocm9sZSA9IHNlbC5ub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUpKSB7XG4gICAgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICAgIG5vcm1hbGl6ZSA9IENlbGxTZWxlY3Rpb24uY3JlYXRlKGRvYywgc2VsLmZyb20pO1xuICAgIH0gZWxzZSBpZiAocm9sZSA9PSBcInJvd1wiKSB7XG4gICAgICBjb25zdCAkY2VsbCA9IGRvYy5yZXNvbHZlKHNlbC5mcm9tICsgMSk7XG4gICAgICBub3JtYWxpemUgPSBDZWxsU2VsZWN0aW9uLnJvd1NlbGVjdGlvbigkY2VsbCwgJGNlbGwpO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93VGFibGVOb2RlU2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQoc2VsLm5vZGUpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBzZWwuZnJvbSArIDE7XG4gICAgICBjb25zdCBsYXN0Q2VsbCA9IHN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiBtYXAuaGVpZ2h0IC0gMV07XG4gICAgICBub3JtYWxpemUgPSBDZWxsU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHN0YXJ0ICsgMSwgbGFzdENlbGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIGlzQ2VsbEJvdW5kYXJ5U2VsZWN0aW9uKHNlbCkpIHtcbiAgICBub3JtYWxpemUgPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHNlbC5mcm9tKTtcbiAgfSBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIGlzVGV4dFNlbGVjdGlvbkFjcm9zc0NlbGxzKHNlbCkpIHtcbiAgICBub3JtYWxpemUgPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHNlbC4kZnJvbS5zdGFydCgpLCBzZWwuJGZyb20uZW5kKCkpO1xuICB9XG4gIGlmIChub3JtYWxpemUpXG4gICAgKHRyIHx8ICh0ciA9IHN0YXRlLnRyKSkuc2V0U2VsZWN0aW9uKG5vcm1hbGl6ZSk7XG4gIHJldHVybiB0cjtcbn1cblxuLy8gc3JjL2ZpeHRhYmxlcy50c1xuaW1wb3J0IHsgUGx1Z2luS2V5IGFzIFBsdWdpbktleTIgfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbnZhciBmaXhUYWJsZXNLZXkgPSBuZXcgUGx1Z2luS2V5MihcImZpeC10YWJsZXNcIik7XG5mdW5jdGlvbiBjaGFuZ2VkRGVzY2VuZGFudHMob2xkLCBjdXIsIG9mZnNldCwgZikge1xuICBjb25zdCBvbGRTaXplID0gb2xkLmNoaWxkQ291bnQsIGN1clNpemUgPSBjdXIuY2hpbGRDb3VudDtcbiAgb3V0ZXI6XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY3VyU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGN1ci5jaGlsZChpKTtcbiAgICAgIGZvciAobGV0IHNjYW4gPSBqLCBlID0gTWF0aC5taW4ob2xkU2l6ZSwgaSArIDMpOyBzY2FuIDwgZTsgc2NhbisrKSB7XG4gICAgICAgIGlmIChvbGQuY2hpbGQoc2NhbikgPT0gY2hpbGQpIHtcbiAgICAgICAgICBqID0gc2NhbiArIDE7XG4gICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmKGNoaWxkLCBvZmZzZXQpO1xuICAgICAgaWYgKGogPCBvbGRTaXplICYmIG9sZC5jaGlsZChqKS5zYW1lTWFya3VwKGNoaWxkKSlcbiAgICAgICAgY2hhbmdlZERlc2NlbmRhbnRzKG9sZC5jaGlsZChqKSwgY2hpbGQsIG9mZnNldCArIDEsIGYpO1xuICAgICAgZWxzZVxuICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oMCwgY2hpbGQuY29udGVudC5zaXplLCBmLCBvZmZzZXQgKyAxKTtcbiAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaXhUYWJsZXMoc3RhdGUsIG9sZFN0YXRlKSB7XG4gIGxldCB0cjtcbiAgY29uc3QgY2hlY2sgPSAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInRhYmxlXCIpXG4gICAgICB0ciA9IGZpeFRhYmxlKHN0YXRlLCBub2RlLCBwb3MsIHRyKTtcbiAgfTtcbiAgaWYgKCFvbGRTdGF0ZSlcbiAgICBzdGF0ZS5kb2MuZGVzY2VuZGFudHMoY2hlY2spO1xuICBlbHNlIGlmIChvbGRTdGF0ZS5kb2MgIT0gc3RhdGUuZG9jKVxuICAgIGNoYW5nZWREZXNjZW5kYW50cyhvbGRTdGF0ZS5kb2MsIHN0YXRlLmRvYywgMCwgY2hlY2spO1xuICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBmaXhUYWJsZShzdGF0ZSwgdGFibGUsIHRhYmxlUG9zLCB0cikge1xuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICBpZiAoIW1hcC5wcm9ibGVtcylcbiAgICByZXR1cm4gdHI7XG4gIGlmICghdHIpXG4gICAgdHIgPSBzdGF0ZS50cjtcbiAgY29uc3QgbXVzdEFkZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5oZWlnaHQ7IGkrKylcbiAgICBtdXN0QWRkLnB1c2goMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLnByb2JsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvYiA9IG1hcC5wcm9ibGVtc1tpXTtcbiAgICBpZiAocHJvYi50eXBlID09IFwiY29sbGlzaW9uXCIpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocHJvYi5wb3MpO1xuICAgICAgaWYgKCFjZWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGF0dHJzID0gY2VsbC5hdHRycztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXR0cnMucm93c3BhbjsgaisrKVxuICAgICAgICBtdXN0QWRkW3Byb2Iucm93ICsgal0gKz0gcHJvYi5uO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdHIubWFwcGluZy5tYXAodGFibGVQb3MgKyAxICsgcHJvYi5wb3MpLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW1vdmVDb2xTcGFuKGF0dHJzLCBhdHRycy5jb2xzcGFuIC0gcHJvYi5uLCBwcm9iLm4pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwibWlzc2luZ1wiKSB7XG4gICAgICBtdXN0QWRkW3Byb2Iucm93XSArPSBwcm9iLm47XG4gICAgfSBlbHNlIGlmIChwcm9iLnR5cGUgPT0gXCJvdmVybG9uZ19yb3dzcGFuXCIpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocHJvYi5wb3MpO1xuICAgICAgaWYgKCFjZWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAodGFibGVQb3MgKyAxICsgcHJvYi5wb3MpLCBudWxsLCB7XG4gICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgIHJvd3NwYW46IGNlbGwuYXR0cnMucm93c3BhbiAtIHByb2IublxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwcm9iLnR5cGUgPT0gXCJjb2x3aWR0aCBtaXNtYXRjaFwiKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHByb2IucG9zKTtcbiAgICAgIGlmICghY2VsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKHRhYmxlUG9zICsgMSArIHByb2IucG9zKSwgbnVsbCwge1xuICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICBjb2x3aWR0aDogcHJvYi5jb2x3aWR0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGxldCBmaXJzdCwgbGFzdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXN0QWRkLmxlbmd0aDsgaSsrKVxuICAgIGlmIChtdXN0QWRkW2ldKSB7XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbClcbiAgICAgICAgZmlyc3QgPSBpO1xuICAgICAgbGFzdCA9IGk7XG4gICAgfVxuICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGFibGVQb3MgKyAxOyBpIDwgbWFwLmhlaWdodDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gdGFibGUuY2hpbGQoaSk7XG4gICAgY29uc3QgZW5kID0gcG9zICsgcm93Lm5vZGVTaXplO1xuICAgIGNvbnN0IGFkZCA9IG11c3RBZGRbaV07XG4gICAgaWYgKGFkZCA+IDApIHtcbiAgICAgIGxldCByb2xlID0gXCJjZWxsXCI7XG4gICAgICBpZiAocm93LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcm9sZSA9IHJvdy5maXJzdENoaWxkLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhZGQ7IGorKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKVtyb2xlXS5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgIGlmIChub2RlKVxuICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gKGkgPT0gMCB8fCBmaXJzdCA9PSBpIC0gMSkgJiYgbGFzdCA9PSBpID8gcG9zICsgMSA6IGVuZCAtIDE7XG4gICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5tYXAoc2lkZSksIG5vZGVzKTtcbiAgICB9XG4gICAgcG9zID0gZW5kO1xuICB9XG4gIHJldHVybiB0ci5zZXRNZXRhKGZpeFRhYmxlc0tleSwgeyBmaXhUYWJsZXM6IHRydWUgfSk7XG59XG5cbi8vIHNyYy9pbnB1dC50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQzLCBTbGljZSBhcyBTbGljZTMgfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7XG4gIFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24yLFxuICBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb24yXG59IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuaW1wb3J0IHsga2V5ZG93bkhhbmRsZXIgfSBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG5cbi8vIHNyYy9jb3B5cGFzdGUudHNcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MiwgU2xpY2UgYXMgU2xpY2UyIH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG5mdW5jdGlvbiBwYXN0ZWRDZWxscyhzbGljZSkge1xuICBpZiAoIXNsaWNlLnNpemUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gIHdoaWxlIChjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiAob3BlblN0YXJ0ID4gMCAmJiBvcGVuRW5kID4gMCB8fCBjb250ZW50LmNoaWxkKDApLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJ0YWJsZVwiKSkge1xuICAgIG9wZW5TdGFydC0tO1xuICAgIG9wZW5FbmQtLTtcbiAgICBjb250ZW50ID0gY29udGVudC5jaGlsZCgwKS5jb250ZW50O1xuICB9XG4gIGNvbnN0IGZpcnN0ID0gY29udGVudC5jaGlsZCgwKTtcbiAgY29uc3Qgcm9sZSA9IGZpcnN0LnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gIGNvbnN0IHNjaGVtYSA9IGZpcnN0LnR5cGUuc2NoZW1hLCByb3dzID0gW107XG4gIGlmIChyb2xlID09IFwicm93XCIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICBsZXQgY2VsbHMgPSBjb250ZW50LmNoaWxkKGkpLmNvbnRlbnQ7XG4gICAgICBjb25zdCBsZWZ0ID0gaSA/IDAgOiBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSAxKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gaSA8IGNvbnRlbnQuY2hpbGRDb3VudCAtIDEgPyAwIDogTWF0aC5tYXgoMCwgb3BlbkVuZCAtIDEpO1xuICAgICAgaWYgKGxlZnQgfHwgcmlnaHQpXG4gICAgICAgIGNlbGxzID0gZml0U2xpY2UoXG4gICAgICAgICAgdGFibGVOb2RlVHlwZXMoc2NoZW1hKS5yb3csXG4gICAgICAgICAgbmV3IFNsaWNlMihjZWxscywgbGVmdCwgcmlnaHQpXG4gICAgICAgICkuY29udGVudDtcbiAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICByb3dzLnB1c2goXG4gICAgICBvcGVuU3RhcnQgfHwgb3BlbkVuZCA/IGZpdFNsaWNlKFxuICAgICAgICB0YWJsZU5vZGVUeXBlcyhzY2hlbWEpLnJvdyxcbiAgICAgICAgbmV3IFNsaWNlMihjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpXG4gICAgICApLmNvbnRlbnQgOiBjb250ZW50XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5zdXJlUmVjdGFuZ3VsYXIoc2NoZW1hLCByb3dzKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZVJlY3Rhbmd1bGFyKHNjaGVtYSwgcm93cykge1xuICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gcm93c1tpXTtcbiAgICBmb3IgKGxldCBqID0gcm93LmNoaWxkQ291bnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgY29uc3QgeyByb3dzcGFuLCBjb2xzcGFuIH0gPSByb3cuY2hpbGQoaikuYXR0cnM7XG4gICAgICBmb3IgKGxldCByID0gaTsgciA8IGkgKyByb3dzcGFuOyByKyspXG4gICAgICAgIHdpZHRoc1tyXSA9ICh3aWR0aHNbcl0gfHwgMCkgKyBjb2xzcGFuO1xuICAgIH1cbiAgfVxuICBsZXQgd2lkdGggPSAwO1xuICBmb3IgKGxldCByID0gMDsgciA8IHdpZHRocy5sZW5ndGg7IHIrKylcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB3aWR0aHNbcl0pO1xuICBmb3IgKGxldCByID0gMDsgciA8IHdpZHRocy5sZW5ndGg7IHIrKykge1xuICAgIGlmIChyID49IHJvd3MubGVuZ3RoKVxuICAgICAgcm93cy5wdXNoKEZyYWdtZW50Mi5lbXB0eSk7XG4gICAgaWYgKHdpZHRoc1tyXSA8IHdpZHRoKSB7XG4gICAgICBjb25zdCBlbXB0eSA9IHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkuY2VsbC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICBjb25zdCBjZWxscyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IHdpZHRoc1tyXTsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgY2VsbHMucHVzaChlbXB0eSk7XG4gICAgICB9XG4gICAgICByb3dzW3JdID0gcm93c1tyXS5hcHBlbmQoRnJhZ21lbnQyLmZyb20oY2VsbHMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaGVpZ2h0OiByb3dzLmxlbmd0aCwgd2lkdGgsIHJvd3MgfTtcbn1cbmZ1bmN0aW9uIGZpdFNsaWNlKG5vZGVUeXBlLCBzbGljZSkge1xuICBjb25zdCBub2RlID0gbm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpO1xuICBjb25zdCB0ciA9IG5ldyBUcmFuc2Zvcm0obm9kZSkucmVwbGFjZSgwLCBub2RlLmNvbnRlbnQuc2l6ZSwgc2xpY2UpO1xuICByZXR1cm4gdHIuZG9jO1xufVxuZnVuY3Rpb24gY2xpcENlbGxzKHsgd2lkdGgsIGhlaWdodCwgcm93cyB9LCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gIGlmICh3aWR0aCAhPSBuZXdXaWR0aCkge1xuICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgY29uc3QgbmV3Um93cyA9IFtdO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3MubGVuZ3RoOyByb3crKykge1xuICAgICAgY29uc3QgZnJhZyA9IHJvd3Nbcm93XSwgY2VsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGNvbCA9IGFkZGVkW3Jvd10gfHwgMCwgaSA9IDA7IGNvbCA8IG5ld1dpZHRoOyBpKyspIHtcbiAgICAgICAgbGV0IGNlbGwgPSBmcmFnLmNoaWxkKGkgJSBmcmFnLmNoaWxkQ291bnQpO1xuICAgICAgICBpZiAoY29sICsgY2VsbC5hdHRycy5jb2xzcGFuID4gbmV3V2lkdGgpXG4gICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGVDaGVja2VkKFxuICAgICAgICAgICAgcmVtb3ZlQ29sU3BhbihcbiAgICAgICAgICAgICAgY2VsbC5hdHRycyxcbiAgICAgICAgICAgICAgY2VsbC5hdHRycy5jb2xzcGFuLFxuICAgICAgICAgICAgICBjb2wgKyBjZWxsLmF0dHJzLmNvbHNwYW4gLSBuZXdXaWR0aFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNlbGwuY29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgIGNvbCArPSBjZWxsLmF0dHJzLmNvbHNwYW47XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgY2VsbC5hdHRycy5yb3dzcGFuOyBqKyspXG4gICAgICAgICAgYWRkZWRbcm93ICsgal0gPSAoYWRkZWRbcm93ICsgal0gfHwgMCkgKyBjZWxsLmF0dHJzLmNvbHNwYW47XG4gICAgICB9XG4gICAgICBuZXdSb3dzLnB1c2goRnJhZ21lbnQyLmZyb20oY2VsbHMpKTtcbiAgICB9XG4gICAgcm93cyA9IG5ld1Jvd3M7XG4gICAgd2lkdGggPSBuZXdXaWR0aDtcbiAgfVxuICBpZiAoaGVpZ2h0ICE9IG5ld0hlaWdodCkge1xuICAgIGNvbnN0IG5ld1Jvd3MgPSBbXTtcbiAgICBmb3IgKGxldCByb3cgPSAwLCBpID0gMDsgcm93IDwgbmV3SGVpZ2h0OyByb3crKywgaSsrKSB7XG4gICAgICBjb25zdCBjZWxscyA9IFtdLCBzb3VyY2UgPSByb3dzW2kgJSBoZWlnaHRdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzb3VyY2UuY2hpbGRDb3VudDsgaisrKSB7XG4gICAgICAgIGxldCBjZWxsID0gc291cmNlLmNoaWxkKGopO1xuICAgICAgICBpZiAocm93ICsgY2VsbC5hdHRycy5yb3dzcGFuID4gbmV3SGVpZ2h0KVxuICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICAgICAgICByb3dzcGFuOiBNYXRoLm1heCgxLCBuZXdIZWlnaHQgLSBjZWxsLmF0dHJzLnJvd3NwYW4pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VsbC5jb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgIH1cbiAgICAgIG5ld1Jvd3MucHVzaChGcmFnbWVudDIuZnJvbShjZWxscykpO1xuICAgIH1cbiAgICByb3dzID0gbmV3Um93cztcbiAgICBoZWlnaHQgPSBuZXdIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgcm93cyB9O1xufVxuZnVuY3Rpb24gZ3Jvd1RhYmxlKHRyLCBtYXAsIHRhYmxlLCBzdGFydCwgd2lkdGgsIGhlaWdodCwgbWFwRnJvbSkge1xuICBjb25zdCBzY2hlbWEgPSB0ci5kb2MudHlwZS5zY2hlbWE7XG4gIGNvbnN0IHR5cGVzID0gdGFibGVOb2RlVHlwZXMoc2NoZW1hKTtcbiAgbGV0IGVtcHR5O1xuICBsZXQgZW1wdHlIZWFkO1xuICBpZiAod2lkdGggPiBtYXAud2lkdGgpIHtcbiAgICBmb3IgKGxldCByb3cgPSAwLCByb3dFbmQgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuICAgICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgICByb3dFbmQgKz0gcm93Tm9kZS5ub2RlU2l6ZTtcbiAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICBsZXQgYWRkO1xuICAgICAgaWYgKHJvd05vZGUubGFzdENoaWxkID09IG51bGwgfHwgcm93Tm9kZS5sYXN0Q2hpbGQudHlwZSA9PSB0eXBlcy5jZWxsKVxuICAgICAgICBhZGQgPSBlbXB0eSB8fCAoZW1wdHkgPSB0eXBlcy5jZWxsLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFkZCA9IGVtcHR5SGVhZCB8fCAoZW1wdHlIZWFkID0gdHlwZXMuaGVhZGVyX2NlbGwuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgIGZvciAobGV0IGkgPSBtYXAud2lkdGg7IGkgPCB3aWR0aDsgaSsrKVxuICAgICAgICBjZWxscy5wdXNoKGFkZCk7XG4gICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocm93RW5kIC0gMSArIHN0YXJ0KSwgY2VsbHMpO1xuICAgIH1cbiAgfVxuICBpZiAoaGVpZ2h0ID4gbWFwLmhlaWdodCkge1xuICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0MiA9IChtYXAuaGVpZ2h0IC0gMSkgKiBtYXAud2lkdGg7IGkgPCBNYXRoLm1heChtYXAud2lkdGgsIHdpZHRoKTsgaSsrKSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSBpID49IG1hcC53aWR0aCA/IGZhbHNlIDogdGFibGUubm9kZUF0KG1hcC5tYXBbc3RhcnQyICsgaV0pLnR5cGUgPT0gdHlwZXMuaGVhZGVyX2NlbGw7XG4gICAgICBjZWxscy5wdXNoKFxuICAgICAgICBoZWFkZXIgPyBlbXB0eUhlYWQgfHwgKGVtcHR5SGVhZCA9IHR5cGVzLmhlYWRlcl9jZWxsLmNyZWF0ZUFuZEZpbGwoKSkgOiBlbXB0eSB8fCAoZW1wdHkgPSB0eXBlcy5jZWxsLmNyZWF0ZUFuZEZpbGwoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGVtcHR5Um93ID0gdHlwZXMucm93LmNyZWF0ZShudWxsLCBGcmFnbWVudDIuZnJvbShjZWxscykpLCByb3dzID0gW107XG4gICAgZm9yIChsZXQgaSA9IG1hcC5oZWlnaHQ7IGkgPCBoZWlnaHQ7IGkrKylcbiAgICAgIHJvd3MucHVzaChlbXB0eVJvdyk7XG4gICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHN0YXJ0ICsgdGFibGUubm9kZVNpemUgLSAyKSwgcm93cyk7XG4gIH1cbiAgcmV0dXJuICEhKGVtcHR5IHx8IGVtcHR5SGVhZCk7XG59XG5mdW5jdGlvbiBpc29sYXRlSG9yaXpvbnRhbCh0ciwgbWFwLCB0YWJsZSwgc3RhcnQsIGxlZnQsIHJpZ2h0LCB0b3AsIG1hcEZyb20pIHtcbiAgaWYgKHRvcCA9PSAwIHx8IHRvcCA9PSBtYXAuaGVpZ2h0KVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAobGV0IGNvbCA9IGxlZnQ7IGNvbCA8IHJpZ2h0OyBjb2wrKykge1xuICAgIGNvbnN0IGluZGV4ID0gdG9wICogbWFwLndpZHRoICsgY29sLCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICBpZiAobWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0gPT0gcG9zKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBjb25zdCB7IHRvcDogY2VsbFRvcCwgbGVmdDogY2VsbExlZnQgfSA9IG1hcC5maW5kQ2VsbChwb3MpO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyBzdGFydCksIG51bGwsIHtcbiAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgcm93c3BhbjogdG9wIC0gY2VsbFRvcFxuICAgICAgfSk7XG4gICAgICB0ci5pbnNlcnQoXG4gICAgICAgIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKG1hcC5wb3NpdGlvbkF0KHRvcCwgY2VsbExlZnQsIHRhYmxlKSksXG4gICAgICAgIGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKHtcbiAgICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICAgIHJvd3NwYW46IGNlbGxUb3AgKyBjZWxsLmF0dHJzLnJvd3NwYW4gLSB0b3BcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb2wgKz0gY2VsbC5hdHRycy5jb2xzcGFuIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNvbGF0ZVZlcnRpY2FsKHRyLCBtYXAsIHRhYmxlLCBzdGFydCwgdG9wLCBib3R0b20sIGxlZnQsIG1hcEZyb20pIHtcbiAgaWYgKGxlZnQgPT0gMCB8fCBsZWZ0ID09IG1hcC53aWR0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGxldCByb3cgPSB0b3A7IHJvdyA8IGJvdHRvbTsgcm93KyspIHtcbiAgICBjb25zdCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGxlZnQsIHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgIGlmIChtYXAubWFwW2luZGV4IC0gMV0gPT0gcG9zKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBjb25zdCBjZWxsTGVmdCA9IG1hcC5jb2xDb3VudChwb3MpO1xuICAgICAgY29uc3QgdXBkYXRlUG9zID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgc3RhcnQpO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdXBkYXRlUG9zLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW1vdmVDb2xTcGFuKFxuICAgICAgICAgIGNlbGwuYXR0cnMsXG4gICAgICAgICAgbGVmdCAtIGNlbGxMZWZ0LFxuICAgICAgICAgIGNlbGwuYXR0cnMuY29sc3BhbiAtIChsZWZ0IC0gY2VsbExlZnQpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0ci5pbnNlcnQoXG4gICAgICAgIHVwZGF0ZVBvcyArIGNlbGwubm9kZVNpemUsXG4gICAgICAgIGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKFxuICAgICAgICAgIHJlbW92ZUNvbFNwYW4oY2VsbC5hdHRycywgMCwgbGVmdCAtIGNlbGxMZWZ0KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcm93ICs9IGNlbGwuYXR0cnMucm93c3BhbiAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGluc2VydENlbGxzKHN0YXRlLCBkaXNwYXRjaCwgdGFibGVTdGFydCwgcmVjdCwgY2VsbHMpIHtcbiAgbGV0IHRhYmxlID0gdGFibGVTdGFydCA/IHN0YXRlLmRvYy5ub2RlQXQodGFibGVTdGFydCAtIDEpIDogc3RhdGUuZG9jO1xuICBpZiAoIXRhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG4gIH1cbiAgbGV0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSByZWN0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyBjZWxscy53aWR0aCwgYm90dG9tID0gdG9wICsgY2VsbHMuaGVpZ2h0O1xuICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICBsZXQgbWFwRnJvbSA9IDA7XG4gIGZ1bmN0aW9uIHJlY29tcCgpIHtcbiAgICB0YWJsZSA9IHRhYmxlU3RhcnQgPyB0ci5kb2Mubm9kZUF0KHRhYmxlU3RhcnQgLSAxKSA6IHRyLmRvYztcbiAgICBpZiAoIXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcbiAgICB9XG4gICAgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBtYXBGcm9tID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgfVxuICBpZiAoZ3Jvd1RhYmxlKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCByaWdodCwgYm90dG9tLCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVIb3Jpem9udGFsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCBsZWZ0LCByaWdodCwgdG9wLCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVIb3Jpem9udGFsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCBsZWZ0LCByaWdodCwgYm90dG9tLCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVWZXJ0aWNhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgdG9wLCBib3R0b20sIGxlZnQsIG1hcEZyb20pKVxuICAgIHJlY29tcCgpO1xuICBpZiAoaXNvbGF0ZVZlcnRpY2FsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCB0b3AsIGJvdHRvbSwgcmlnaHQsIG1hcEZyb20pKVxuICAgIHJlY29tcCgpO1xuICBmb3IgKGxldCByb3cgPSB0b3A7IHJvdyA8IGJvdHRvbTsgcm93KyspIHtcbiAgICBjb25zdCBmcm9tID0gbWFwLnBvc2l0aW9uQXQocm93LCBsZWZ0LCB0YWJsZSksIHRvID0gbWFwLnBvc2l0aW9uQXQocm93LCByaWdodCwgdGFibGUpO1xuICAgIHRyLnJlcGxhY2UoXG4gICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChmcm9tICsgdGFibGVTdGFydCksXG4gICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcCh0byArIHRhYmxlU3RhcnQpLFxuICAgICAgbmV3IFNsaWNlMihjZWxscy5yb3dzW3JvdyAtIHRvcF0sIDAsIDApXG4gICAgKTtcbiAgfVxuICByZWNvbXAoKTtcbiAgdHIuc2V0U2VsZWN0aW9uKFxuICAgIG5ldyBDZWxsU2VsZWN0aW9uKFxuICAgICAgdHIuZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5wb3NpdGlvbkF0KHRvcCwgbGVmdCwgdGFibGUpKSxcbiAgICAgIHRyLmRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAucG9zaXRpb25BdChib3R0b20gLSAxLCByaWdodCAtIDEsIHRhYmxlKSlcbiAgICApXG4gICk7XG4gIGRpc3BhdGNoKHRyKTtcbn1cblxuLy8gc3JjL2lucHV0LnRzXG52YXIgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgQXJyb3dMZWZ0OiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgQXJyb3dSaWdodDogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgQXJyb3dVcDogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgQXJyb3dEb3duOiBhcnJvdyhcInZlcnRcIiwgMSksXG4gIFwiU2hpZnQtQXJyb3dMZWZ0XCI6IHNoaWZ0QXJyb3coXCJob3JpelwiLCAtMSksXG4gIFwiU2hpZnQtQXJyb3dSaWdodFwiOiBzaGlmdEFycm93KFwiaG9yaXpcIiwgMSksXG4gIFwiU2hpZnQtQXJyb3dVcFwiOiBzaGlmdEFycm93KFwidmVydFwiLCAtMSksXG4gIFwiU2hpZnQtQXJyb3dEb3duXCI6IHNoaWZ0QXJyb3coXCJ2ZXJ0XCIsIDEpLFxuICBCYWNrc3BhY2U6IGRlbGV0ZUNlbGxTZWxlY3Rpb24sXG4gIFwiTW9kLUJhY2tzcGFjZVwiOiBkZWxldGVDZWxsU2VsZWN0aW9uLFxuICBEZWxldGU6IGRlbGV0ZUNlbGxTZWxlY3Rpb24sXG4gIFwiTW9kLURlbGV0ZVwiOiBkZWxldGVDZWxsU2VsZWN0aW9uXG59KTtcbmZ1bmN0aW9uIG1heWJlU2V0U2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgc2VsZWN0aW9uKSB7XG4gIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaClcbiAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhcnJvdyhheGlzLCBkaXIpIHtcbiAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBpZiAoIXZpZXcpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgU2VsZWN0aW9uMi5uZWFyKHNlbC4kaGVhZENlbGwsIGRpcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChheGlzICE9IFwiaG9yaXpcIiAmJiAhc2VsLmVtcHR5KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGVuZCA9IGF0RW5kT2ZDZWxsKHZpZXcsIGF4aXMsIGRpcik7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChheGlzID09IFwiaG9yaXpcIikge1xuICAgICAgcmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIFNlbGVjdGlvbjIubmVhcihzdGF0ZS5kb2MucmVzb2x2ZShzZWwuaGVhZCArIGRpciksIGRpcilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0ICRjZWxsID0gc3RhdGUuZG9jLnJlc29sdmUoZW5kKTtcbiAgICAgIGNvbnN0ICRuZXh0ID0gbmV4dENlbGwoJGNlbGwsIGF4aXMsIGRpcik7XG4gICAgICBsZXQgbmV3U2VsO1xuICAgICAgaWYgKCRuZXh0KVxuICAgICAgICBuZXdTZWwgPSBTZWxlY3Rpb24yLm5lYXIoJG5leHQsIDEpO1xuICAgICAgZWxzZSBpZiAoZGlyIDwgMClcbiAgICAgICAgbmV3U2VsID0gU2VsZWN0aW9uMi5uZWFyKHN0YXRlLmRvYy5yZXNvbHZlKCRjZWxsLmJlZm9yZSgtMSkpLCAtMSk7XG4gICAgICBlbHNlXG4gICAgICAgIG5ld1NlbCA9IFNlbGVjdGlvbjIubmVhcihzdGF0ZS5kb2MucmVzb2x2ZSgkY2VsbC5hZnRlcigtMSkpLCAxKTtcbiAgICAgIHJldHVybiBtYXliZVNldFNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gsIG5ld1NlbCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2hpZnRBcnJvdyhheGlzLCBkaXIpIHtcbiAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBpZiAoIXZpZXcpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBjZWxsU2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgICBjZWxsU2VsID0gc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbmQgPSBhdEVuZE9mQ2VsbCh2aWV3LCBheGlzLCBkaXIpO1xuICAgICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjZWxsU2VsID0gbmV3IENlbGxTZWxlY3Rpb24oc3RhdGUuZG9jLnJlc29sdmUoZW5kKSk7XG4gICAgfVxuICAgIGNvbnN0ICRoZWFkID0gbmV4dENlbGwoY2VsbFNlbC4kaGVhZENlbGwsIGF4aXMsIGRpcik7XG4gICAgaWYgKCEkaGVhZClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oXG4gICAgICBzdGF0ZSxcbiAgICAgIGRpc3BhdGNoLFxuICAgICAgbmV3IENlbGxTZWxlY3Rpb24oY2VsbFNlbC4kYW5jaG9yQ2VsbCwgJGhlYWQpXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNlbGxTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgIGNvbnN0IGJhc2VDb250ZW50ID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKS5jZWxsLmNyZWF0ZUFuZEZpbGwoKS5jb250ZW50O1xuICAgIHNlbC5mb3JFYWNoQ2VsbCgoY2VsbCwgcG9zKSA9PiB7XG4gICAgICBpZiAoIWNlbGwuY29udGVudC5lcShiYXNlQ29udGVudCkpXG4gICAgICAgIHRyLnJlcGxhY2UoXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAocG9zICsgMSksXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAocG9zICsgY2VsbC5ub2RlU2l6ZSAtIDEpLFxuICAgICAgICAgIG5ldyBTbGljZTMoYmFzZUNvbnRlbnQsIDAsIDApXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgICBkaXNwYXRjaCh0cik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYW5kbGVUcmlwbGVDbGljayh2aWV3LCBwb3MpIHtcbiAgY29uc3QgZG9jID0gdmlldy5zdGF0ZS5kb2MsICRjZWxsID0gY2VsbEFyb3VuZChkb2MucmVzb2x2ZShwb3MpKTtcbiAgaWYgKCEkY2VsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IENlbGxTZWxlY3Rpb24oJGNlbGwpKSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFzdGUodmlldywgXywgc2xpY2UpIHtcbiAgaWYgKCFpc0luVGFibGUodmlldy5zdGF0ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgY2VsbHMgPSBwYXN0ZWRDZWxscyhzbGljZSk7XG4gIGNvbnN0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgIGlmICghY2VsbHMpXG4gICAgICBjZWxscyA9IHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgcm93czogW1xuICAgICAgICAgIEZyYWdtZW50My5mcm9tKFxuICAgICAgICAgICAgZml0U2xpY2UodGFibGVOb2RlVHlwZXModmlldy5zdGF0ZS5zY2hlbWEpLmNlbGwsIHNsaWNlKVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICBjb25zdCB0YWJsZSA9IHNlbC4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBzdGFydCA9IHNlbC4kYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgcmVjdCA9IFRhYmxlTWFwLmdldCh0YWJsZSkucmVjdEJldHdlZW4oXG4gICAgICBzZWwuJGFuY2hvckNlbGwucG9zIC0gc3RhcnQsXG4gICAgICBzZWwuJGhlYWRDZWxsLnBvcyAtIHN0YXJ0XG4gICAgKTtcbiAgICBjZWxscyA9IGNsaXBDZWxscyhjZWxscywgcmVjdC5yaWdodCAtIHJlY3QubGVmdCwgcmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgaW5zZXJ0Q2VsbHModmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgc3RhcnQsIHJlY3QsIGNlbGxzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjZWxscykge1xuICAgIGNvbnN0ICRjZWxsID0gc2VsZWN0aW9uQ2VsbCh2aWV3LnN0YXRlKTtcbiAgICBjb25zdCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgICBpbnNlcnRDZWxscyhcbiAgICAgIHZpZXcuc3RhdGUsXG4gICAgICB2aWV3LmRpc3BhdGNoLFxuICAgICAgc3RhcnQsXG4gICAgICBUYWJsZU1hcC5nZXQoJGNlbGwubm9kZSgtMSkpLmZpbmRDZWxsKCRjZWxsLnBvcyAtIHN0YXJ0KSxcbiAgICAgIGNlbGxzXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bih2aWV3LCBzdGFydEV2ZW50KSB7XG4gIHZhciBfYTtcbiAgaWYgKHN0YXJ0RXZlbnQuY3RybEtleSB8fCBzdGFydEV2ZW50Lm1ldGFLZXkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzdGFydERPTUNlbGwgPSBkb21JbkNlbGwodmlldywgc3RhcnRFdmVudC50YXJnZXQpO1xuICBsZXQgJGFuY2hvcjtcbiAgaWYgKHN0YXJ0RXZlbnQuc2hpZnRLZXkgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgc2V0Q2VsbFNlbGVjdGlvbih2aWV3LnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yQ2VsbCwgc3RhcnRFdmVudCk7XG4gICAgc3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2UgaWYgKHN0YXJ0RXZlbnQuc2hpZnRLZXkgJiYgc3RhcnRET01DZWxsICYmICgkYW5jaG9yID0gY2VsbEFyb3VuZCh2aWV3LnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yKSkgIT0gbnVsbCAmJiAoKF9hID0gY2VsbFVuZGVyTW91c2Uodmlldywgc3RhcnRFdmVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wb3MpICE9ICRhbmNob3IucG9zKSB7XG4gICAgc2V0Q2VsbFNlbGVjdGlvbigkYW5jaG9yLCBzdGFydEV2ZW50KTtcbiAgICBzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSBpZiAoIXN0YXJ0RE9NQ2VsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmdW5jdGlvbiBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IyLCBldmVudCkge1xuICAgIGxldCAkaGVhZCA9IGNlbGxVbmRlck1vdXNlKHZpZXcsIGV2ZW50KTtcbiAgICBjb25zdCBzdGFydGluZyA9IHRhYmxlRWRpdGluZ0tleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKSA9PSBudWxsO1xuICAgIGlmICghJGhlYWQgfHwgIWluU2FtZVRhYmxlKCRhbmNob3IyLCAkaGVhZCkpIHtcbiAgICAgIGlmIChzdGFydGluZylcbiAgICAgICAgJGhlYWQgPSAkYW5jaG9yMjtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgQ2VsbFNlbGVjdGlvbigkYW5jaG9yMiwgJGhlYWQpO1xuICAgIGlmIChzdGFydGluZyB8fCAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgaWYgKHN0YXJ0aW5nKVxuICAgICAgICB0ci5zZXRNZXRhKHRhYmxlRWRpdGluZ0tleSwgJGFuY2hvcjIucG9zKTtcbiAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wKTtcbiAgICB2aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBzdG9wKTtcbiAgICB2aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICBpZiAodGFibGVFZGl0aW5nS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpICE9IG51bGwpXG4gICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0TWV0YSh0YWJsZUVkaXRpbmdLZXksIC0xKSk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShfZXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICBjb25zdCBhbmNob3IgPSB0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgbGV0ICRhbmNob3IyO1xuICAgIGlmIChhbmNob3IgIT0gbnVsbCkge1xuICAgICAgJGFuY2hvcjIgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgfSBlbHNlIGlmIChkb21JbkNlbGwodmlldywgZXZlbnQudGFyZ2V0KSAhPSBzdGFydERPTUNlbGwpIHtcbiAgICAgICRhbmNob3IyID0gY2VsbFVuZGVyTW91c2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICBpZiAoISRhbmNob3IyKVxuICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBpZiAoJGFuY2hvcjIpXG4gICAgICBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IyLCBldmVudCk7XG4gIH1cbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3ApO1xuICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBzdG9wKTtcbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG59XG5mdW5jdGlvbiBhdEVuZE9mQ2VsbCh2aWV3LCBheGlzLCBkaXIpIHtcbiAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uMikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgJGhlYWQgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBmb3IgKGxldCBkID0gJGhlYWQuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgIGNvbnN0IHBhcmVudCA9ICRoZWFkLm5vZGUoZCksIGluZGV4ID0gZGlyIDwgMCA/ICRoZWFkLmluZGV4KGQpIDogJGhlYWQuaW5kZXhBZnRlcihkKTtcbiAgICBpZiAoaW5kZXggIT0gKGRpciA8IDAgPyAwIDogcGFyZW50LmNoaWxkQ291bnQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwiY2VsbFwiIHx8IHBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgICAgY29uc3QgY2VsbFBvcyA9ICRoZWFkLmJlZm9yZShkKTtcbiAgICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyBkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIgOiBkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgICByZXR1cm4gdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpID8gY2VsbFBvcyA6IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZG9tSW5DZWxsKHZpZXcsIGRvbSkge1xuICBmb3IgKDsgZG9tICYmIGRvbSAhPSB2aWV3LmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVERcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJUSFwiKSB7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNlbGxVbmRlck1vdXNlKHZpZXcsIGV2ZW50KSB7XG4gIGNvbnN0IG1vdXNlUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7XG4gICAgbGVmdDogZXZlbnQuY2xpZW50WCxcbiAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgfSk7XG4gIGlmICghbW91c2VQb3MpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtb3VzZVBvcyA/IGNlbGxBcm91bmQodmlldy5zdGF0ZS5kb2MucmVzb2x2ZShtb3VzZVBvcy5wb3MpKSA6IG51bGw7XG59XG5cbi8vIHNyYy9jb2x1bW5yZXNpemluZy50c1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MyB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuaW1wb3J0IHtcbiAgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMixcbiAgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MlxufSBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuXG4vLyBzcmMvdGFibGV2aWV3LnRzXG52YXIgVGFibGVWaWV3ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBjZWxsTWluV2lkdGgpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuY2VsbE1pbldpZHRoID0gY2VsbE1pbldpZHRoO1xuICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcInRhYmxlV3JhcHBlclwiO1xuICAgIHRoaXMudGFibGUgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGFibGVcIikpO1xuICAgIHRoaXMuY29sZ3JvdXAgPSB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2xncm91cFwiKSk7XG4gICAgdXBkYXRlQ29sdW1uc09uUmVzaXplKG5vZGUsIHRoaXMuY29sZ3JvdXAsIHRoaXMudGFibGUsIGNlbGxNaW5XaWR0aCk7XG4gICAgdGhpcy5jb250ZW50RE9NID0gdGhpcy50YWJsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpO1xuICB9XG4gIHVwZGF0ZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPSB0aGlzLm5vZGUudHlwZSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShub2RlLCB0aGlzLmNvbGdyb3VwLCB0aGlzLnRhYmxlLCB0aGlzLmNlbGxNaW5XaWR0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWdub3JlTXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmIChyZWNvcmQudGFyZ2V0ID09IHRoaXMudGFibGUgfHwgdGhpcy5jb2xncm91cC5jb250YWlucyhyZWNvcmQudGFyZ2V0KSk7XG4gIH1cbn07XG5mdW5jdGlvbiB1cGRhdGVDb2x1bW5zT25SZXNpemUobm9kZSwgY29sZ3JvdXAsIHRhYmxlLCBjZWxsTWluV2lkdGgsIG92ZXJyaWRlQ29sLCBvdmVycmlkZVZhbHVlKSB7XG4gIHZhciBfYTtcbiAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICBsZXQgZml4ZWRXaWR0aCA9IHRydWU7XG4gIGxldCBuZXh0RE9NID0gY29sZ3JvdXAuZmlyc3RDaGlsZDtcbiAgY29uc3Qgcm93ID0gbm9kZS5maXJzdENoaWxkO1xuICBpZiAoIXJvdylcbiAgICByZXR1cm47XG4gIGZvciAobGV0IGkgPSAwLCBjb2wgPSAwOyBpIDwgcm93LmNoaWxkQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IHsgY29sc3BhbiwgY29sd2lkdGggfSA9IHJvdy5jaGlsZChpKS5hdHRycztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHNwYW47IGorKywgY29sKyspIHtcbiAgICAgIGNvbnN0IGhhc1dpZHRoID0gb3ZlcnJpZGVDb2wgPT0gY29sID8gb3ZlcnJpZGVWYWx1ZSA6IGNvbHdpZHRoICYmIGNvbHdpZHRoW2pdO1xuICAgICAgY29uc3QgY3NzV2lkdGggPSBoYXNXaWR0aCA/IGhhc1dpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgIHRvdGFsV2lkdGggKz0gaGFzV2lkdGggfHwgY2VsbE1pbldpZHRoO1xuICAgICAgaWYgKCFoYXNXaWR0aClcbiAgICAgICAgZml4ZWRXaWR0aCA9IGZhbHNlO1xuICAgICAgaWYgKCFuZXh0RE9NKSB7XG4gICAgICAgIGNvbGdyb3VwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2xcIikpLnN0eWxlLndpZHRoID0gY3NzV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV4dERPTS5zdHlsZS53aWR0aCAhPSBjc3NXaWR0aClcbiAgICAgICAgICBuZXh0RE9NLnN0eWxlLndpZHRoID0gY3NzV2lkdGg7XG4gICAgICAgIG5leHRET00gPSBuZXh0RE9NLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAobmV4dERPTSkge1xuICAgIGNvbnN0IGFmdGVyID0gbmV4dERPTS5uZXh0U2libGluZztcbiAgICAoX2EgPSBuZXh0RE9NLnBhcmVudE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChuZXh0RE9NKTtcbiAgICBuZXh0RE9NID0gYWZ0ZXI7XG4gIH1cbiAgaWYgKGZpeGVkV2lkdGgpIHtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9IHRvdGFsV2lkdGggKyBcInB4XCI7XG4gICAgdGFibGUuc3R5bGUubWluV2lkdGggPSBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICB0YWJsZS5zdHlsZS5taW5XaWR0aCA9IHRvdGFsV2lkdGggKyBcInB4XCI7XG4gIH1cbn1cblxuLy8gc3JjL2NvbHVtbnJlc2l6aW5nLnRzXG52YXIgY29sdW1uUmVzaXppbmdQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5MyhcbiAgXCJ0YWJsZUNvbHVtblJlc2l6aW5nXCJcbik7XG5mdW5jdGlvbiBjb2x1bW5SZXNpemluZyh7XG4gIGhhbmRsZVdpZHRoID0gNSxcbiAgY2VsbE1pbldpZHRoID0gMjUsXG4gIFZpZXcgPSBUYWJsZVZpZXcsXG4gIGxhc3RDb2x1bW5SZXNpemFibGUgPSB0cnVlXG59ID0ge30pIHtcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAga2V5OiBjb2x1bW5SZXNpemluZ1BsdWdpbktleSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdChfLCBzdGF0ZSkge1xuICAgICAgICBwbHVnaW4uc3BlYy5wcm9wcy5ub2RlVmlld3NbdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKS50YWJsZS5uYW1lXSA9IChub2RlLCB2aWV3KSA9PiBuZXcgVmlldyhub2RlLCBjZWxsTWluV2lkdGgsIHZpZXcpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZVN0YXRlKC0xLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgcmV0dXJuIHByZXYuYXBwbHkodHIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGF0dHJpYnV0ZXM6IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xID8geyBjbGFzczogXCJyZXNpemUtY3Vyc29yXCIgfSA6IHt9O1xuICAgICAgfSxcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZShcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGhhbmRsZVdpZHRoLFxuICAgICAgICAgICAgY2VsbE1pbldpZHRoLFxuICAgICAgICAgICAgbGFzdENvbHVtblJlc2l6YWJsZVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbGVhdmU6ICh2aWV3KSA9PiB7XG4gICAgICAgICAgaGFuZGxlTW91c2VMZWF2ZSh2aWV3KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vkb3duOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICBoYW5kbGVNb3VzZURvd24yKHZpZXcsIGV2ZW50LCBjZWxsTWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGlvbnM6IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgaWYgKHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZURlY29yYXRpb25zKHN0YXRlLCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm9kZVZpZXdzOiB7fVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwbHVnaW47XG59XG52YXIgUmVzaXplU3RhdGUgPSBjbGFzcyBfUmVzaXplU3RhdGUge1xuICBjb25zdHJ1Y3RvcihhY3RpdmVIYW5kbGUsIGRyYWdnaW5nKSB7XG4gICAgdGhpcy5hY3RpdmVIYW5kbGUgPSBhY3RpdmVIYW5kbGU7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICB9XG4gIGFwcGx5KHRyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRyLmdldE1ldGEoY29sdW1uUmVzaXppbmdQbHVnaW5LZXkpO1xuICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLnNldEhhbmRsZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG5ldyBfUmVzaXplU3RhdGUoYWN0aW9uLnNldEhhbmRsZSwgZmFsc2UpO1xuICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLnNldERyYWdnaW5nICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbmV3IF9SZXNpemVTdGF0ZShzdGF0ZS5hY3RpdmVIYW5kbGUsIGFjdGlvbi5zZXREcmFnZ2luZyk7XG4gICAgaWYgKHN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xICYmIHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgIGxldCBoYW5kbGUgPSB0ci5tYXBwaW5nLm1hcChzdGF0ZS5hY3RpdmVIYW5kbGUsIC0xKTtcbiAgICAgIGlmICghcG9pbnRzQXRDZWxsKHRyLmRvYy5yZXNvbHZlKGhhbmRsZSkpKSB7XG4gICAgICAgIGhhbmRsZSA9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfUmVzaXplU3RhdGUoaGFuZGxlLCBzdGF0ZS5kcmFnZ2luZyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgaGFuZGxlV2lkdGgsIGNlbGxNaW5XaWR0aCwgbGFzdENvbHVtblJlc2l6YWJsZSkge1xuICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICBpZiAoIXBsdWdpblN0YXRlKVxuICAgIHJldHVybjtcbiAgaWYgKCFwbHVnaW5TdGF0ZS5kcmFnZ2luZykge1xuICAgIGNvbnN0IHRhcmdldCA9IGRvbUNlbGxBcm91bmQoZXZlbnQudGFyZ2V0KTtcbiAgICBsZXQgY2VsbCA9IC0xO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbGVmdCA8PSBoYW5kbGVXaWR0aClcbiAgICAgICAgY2VsbCA9IGVkZ2VDZWxsKHZpZXcsIGV2ZW50LCBcImxlZnRcIiwgaGFuZGxlV2lkdGgpO1xuICAgICAgZWxzZSBpZiAocmlnaHQgLSBldmVudC5jbGllbnRYIDw9IGhhbmRsZVdpZHRoKVxuICAgICAgICBjZWxsID0gZWRnZUNlbGwodmlldywgZXZlbnQsIFwicmlnaHRcIiwgaGFuZGxlV2lkdGgpO1xuICAgIH1cbiAgICBpZiAoY2VsbCAhPSBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpIHtcbiAgICAgIGlmICghbGFzdENvbHVtblJlc2l6YWJsZSAmJiBjZWxsICE9PSAtMSkge1xuICAgICAgICBjb25zdCAkY2VsbCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSk7XG4gICAgICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgICAgIGNvbnN0IHRhYmxlU3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gICAgICAgIGNvbnN0IGNvbCA9IG1hcC5jb2xDb3VudCgkY2VsbC5wb3MgLSB0YWJsZVN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcbiAgICAgICAgaWYgKGNvbCA9PSBtYXAud2lkdGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVIYW5kbGUodmlldywgY2VsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKHZpZXcpIHtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgaWYgKHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xICYmICFwbHVnaW5TdGF0ZS5kcmFnZ2luZylcbiAgICB1cGRhdGVIYW5kbGUodmlldywgLTEpO1xufVxuZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duMih2aWV3LCBldmVudCwgY2VsbE1pbldpZHRoKSB7XG4gIGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gIGlmICghcGx1Z2luU3RhdGUgfHwgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlID09IC0xIHx8IHBsdWdpblN0YXRlLmRyYWdnaW5nKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgY2VsbCA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpO1xuICBjb25zdCB3aWR0aCA9IGN1cnJlbnRDb2xXaWR0aCh2aWV3LCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUsIGNlbGwuYXR0cnMpO1xuICB2aWV3LmRpc3BhdGNoKFxuICAgIHZpZXcuc3RhdGUudHIuc2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSwge1xuICAgICAgc2V0RHJhZ2dpbmc6IHsgc3RhcnRYOiBldmVudC5jbGllbnRYLCBzdGFydFdpZHRoOiB3aWR0aCB9XG4gICAgfSlcbiAgKTtcbiAgZnVuY3Rpb24gZmluaXNoKGV2ZW50Mikge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmaW5pc2gpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgIGNvbnN0IHBsdWdpblN0YXRlMiA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgIGlmIChwbHVnaW5TdGF0ZTIgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpblN0YXRlMi5kcmFnZ2luZykge1xuICAgICAgdXBkYXRlQ29sdW1uV2lkdGgoXG4gICAgICAgIHZpZXcsXG4gICAgICAgIHBsdWdpblN0YXRlMi5hY3RpdmVIYW5kbGUsXG4gICAgICAgIGRyYWdnZWRXaWR0aChwbHVnaW5TdGF0ZTIuZHJhZ2dpbmcsIGV2ZW50MiwgY2VsbE1pbldpZHRoKVxuICAgICAgKTtcbiAgICAgIHZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHZpZXcuc3RhdGUudHIuc2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSwgeyBzZXREcmFnZ2luZzogbnVsbCB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShldmVudDIpIHtcbiAgICBpZiAoIWV2ZW50Mi53aGljaClcbiAgICAgIHJldHVybiBmaW5pc2goZXZlbnQyKTtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZTIgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXBsdWdpblN0YXRlMilcbiAgICAgIHJldHVybjtcbiAgICBpZiAocGx1Z2luU3RhdGUyLmRyYWdnaW5nKSB7XG4gICAgICBjb25zdCBkcmFnZ2VkID0gZHJhZ2dlZFdpZHRoKHBsdWdpblN0YXRlMi5kcmFnZ2luZywgZXZlbnQyLCBjZWxsTWluV2lkdGgpO1xuICAgICAgZGlzcGxheUNvbHVtbldpZHRoKHZpZXcsIHBsdWdpblN0YXRlMi5hY3RpdmVIYW5kbGUsIGRyYWdnZWQsIGNlbGxNaW5XaWR0aCk7XG4gICAgfVxuICB9XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmaW5pc2gpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjdXJyZW50Q29sV2lkdGgodmlldywgY2VsbFBvcywgeyBjb2xzcGFuLCBjb2x3aWR0aCB9KSB7XG4gIGNvbnN0IHdpZHRoID0gY29sd2lkdGggJiYgY29sd2lkdGhbY29sd2lkdGgubGVuZ3RoIC0gMV07XG4gIGlmICh3aWR0aClcbiAgICByZXR1cm4gd2lkdGg7XG4gIGNvbnN0IGRvbSA9IHZpZXcuZG9tQXRQb3MoY2VsbFBvcyk7XG4gIGNvbnN0IG5vZGUgPSBkb20ubm9kZS5jaGlsZE5vZGVzW2RvbS5vZmZzZXRdO1xuICBsZXQgZG9tV2lkdGggPSBub2RlLm9mZnNldFdpZHRoLCBwYXJ0cyA9IGNvbHNwYW47XG4gIGlmIChjb2x3aWR0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sc3BhbjsgaSsrKVxuICAgICAgaWYgKGNvbHdpZHRoW2ldKSB7XG4gICAgICAgIGRvbVdpZHRoIC09IGNvbHdpZHRoW2ldO1xuICAgICAgICBwYXJ0cy0tO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBkb21XaWR0aCAvIHBhcnRzO1xufVxuZnVuY3Rpb24gZG9tQ2VsbEFyb3VuZCh0YXJnZXQpIHtcbiAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgIT0gXCJURFwiICYmIHRhcmdldC5ub2RlTmFtZSAhPSBcIlRIXCIpXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNsYXNzTGlzdCAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiUHJvc2VNaXJyb3JcIikgPyBudWxsIDogdGFyZ2V0LnBhcmVudE5vZGU7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBlZGdlQ2VsbCh2aWV3LCBldmVudCwgc2lkZSwgaGFuZGxlV2lkdGgpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2lkZSA9PSBcInJpZ2h0XCIgPyAtaGFuZGxlV2lkdGggOiBoYW5kbGVXaWR0aDtcbiAgY29uc3QgZm91bmQgPSB2aWV3LnBvc0F0Q29vcmRzKHtcbiAgICBsZWZ0OiBldmVudC5jbGllbnRYICsgb2Zmc2V0LFxuICAgIHRvcDogZXZlbnQuY2xpZW50WVxuICB9KTtcbiAgaWYgKCFmb3VuZClcbiAgICByZXR1cm4gLTE7XG4gIGNvbnN0IHsgcG9zIH0gPSBmb3VuZDtcbiAgY29uc3QgJGNlbGwgPSBjZWxsQXJvdW5kKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKSk7XG4gIGlmICghJGNlbGwpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAoc2lkZSA9PSBcInJpZ2h0XCIpXG4gICAgcmV0dXJuICRjZWxsLnBvcztcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KCRjZWxsLm5vZGUoLTEpKSwgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gIGNvbnN0IGluZGV4ID0gbWFwLm1hcC5pbmRleE9mKCRjZWxsLnBvcyAtIHN0YXJ0KTtcbiAgcmV0dXJuIGluZGV4ICUgbWFwLndpZHRoID09IDAgPyAtMSA6IHN0YXJ0ICsgbWFwLm1hcFtpbmRleCAtIDFdO1xufVxuZnVuY3Rpb24gZHJhZ2dlZFdpZHRoKGRyYWdnaW5nLCBldmVudCwgY2VsbE1pbldpZHRoKSB7XG4gIGNvbnN0IG9mZnNldCA9IGV2ZW50LmNsaWVudFggLSBkcmFnZ2luZy5zdGFydFg7XG4gIHJldHVybiBNYXRoLm1heChjZWxsTWluV2lkdGgsIGRyYWdnaW5nLnN0YXJ0V2lkdGggKyBvZmZzZXQpO1xufVxuZnVuY3Rpb24gdXBkYXRlSGFuZGxlKHZpZXcsIHZhbHVlKSB7XG4gIHZpZXcuZGlzcGF0Y2goXG4gICAgdmlldy5zdGF0ZS50ci5zZXRNZXRhKGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LCB7IHNldEhhbmRsZTogdmFsdWUgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbHVtbldpZHRoKHZpZXcsIGNlbGwsIHdpZHRoKSB7XG4gIGNvbnN0ICRjZWxsID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKSwgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKSwgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gIGNvbnN0IGNvbCA9IG1hcC5jb2xDb3VudCgkY2VsbC5wb3MgLSBzdGFydCkgKyAkY2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbiAtIDE7XG4gIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCBtYXBJbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGNvbDtcbiAgICBpZiAocm93ICYmIG1hcC5tYXBbbWFwSW5kZXhdID09IG1hcC5tYXBbbWFwSW5kZXggLSBtYXAud2lkdGhdKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFttYXBJbmRleF07XG4gICAgY29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcbiAgICBjb25zdCBpbmRleCA9IGF0dHJzLmNvbHNwYW4gPT0gMSA/IDAgOiBjb2wgLSBtYXAuY29sQ291bnQocG9zKTtcbiAgICBpZiAoYXR0cnMuY29sd2lkdGggJiYgYXR0cnMuY29sd2lkdGhbaW5kZXhdID09IHdpZHRoKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgY29sd2lkdGggPSBhdHRycy5jb2x3aWR0aCA/IGF0dHJzLmNvbHdpZHRoLnNsaWNlKCkgOiB6ZXJvZXMoYXR0cnMuY29sc3Bhbik7XG4gICAgY29sd2lkdGhbaW5kZXhdID0gd2lkdGg7XG4gICAgdHIuc2V0Tm9kZU1hcmt1cChzdGFydCArIHBvcywgbnVsbCwgeyAuLi5hdHRycywgY29sd2lkdGggfSk7XG4gIH1cbiAgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5mdW5jdGlvbiBkaXNwbGF5Q29sdW1uV2lkdGgodmlldywgY2VsbCwgd2lkdGgsIGNlbGxNaW5XaWR0aCkge1xuICBjb25zdCAkY2VsbCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSksIHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICBjb25zdCBjb2wgPSBUYWJsZU1hcC5nZXQodGFibGUpLmNvbENvdW50KCRjZWxsLnBvcyAtIHN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcbiAgbGV0IGRvbSA9IHZpZXcuZG9tQXRQb3MoJGNlbGwuc3RhcnQoLTEpKS5ub2RlO1xuICB3aGlsZSAoZG9tICYmIGRvbS5ub2RlTmFtZSAhPSBcIlRBQkxFXCIpIHtcbiAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoIWRvbSlcbiAgICByZXR1cm47XG4gIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShcbiAgICB0YWJsZSxcbiAgICBkb20uZmlyc3RDaGlsZCxcbiAgICBkb20sXG4gICAgY2VsbE1pbldpZHRoLFxuICAgIGNvbCxcbiAgICB3aWR0aFxuICApO1xufVxuZnVuY3Rpb24gemVyb2VzKG4pIHtcbiAgcmV0dXJuIEFycmF5KG4pLmZpbGwoMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVEZWNvcmF0aW9ucyhzdGF0ZSwgY2VsbCkge1xuICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICBjb25zdCAkY2VsbCA9IHN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuICBjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpO1xuICBpZiAoIXRhYmxlKSB7XG4gICAgcmV0dXJuIERlY29yYXRpb25TZXQyLmVtcHR5O1xuICB9XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICBjb25zdCBjb2wgPSBtYXAuY29sQ291bnQoJGNlbGwucG9zIC0gc3RhcnQpICsgJGNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW47XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb2wgKyByb3cgKiBtYXAud2lkdGggLSAxO1xuICAgIGlmICgoY29sID09IG1hcC53aWR0aCB8fCBtYXAubWFwW2luZGV4XSAhPSBtYXAubWFwW2luZGV4ICsgMV0pICYmIChyb3cgPT0gMCB8fCBtYXAubWFwW2luZGV4XSAhPSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkpIHtcbiAgICAgIGNvbnN0IGNlbGxQb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IHBvcyA9IHN0YXJ0ICsgY2VsbFBvcyArIHRhYmxlLm5vZGVBdChjZWxsUG9zKS5ub2RlU2l6ZSAtIDE7XG4gICAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY29sdW1uLXJlc2l6ZS1oYW5kbGVcIjtcbiAgICAgIGRlY29yYXRpb25zLnB1c2goRGVjb3JhdGlvbjIud2lkZ2V0KHBvcywgZG9tKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBEZWNvcmF0aW9uU2V0Mi5jcmVhdGUoc3RhdGUuZG9jLCBkZWNvcmF0aW9ucyk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQ0IH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge1xuICBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb24zXG59IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuZnVuY3Rpb24gc2VsZWN0ZWRSZWN0KHN0YXRlKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgJHBvcyA9IHNlbGVjdGlvbkNlbGwoc3RhdGUpO1xuICBjb25zdCB0YWJsZSA9ICRwb3Mubm9kZSgtMSk7XG4gIGNvbnN0IHRhYmxlU3RhcnQgPSAkcG9zLnN0YXJ0KC0xKTtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgY29uc3QgcmVjdCA9IHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24gPyBtYXAucmVjdEJldHdlZW4oXG4gICAgc2VsLiRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQsXG4gICAgc2VsLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICkgOiBtYXAuZmluZENlbGwoJHBvcy5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgcmV0dXJuIHsgLi4ucmVjdCwgdGFibGVTdGFydCwgbWFwLCB0YWJsZSB9O1xufVxuZnVuY3Rpb24gYWRkQ29sdW1uKHRyLCB7IG1hcCwgdGFibGVTdGFydCwgdGFibGUgfSwgY29sKSB7XG4gIGxldCByZWZDb2x1bW4gPSBjb2wgPiAwID8gLTEgOiAwO1xuICBpZiAoY29sdW1uSXNIZWFkZXIobWFwLCB0YWJsZSwgY29sICsgcmVmQ29sdW1uKSkge1xuICAgIHJlZkNvbHVtbiA9IGNvbCA9PSAwIHx8IGNvbCA9PSBtYXAud2lkdGggPyBudWxsIDogMDtcbiAgfVxuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuICAgIGNvbnN0IGluZGV4ID0gcm93ICogbWFwLndpZHRoICsgY29sO1xuICAgIGlmIChjb2wgPiAwICYmIGNvbCA8IG1hcC53aWR0aCAmJiBtYXAubWFwW2luZGV4IC0gMV0gPT0gbWFwLm1hcFtpbmRleF0pIHtcbiAgICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdHIubWFwcGluZy5tYXAodGFibGVTdGFydCArIHBvcyksXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFkZENvbFNwYW4oY2VsbC5hdHRycywgY29sIC0gbWFwLmNvbENvdW50KHBvcykpXG4gICAgICApO1xuICAgICAgcm93ICs9IGNlbGwuYXR0cnMucm93c3BhbiAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSByZWZDb2x1bW4gPT0gbnVsbCA/IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5jZWxsIDogdGFibGUubm9kZUF0KG1hcC5tYXBbaW5kZXggKyByZWZDb2x1bW5dKS50eXBlO1xuICAgICAgY29uc3QgcG9zID0gbWFwLnBvc2l0aW9uQXQocm93LCBjb2wsIHRhYmxlKTtcbiAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBhZGRDb2x1bW5CZWZvcmUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGRpc3BhdGNoKGFkZENvbHVtbihzdGF0ZS50ciwgcmVjdCwgcmVjdC5sZWZ0KSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhZGRDb2x1bW5BZnRlcihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgZGlzcGF0Y2goYWRkQ29sdW1uKHN0YXRlLnRyLCByZWN0LCByZWN0LnJpZ2h0KSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmVDb2x1bW4odHIsIHsgbWFwLCB0YWJsZSwgdGFibGVTdGFydCB9LCBjb2wpIHtcbiAgY29uc3QgbWFwU3RhcnQgPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyApIHtcbiAgICBjb25zdCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGNvbDtcbiAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgY29uc3QgYXR0cnMgPSBjZWxsLmF0dHJzO1xuICAgIGlmIChjb2wgPiAwICYmIG1hcC5tYXBbaW5kZXggLSAxXSA9PSBwb3MgfHwgY29sIDwgbWFwLndpZHRoIC0gMSAmJiBtYXAubWFwW2luZGV4ICsgMV0gPT0gcG9zKSB7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAodGFibGVTdGFydCArIHBvcyksXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlbW92ZUNvbFNwYW4oYXR0cnMsIGNvbCAtIG1hcC5jb2xDb3VudChwb3MpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAodGFibGVTdGFydCArIHBvcyk7XG4gICAgICB0ci5kZWxldGUoc3RhcnQsIHN0YXJ0ICsgY2VsbC5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIHJvdyArPSBhdHRycy5yb3dzcGFuO1xuICB9XG59XG5mdW5jdGlvbiBkZWxldGVDb2x1bW4oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgaWYgKHJlY3QubGVmdCA9PSAwICYmIHJlY3QucmlnaHQgPT0gcmVjdC5tYXAud2lkdGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IHJlY3QucmlnaHQgLSAxOyA7IGktLSkge1xuICAgICAgcmVtb3ZlQ29sdW1uKHRyLCByZWN0LCBpKTtcbiAgICAgIGlmIChpID09IHJlY3QubGVmdClcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCB0YWJsZSA9IHJlY3QudGFibGVTdGFydCA/IHRyLmRvYy5ub2RlQXQocmVjdC50YWJsZVN0YXJ0IC0gMSkgOiB0ci5kb2M7XG4gICAgICBpZiAoIXRhYmxlKSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJlY3QudGFibGUgPSB0YWJsZTtcbiAgICAgIHJlY3QubWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICB9XG4gICAgZGlzcGF0Y2godHIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcm93SXNIZWFkZXIobWFwLCB0YWJsZSwgcm93KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgaGVhZGVyQ2VsbCA9IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5oZWFkZXJfY2VsbDtcbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWFwLndpZHRoOyBjb2wrKylcbiAgICBpZiAoKChfYSA9IHRhYmxlLm5vZGVBdChtYXAubWFwW2NvbCArIHJvdyAqIG1hcC53aWR0aF0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZSkgIT0gaGVhZGVyQ2VsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhZGRSb3codHIsIHsgbWFwLCB0YWJsZVN0YXJ0LCB0YWJsZSB9LCByb3cpIHtcbiAgdmFyIF9hO1xuICBsZXQgcm93UG9zID0gdGFibGVTdGFydDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3c7IGkrKylcbiAgICByb3dQb3MgKz0gdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIGxldCByZWZSb3cgPSByb3cgPiAwID8gLTEgOiAwO1xuICBpZiAocm93SXNIZWFkZXIobWFwLCB0YWJsZSwgcm93ICsgcmVmUm93KSlcbiAgICByZWZSb3cgPSByb3cgPT0gMCB8fCByb3cgPT0gbWFwLmhlaWdodCA/IG51bGwgOiAwO1xuICBmb3IgKGxldCBjb2wgPSAwLCBpbmRleCA9IG1hcC53aWR0aCAqIHJvdzsgY29sIDwgbWFwLndpZHRoOyBjb2wrKywgaW5kZXgrKykge1xuICAgIGlmIChyb3cgPiAwICYmIHJvdyA8IG1hcC5oZWlnaHQgJiYgbWFwLm1hcFtpbmRleF0gPT0gbWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0pIHtcbiAgICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgICAgY29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodGFibGVTdGFydCArIHBvcywgbnVsbCwge1xuICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgcm93c3BhbjogYXR0cnMucm93c3BhbiArIDFcbiAgICAgIH0pO1xuICAgICAgY29sICs9IGF0dHJzLmNvbHNwYW4gLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gcmVmUm93ID09IG51bGwgPyB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkuY2VsbCA6IChfYSA9IHRhYmxlLm5vZGVBdChtYXAubWFwW2luZGV4ICsgcmVmUm93ICogbWFwLndpZHRoXSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlO1xuICAgICAgY29uc3Qgbm9kZSA9IHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgaWYgKG5vZGUpXG4gICAgICAgIGNlbGxzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHRyLmluc2VydChyb3dQb3MsIHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5yb3cuY3JlYXRlKG51bGwsIGNlbGxzKSk7XG4gIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGFkZFJvd0JlZm9yZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgZGlzcGF0Y2goYWRkUm93KHN0YXRlLnRyLCByZWN0LCByZWN0LnRvcCkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYWRkUm93QWZ0ZXIoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGRpc3BhdGNoKGFkZFJvdyhzdGF0ZS50ciwgcmVjdCwgcmVjdC5ib3R0b20pKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJvdyh0ciwgeyBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0IH0sIHJvdykge1xuICBsZXQgcm93UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3c7IGkrKylcbiAgICByb3dQb3MgKz0gdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG4gIGNvbnN0IG5leHRSb3cgPSByb3dQb3MgKyB0YWJsZS5jaGlsZChyb3cpLm5vZGVTaXplO1xuICBjb25zdCBtYXBGcm9tID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgdHIuZGVsZXRlKHJvd1BvcyArIHRhYmxlU3RhcnQsIG5leHRSb3cgKyB0YWJsZVN0YXJ0KTtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAobGV0IGNvbCA9IDAsIGluZGV4ID0gcm93ICogbWFwLndpZHRoOyBjb2wgPCBtYXAud2lkdGg7IGNvbCsrLCBpbmRleCsrKSB7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgaWYgKHNlZW4uaGFzKHBvcykpXG4gICAgICBjb250aW51ZTtcbiAgICBzZWVuLmFkZChwb3MpO1xuICAgIGlmIChyb3cgPiAwICYmIHBvcyA9PSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkge1xuICAgICAgY29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgdGFibGVTdGFydCksIG51bGwsIHtcbiAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgIHJvd3NwYW46IGF0dHJzLnJvd3NwYW4gLSAxXG4gICAgICB9KTtcbiAgICAgIGNvbCArPSBhdHRycy5jb2xzcGFuIC0gMTtcbiAgICB9IGVsc2UgaWYgKHJvdyA8IG1hcC5oZWlnaHQgJiYgcG9zID09IG1hcC5tYXBbaW5kZXggKyBtYXAud2lkdGhdKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBjb25zdCBhdHRycyA9IGNlbGwuYXR0cnM7XG4gICAgICBjb25zdCBjb3B5ID0gY2VsbC50eXBlLmNyZWF0ZShcbiAgICAgICAgeyAuLi5hdHRycywgcm93c3BhbjogY2VsbC5hdHRycy5yb3dzcGFuIC0gMSB9LFxuICAgICAgICBjZWxsLmNvbnRlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdQb3MgPSBtYXAucG9zaXRpb25BdChyb3cgKyAxLCBjb2wsIHRhYmxlKTtcbiAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcCh0YWJsZVN0YXJ0ICsgbmV3UG9zKSwgY29weSk7XG4gICAgICBjb2wgKz0gYXR0cnMuY29sc3BhbiAtIDE7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWxldGVSb3coc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuICAgIGlmIChyZWN0LnRvcCA9PSAwICYmIHJlY3QuYm90dG9tID09IHJlY3QubWFwLmhlaWdodClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gcmVjdC5ib3R0b20gLSAxOyA7IGktLSkge1xuICAgICAgcmVtb3ZlUm93KHRyLCByZWN0LCBpKTtcbiAgICAgIGlmIChpID09IHJlY3QudG9wKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IHRhYmxlID0gcmVjdC50YWJsZVN0YXJ0ID8gdHIuZG9jLm5vZGVBdChyZWN0LnRhYmxlU3RhcnQgLSAxKSA6IHRyLmRvYztcbiAgICAgIGlmICghdGFibGUpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIk5vIHRhYmxlIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgcmVjdC50YWJsZSA9IHRhYmxlO1xuICAgICAgcmVjdC5tYXAgPSBUYWJsZU1hcC5nZXQocmVjdC50YWJsZSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkoY2VsbCkge1xuICBjb25zdCBjID0gY2VsbC5jb250ZW50O1xuICByZXR1cm4gYy5jaGlsZENvdW50ID09IDEgJiYgYy5jaGlsZCgwKS5pc1RleHRibG9jayAmJiBjLmNoaWxkKDApLmNoaWxkQ291bnQgPT0gMDtcbn1cbmZ1bmN0aW9uIGNlbGxzT3ZlcmxhcFJlY3RhbmdsZSh7IHdpZHRoLCBoZWlnaHQsIG1hcCB9LCByZWN0KSB7XG4gIGxldCBpbmRleFRvcCA9IHJlY3QudG9wICogd2lkdGggKyByZWN0LmxlZnQsIGluZGV4TGVmdCA9IGluZGV4VG9wO1xuICBsZXQgaW5kZXhCb3R0b20gPSAocmVjdC5ib3R0b20gLSAxKSAqIHdpZHRoICsgcmVjdC5sZWZ0LCBpbmRleFJpZ2h0ID0gaW5kZXhUb3AgKyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCAtIDEpO1xuICBmb3IgKGxldCBpID0gcmVjdC50b3A7IGkgPCByZWN0LmJvdHRvbTsgaSsrKSB7XG4gICAgaWYgKHJlY3QubGVmdCA+IDAgJiYgbWFwW2luZGV4TGVmdF0gPT0gbWFwW2luZGV4TGVmdCAtIDFdIHx8IHJlY3QucmlnaHQgPCB3aWR0aCAmJiBtYXBbaW5kZXhSaWdodF0gPT0gbWFwW2luZGV4UmlnaHQgKyAxXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGluZGV4TGVmdCArPSB3aWR0aDtcbiAgICBpbmRleFJpZ2h0ICs9IHdpZHRoO1xuICB9XG4gIGZvciAobGV0IGkgPSByZWN0LmxlZnQ7IGkgPCByZWN0LnJpZ2h0OyBpKyspIHtcbiAgICBpZiAocmVjdC50b3AgPiAwICYmIG1hcFtpbmRleFRvcF0gPT0gbWFwW2luZGV4VG9wIC0gd2lkdGhdIHx8IHJlY3QuYm90dG9tIDwgaGVpZ2h0ICYmIG1hcFtpbmRleEJvdHRvbV0gPT0gbWFwW2luZGV4Qm90dG9tICsgd2lkdGhdKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaW5kZXhUb3ArKztcbiAgICBpbmRleEJvdHRvbSsrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2VsbHMoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikgfHwgc2VsLiRhbmNob3JDZWxsLnBvcyA9PSBzZWwuJGhlYWRDZWxsLnBvcylcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB7IG1hcCB9ID0gcmVjdDtcbiAgaWYgKGNlbGxzT3ZlcmxhcFJlY3RhbmdsZShtYXAsIHJlY3QpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICBjb25zdCBzZWVuID0ge307XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudDQuZW1wdHk7XG4gICAgbGV0IG1lcmdlZFBvcztcbiAgICBsZXQgbWVyZ2VkQ2VsbDtcbiAgICBmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQ7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxQb3MgPSBtYXAubWFwW3JvdyAqIG1hcC53aWR0aCArIGNvbF07XG4gICAgICAgIGNvbnN0IGNlbGwgPSByZWN0LnRhYmxlLm5vZGVBdChjZWxsUG9zKTtcbiAgICAgICAgaWYgKHNlZW5bY2VsbFBvc10gfHwgIWNlbGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHNlZW5bY2VsbFBvc10gPSB0cnVlO1xuICAgICAgICBpZiAobWVyZ2VkUG9zID09IG51bGwpIHtcbiAgICAgICAgICBtZXJnZWRQb3MgPSBjZWxsUG9zO1xuICAgICAgICAgIG1lcmdlZENlbGwgPSBjZWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaXNFbXB0eShjZWxsKSlcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZChjZWxsLmNvbnRlbnQpO1xuICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHRyLm1hcHBpbmcubWFwKGNlbGxQb3MgKyByZWN0LnRhYmxlU3RhcnQpO1xuICAgICAgICAgIHRyLmRlbGV0ZShtYXBwZWQsIG1hcHBlZCArIGNlbGwubm9kZVNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtZXJnZWRQb3MgPT0gbnVsbCB8fCBtZXJnZWRDZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0ci5zZXROb2RlTWFya3VwKG1lcmdlZFBvcyArIHJlY3QudGFibGVTdGFydCwgbnVsbCwge1xuICAgICAgLi4uYWRkQ29sU3BhbihcbiAgICAgICAgbWVyZ2VkQ2VsbC5hdHRycyxcbiAgICAgICAgbWVyZ2VkQ2VsbC5hdHRycy5jb2xzcGFuLFxuICAgICAgICByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0IC0gbWVyZ2VkQ2VsbC5hdHRycy5jb2xzcGFuXG4gICAgICApLFxuICAgICAgcm93c3BhbjogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICAgIH0pO1xuICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgIGNvbnN0IGVuZCA9IG1lcmdlZFBvcyArIDEgKyBtZXJnZWRDZWxsLmNvbnRlbnQuc2l6ZTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaXNFbXB0eShtZXJnZWRDZWxsKSA/IG1lcmdlZFBvcyArIDEgOiBlbmQ7XG4gICAgICB0ci5yZXBsYWNlV2l0aChzdGFydCArIHJlY3QudGFibGVTdGFydCwgZW5kICsgcmVjdC50YWJsZVN0YXJ0LCBjb250ZW50KTtcbiAgICB9XG4gICAgdHIuc2V0U2VsZWN0aW9uKFxuICAgICAgbmV3IENlbGxTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobWVyZ2VkUG9zICsgcmVjdC50YWJsZVN0YXJ0KSlcbiAgICApO1xuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q2VsbChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgY29uc3Qgbm9kZVR5cGVzID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKTtcbiAgcmV0dXJuIHNwbGl0Q2VsbFdpdGhUeXBlKCh7IG5vZGUgfSkgPT4ge1xuICAgIHJldHVybiBub2RlVHlwZXNbbm9kZS50eXBlLnNwZWMudGFibGVSb2xlXTtcbiAgfSkoc3RhdGUsIGRpc3BhdGNoKTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q2VsbFdpdGhUeXBlKGdldENlbGxUeXBlKSB7XG4gIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgY2VsbE5vZGU7XG4gICAgbGV0IGNlbGxQb3M7XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpIHtcbiAgICAgIGNlbGxOb2RlID0gY2VsbFdyYXBwaW5nKHNlbC4kZnJvbSk7XG4gICAgICBpZiAoIWNlbGxOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjZWxsUG9zID0gKF9hID0gY2VsbEFyb3VuZChzZWwuJGZyb20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsLiRhbmNob3JDZWxsLnBvcyAhPSBzZWwuJGhlYWRDZWxsLnBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2VsbE5vZGUgPSBzZWwuJGFuY2hvckNlbGwubm9kZUFmdGVyO1xuICAgICAgY2VsbFBvcyA9IHNlbC4kYW5jaG9yQ2VsbC5wb3M7XG4gICAgfVxuICAgIGlmIChjZWxsTm9kZSA9PSBudWxsIHx8IGNlbGxQb3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2VsbE5vZGUuYXR0cnMuY29sc3BhbiA9PSAxICYmIGNlbGxOb2RlLmF0dHJzLnJvd3NwYW4gPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCBiYXNlQXR0cnMgPSBjZWxsTm9kZS5hdHRycztcbiAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICBjb25zdCBjb2x3aWR0aCA9IGJhc2VBdHRycy5jb2x3aWR0aDtcbiAgICAgIGlmIChiYXNlQXR0cnMucm93c3BhbiA+IDEpXG4gICAgICAgIGJhc2VBdHRycyA9IHsgLi4uYmFzZUF0dHJzLCByb3dzcGFuOiAxIH07XG4gICAgICBpZiAoYmFzZUF0dHJzLmNvbHNwYW4gPiAxKVxuICAgICAgICBiYXNlQXR0cnMgPSB7IC4uLmJhc2VBdHRycywgY29sc3BhbjogMSB9O1xuICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSksIHRyID0gc3RhdGUudHI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7IGkrKylcbiAgICAgICAgYXR0cnMucHVzaChcbiAgICAgICAgICBjb2x3aWR0aCA/IHtcbiAgICAgICAgICAgIC4uLmJhc2VBdHRycyxcbiAgICAgICAgICAgIGNvbHdpZHRoOiBjb2x3aWR0aCAmJiBjb2x3aWR0aFtpXSA/IFtjb2x3aWR0aFtpXV0gOiBudWxsXG4gICAgICAgICAgfSA6IGJhc2VBdHRyc1xuICAgICAgICApO1xuICAgICAgbGV0IGxhc3RDZWxsO1xuICAgICAgZm9yIChsZXQgcm93ID0gcmVjdC50b3A7IHJvdyA8IHJlY3QuYm90dG9tOyByb3crKykge1xuICAgICAgICBsZXQgcG9zID0gcmVjdC5tYXAucG9zaXRpb25BdChyb3csIHJlY3QubGVmdCwgcmVjdC50YWJsZSk7XG4gICAgICAgIGlmIChyb3cgPT0gcmVjdC50b3ApXG4gICAgICAgICAgcG9zICs9IGNlbGxOb2RlLm5vZGVTaXplO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQsIGkgPSAwOyBjb2wgPCByZWN0LnJpZ2h0OyBjb2wrKywgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvbCA9PSByZWN0LmxlZnQgJiYgcm93ID09IHJlY3QudG9wKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgdHIuaW5zZXJ0KFxuICAgICAgICAgICAgbGFzdENlbGwgPSB0ci5tYXBwaW5nLm1hcChwb3MgKyByZWN0LnRhYmxlU3RhcnQsIDEpLFxuICAgICAgICAgICAgZ2V0Q2VsbFR5cGUoeyBub2RlOiBjZWxsTm9kZSwgcm93LCBjb2wgfSkuY3JlYXRlQW5kRmlsbChhdHRyc1tpXSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICBjZWxsUG9zLFxuICAgICAgICBnZXRDZWxsVHlwZSh7IG5vZGU6IGNlbGxOb2RlLCByb3c6IHJlY3QudG9wLCBjb2w6IHJlY3QubGVmdCB9KSxcbiAgICAgICAgYXR0cnNbMF1cbiAgICAgICk7XG4gICAgICBpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbilcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgIG5ldyBDZWxsU2VsZWN0aW9uKFxuICAgICAgICAgICAgdHIuZG9jLnJlc29sdmUoc2VsLiRhbmNob3JDZWxsLnBvcyksXG4gICAgICAgICAgICBsYXN0Q2VsbCA/IHRyLmRvYy5yZXNvbHZlKGxhc3RDZWxsKSA6IHZvaWQgMFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRDZWxsQXR0cihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc0luVGFibGUoc3RhdGUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0ICRjZWxsID0gc2VsZWN0aW9uQ2VsbChzdGF0ZSk7XG4gICAgaWYgKCRjZWxsLm5vZGVBZnRlci5hdHRyc1tuYW1lXSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pXG4gICAgICAgIHN0YXRlLnNlbGVjdGlvbi5mb3JFYWNoQ2VsbCgobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuYXR0cnNbbmFtZV0gIT09IHZhbHVlKVxuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIG51bGwsIHtcbiAgICAgICAgICAgICAgLi4ubm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgW25hbWVdOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICB0ci5zZXROb2RlTWFya3VwKCRjZWxsLnBvcywgbnVsbCwge1xuICAgICAgICAgIC4uLiRjZWxsLm5vZGVBZnRlci5hdHRycyxcbiAgICAgICAgICBbbmFtZV06IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRfdG9nZ2xlSGVhZGVyKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIGlmICghaXNJblRhYmxlKHN0YXRlKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGNvbnN0IHR5cGVzID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgY29uc3QgY2VsbHMgPSByZWN0Lm1hcC5jZWxsc0luUmVjdChcbiAgICAgICAgdHlwZSA9PSBcImNvbHVtblwiID8ge1xuICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICAgICAgYm90dG9tOiByZWN0Lm1hcC5oZWlnaHRcbiAgICAgICAgfSA6IHR5cGUgPT0gXCJyb3dcIiA/IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgICAgcmlnaHQ6IHJlY3QubWFwLndpZHRoLFxuICAgICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b21cbiAgICAgICAgfSA6IHJlY3RcbiAgICAgICk7XG4gICAgICBjb25zdCBub2RlcyA9IGNlbGxzLm1hcCgocG9zKSA9PiByZWN0LnRhYmxlLm5vZGVBdChwb3MpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChub2Rlc1tpXS50eXBlID09IHR5cGVzLmhlYWRlcl9jZWxsKVxuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgICAgICByZWN0LnRhYmxlU3RhcnQgKyBjZWxsc1tpXSxcbiAgICAgICAgICAgIHR5cGVzLmNlbGwsXG4gICAgICAgICAgICBub2Rlc1tpXS5hdHRyc1xuICAgICAgICAgICk7XG4gICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgICAgIHJlY3QudGFibGVTdGFydCArIGNlbGxzW2ldLFxuICAgICAgICAgICAgdHlwZXMuaGVhZGVyX2NlbGwsXG4gICAgICAgICAgICBub2Rlc1tpXS5hdHRyc1xuICAgICAgICAgICk7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gaXNIZWFkZXJFbmFibGVkQnlUeXBlKHR5cGUsIHJlY3QsIHR5cGVzKSB7XG4gIGNvbnN0IGNlbGxQb3NpdGlvbnMgPSByZWN0Lm1hcC5jZWxsc0luUmVjdCh7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IHR5cGUgPT0gXCJyb3dcIiA/IHJlY3QubWFwLndpZHRoIDogMSxcbiAgICBib3R0b206IHR5cGUgPT0gXCJjb2x1bW5cIiA/IHJlY3QubWFwLmhlaWdodCA6IDFcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbFBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNlbGwgPSByZWN0LnRhYmxlLm5vZGVBdChjZWxsUG9zaXRpb25zW2ldKTtcbiAgICBpZiAoY2VsbCAmJiBjZWxsLnR5cGUgIT09IHR5cGVzLmhlYWRlcl9jZWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9nZ2xlSGVhZGVyKHR5cGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB1c2VEZXByZWNhdGVkTG9naWM6IGZhbHNlIH07XG4gIGlmIChvcHRpb25zLnVzZURlcHJlY2F0ZWRMb2dpYylcbiAgICByZXR1cm4gZGVwcmVjYXRlZF90b2dnbGVIZWFkZXIodHlwZSk7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSk7XG4gICAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgIGNvbnN0IGlzSGVhZGVyUm93RW5hYmxlZCA9IGlzSGVhZGVyRW5hYmxlZEJ5VHlwZShcInJvd1wiLCByZWN0LCB0eXBlcyk7XG4gICAgICBjb25zdCBpc0hlYWRlckNvbHVtbkVuYWJsZWQgPSBpc0hlYWRlckVuYWJsZWRCeVR5cGUoXG4gICAgICAgIFwiY29sdW1uXCIsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIHR5cGVzXG4gICAgICApO1xuICAgICAgY29uc3QgaXNIZWFkZXJFbmFibGVkID0gdHlwZSA9PT0gXCJjb2x1bW5cIiA/IGlzSGVhZGVyUm93RW5hYmxlZCA6IHR5cGUgPT09IFwicm93XCIgPyBpc0hlYWRlckNvbHVtbkVuYWJsZWQgOiBmYWxzZTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0c0F0ID0gaXNIZWFkZXJFbmFibGVkID8gMSA6IDA7XG4gICAgICBjb25zdCBjZWxsc1JlY3QgPSB0eXBlID09IFwiY29sdW1uXCIgPyB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogc2VsZWN0aW9uU3RhcnRzQXQsXG4gICAgICAgIHJpZ2h0OiAxLFxuICAgICAgICBib3R0b206IHJlY3QubWFwLmhlaWdodFxuICAgICAgfSA6IHR5cGUgPT0gXCJyb3dcIiA/IHtcbiAgICAgICAgbGVmdDogc2VsZWN0aW9uU3RhcnRzQXQsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IHJlY3QubWFwLndpZHRoLFxuICAgICAgICBib3R0b206IDFcbiAgICAgIH0gOiByZWN0O1xuICAgICAgY29uc3QgbmV3VHlwZSA9IHR5cGUgPT0gXCJjb2x1bW5cIiA/IGlzSGVhZGVyQ29sdW1uRW5hYmxlZCA/IHR5cGVzLmNlbGwgOiB0eXBlcy5oZWFkZXJfY2VsbCA6IHR5cGUgPT0gXCJyb3dcIiA/IGlzSGVhZGVyUm93RW5hYmxlZCA/IHR5cGVzLmNlbGwgOiB0eXBlcy5oZWFkZXJfY2VsbCA6IHR5cGVzLmNlbGw7XG4gICAgICByZWN0Lm1hcC5jZWxsc0luUmVjdChjZWxsc1JlY3QpLmZvckVhY2goKHJlbGF0aXZlQ2VsbFBvcykgPT4ge1xuICAgICAgICBjb25zdCBjZWxsUG9zID0gcmVsYXRpdmVDZWxsUG9zICsgcmVjdC50YWJsZVN0YXJ0O1xuICAgICAgICBjb25zdCBjZWxsID0gdHIuZG9jLm5vZGVBdChjZWxsUG9zKTtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKGNlbGxQb3MsIG5ld1R5cGUsIGNlbGwuYXR0cnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG52YXIgdG9nZ2xlSGVhZGVyUm93ID0gdG9nZ2xlSGVhZGVyKFwicm93XCIsIHtcbiAgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlXG59KTtcbnZhciB0b2dnbGVIZWFkZXJDb2x1bW4gPSB0b2dnbGVIZWFkZXIoXCJjb2x1bW5cIiwge1xuICB1c2VEZXByZWNhdGVkTG9naWM6IHRydWVcbn0pO1xudmFyIHRvZ2dsZUhlYWRlckNlbGwgPSB0b2dnbGVIZWFkZXIoXCJjZWxsXCIsIHtcbiAgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlXG59KTtcbmZ1bmN0aW9uIGZpbmROZXh0Q2VsbCgkY2VsbCwgZGlyKSB7XG4gIGlmIChkaXIgPCAwKSB7XG4gICAgY29uc3QgYmVmb3JlID0gJGNlbGwubm9kZUJlZm9yZTtcbiAgICBpZiAoYmVmb3JlKVxuICAgICAgcmV0dXJuICRjZWxsLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZTtcbiAgICBmb3IgKGxldCByb3cgPSAkY2VsbC5pbmRleCgtMSkgLSAxLCByb3dFbmQgPSAkY2VsbC5iZWZvcmUoKTsgcm93ID49IDA7IHJvdy0tKSB7XG4gICAgICBjb25zdCByb3dOb2RlID0gJGNlbGwubm9kZSgtMSkuY2hpbGQocm93KTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHJvd05vZGUubGFzdENoaWxkO1xuICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICByZXR1cm4gcm93RW5kIC0gMSAtIGxhc3RDaGlsZC5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICAgIHJvd0VuZCAtPSByb3dOb2RlLm5vZGVTaXplO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGNlbGwuaW5kZXgoKSA8ICRjZWxsLnBhcmVudC5jaGlsZENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuICRjZWxsLnBvcyArICRjZWxsLm5vZGVBZnRlci5ub2RlU2l6ZTtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKTtcbiAgICBmb3IgKGxldCByb3cgPSAkY2VsbC5pbmRleEFmdGVyKC0xKSwgcm93U3RhcnQgPSAkY2VsbC5hZnRlcigpOyByb3cgPCB0YWJsZS5jaGlsZENvdW50OyByb3crKykge1xuICAgICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgICBpZiAocm93Tm9kZS5jaGlsZENvdW50KVxuICAgICAgICByZXR1cm4gcm93U3RhcnQgKyAxO1xuICAgICAgcm93U3RhcnQgKz0gcm93Tm9kZS5ub2RlU2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnb1RvTmV4dENlbGwoZGlyZWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2VsbCA9IGZpbmROZXh0Q2VsbChzZWxlY3Rpb25DZWxsKHN0YXRlKSwgZGlyZWN0aW9uKTtcbiAgICBpZiAoY2VsbCA9PSBudWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgJGNlbGwgPSBzdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgICAgIGRpc3BhdGNoKFxuICAgICAgICBzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbjMuYmV0d2VlbigkY2VsbCwgbW92ZUNlbGxGb3J3YXJkKCRjZWxsKSkpLnNjcm9sbEludG9WaWV3KClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlVGFibGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPiAwOyBkLS0pIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGQpO1xuICAgIGlmIChub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJ0YWJsZVwiKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgIHN0YXRlLnRyLmRlbGV0ZSgkcG9zLmJlZm9yZShkKSwgJHBvcy5hZnRlcihkKSkuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiB0YWJsZUVkaXRpbmcoe1xuICBhbGxvd1RhYmxlTm9kZVNlbGVjdGlvbiA9IGZhbHNlXG59ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4yKHtcbiAgICBrZXk6IHRhYmxlRWRpdGluZ0tleSxcbiAgICAvLyBUaGlzIHBpZWNlIG9mIHN0YXRlIGlzIHVzZWQgdG8gcmVtZW1iZXIgd2hlbiBhIG1vdXNlLWRyYWdcbiAgICAvLyBjZWxsLXNlbGVjdGlvbiBpcyBoYXBwZW5pbmcsIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIGV2ZW4gYXNcbiAgICAvLyB0cmFuc2FjdGlvbnMgKHdoaWNoIG1pZ2h0IG1vdmUgaXRzIGFuY2hvciBjZWxsKSBjb21lIGluLlxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgY3VyKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRyLmdldE1ldGEodGFibGVFZGl0aW5nS2V5KTtcbiAgICAgICAgaWYgKHNldCAhPSBudWxsKVxuICAgICAgICAgIHJldHVybiBzZXQgPT0gLTEgPyBudWxsIDogc2V0O1xuICAgICAgICBpZiAoY3VyID09IG51bGwgfHwgIXRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgY29uc3QgeyBkZWxldGVkLCBwb3MgfSA9IHRyLm1hcHBpbmcubWFwUmVzdWx0KGN1cik7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IHBvcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogZHJhd0NlbGxTZWxlY3Rpb24sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgbW91c2Vkb3duOiBoYW5kbGVNb3VzZURvd25cbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlRWRpdGluZ0tleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKSAhPSBudWxsID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24gOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRyaXBsZUNsaWNrLFxuICAgICAgaGFuZGxlS2V5RG93bixcbiAgICAgIGhhbmRsZVBhc3RlXG4gICAgfSxcbiAgICBhcHBlbmRUcmFuc2FjdGlvbihfLCBvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBmaXhUYWJsZXMoc3RhdGUsIG9sZFN0YXRlKSxcbiAgICAgICAgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCB7XG4gIENlbGxCb29rbWFyayxcbiAgQ2VsbFNlbGVjdGlvbixcbiAgUmVzaXplU3RhdGUsXG4gIFRhYmxlTWFwLFxuICBUYWJsZVZpZXcsXG4gIGNsaXBDZWxscyBhcyBfX2NsaXBDZWxscyxcbiAgaW5zZXJ0Q2VsbHMgYXMgX19pbnNlcnRDZWxscyxcbiAgcGFzdGVkQ2VsbHMgYXMgX19wYXN0ZWRDZWxscyxcbiAgYWRkQ29sU3BhbixcbiAgYWRkQ29sdW1uLFxuICBhZGRDb2x1bW5BZnRlcixcbiAgYWRkQ29sdW1uQmVmb3JlLFxuICBhZGRSb3csXG4gIGFkZFJvd0FmdGVyLFxuICBhZGRSb3dCZWZvcmUsXG4gIGNlbGxBcm91bmQsXG4gIGNvbENvdW50LFxuICBjb2x1bW5Jc0hlYWRlcixcbiAgY29sdW1uUmVzaXppbmcsXG4gIGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LFxuICBkZWxldGVDb2x1bW4sXG4gIGRlbGV0ZVJvdyxcbiAgZGVsZXRlVGFibGUsXG4gIGZpbmRDZWxsLFxuICBmaXhUYWJsZXMsXG4gIGZpeFRhYmxlc0tleSxcbiAgZ29Ub05leHRDZWxsLFxuICBoYW5kbGVQYXN0ZSxcbiAgaW5TYW1lVGFibGUsXG4gIGlzSW5UYWJsZSxcbiAgbWVyZ2VDZWxscyxcbiAgbW92ZUNlbGxGb3J3YXJkLFxuICBuZXh0Q2VsbCxcbiAgcG9pbnRzQXRDZWxsLFxuICByZW1vdmVDb2xTcGFuLFxuICByZW1vdmVDb2x1bW4sXG4gIHJlbW92ZVJvdyxcbiAgcm93SXNIZWFkZXIsXG4gIHNlbGVjdGVkUmVjdCxcbiAgc2VsZWN0aW9uQ2VsbCxcbiAgc2V0Q2VsbEF0dHIsXG4gIHNwbGl0Q2VsbCxcbiAgc3BsaXRDZWxsV2l0aFR5cGUsXG4gIHRhYmxlRWRpdGluZyxcbiAgdGFibGVFZGl0aW5nS2V5LFxuICB0YWJsZU5vZGVUeXBlcyxcbiAgdGFibGVOb2RlcyxcbiAgdG9nZ2xlSGVhZGVyLFxuICB0b2dnbGVIZWFkZXJDZWxsLFxuICB0b2dnbGVIZWFkZXJDb2x1bW4sXG4gIHRvZ2dsZUhlYWRlclJvdyxcbiAgdXBkYXRlQ29sdW1uc09uUmVzaXplXG59O1xuIl0sIm5hbWVzIjpbIlBsdWdpbiIsIlBsdWdpbjIiLCJGcmFnbWVudCIsIlNsaWNlIiwiTm9kZVNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24yIiwiU2VsZWN0aW9uIiwiU2VsZWN0aW9uUmFuZ2UiLCJUZXh0U2VsZWN0aW9uIiwiRGVjb3JhdGlvbiIsIkRlY29yYXRpb25TZXQiLCJyZWFkRnJvbUNhY2hlIiwiYWRkVG9DYWNoZSIsIldlYWtNYXAiLCJjYWNoZSIsImtleSIsImdldCIsInZhbHVlIiwic2V0IiwiY2FjaGVTaXplIiwiY2FjaGVQb3MiLCJpIiwibGVuZ3RoIiwiVGFibGVNYXAiLCJjb25zdHJ1Y3RvciIsIndpZHRoIiwiaGVpZ2h0IiwibWFwIiwicHJvYmxlbXMiLCJmaW5kQ2VsbCIsInBvcyIsImN1clBvcyIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImoiLCJSYW5nZUVycm9yIiwiY29sQ291bnQiLCJuZXh0Q2VsbCIsImF4aXMiLCJkaXIiLCJyZWN0QmV0d2VlbiIsImEiLCJiIiwibGVmdEEiLCJyaWdodEEiLCJ0b3BBIiwiYm90dG9tQSIsImxlZnRCIiwicmlnaHRCIiwidG9wQiIsImJvdHRvbUIiLCJNYXRoIiwibWluIiwibWF4IiwiY2VsbHNJblJlY3QiLCJyZWN0IiwicmVzdWx0Iiwic2VlbiIsInJvdyIsImNvbCIsImluZGV4IiwicHVzaCIsInBvc2l0aW9uQXQiLCJ0YWJsZSIsInJvd1N0YXJ0Iiwicm93RW5kIiwiY2hpbGQiLCJub2RlU2l6ZSIsInJvd0VuZEluZGV4IiwiY29tcHV0ZU1hcCIsInR5cGUiLCJzcGVjIiwidGFibGVSb2xlIiwibmFtZSIsImZpbmRXaWR0aCIsImNoaWxkQ291bnQiLCJtYXBQb3MiLCJjb2xXaWR0aHMiLCJlIiwicm93Tm9kZSIsImNlbGxOb2RlIiwiY29sc3BhbiIsInJvd3NwYW4iLCJjb2x3aWR0aCIsImF0dHJzIiwiaCIsIm4iLCJzdGFydCIsInciLCJjb2xXIiwid2lkdGhJbmRleCIsInByZXYiLCJleHBlY3RlZFBvcyIsIm1pc3NpbmciLCJ0YWJsZU1hcCIsImJhZFdpZHRocyIsImZpbmRCYWRDb2xXaWR0aHMiLCJoYXNSb3dTcGFuIiwicm93V2lkdGgiLCJwcmV2Um93IiwiY2VsbCIsIm5vZGUiLCJub2RlQXQiLCJ1cGRhdGVkIiwiY29sV2lkdGgiLCJmcmVzaENvbFdpZHRoIiwidW5zaGlmdCIsInNsaWNlIiwiUGx1Z2luS2V5IiwiZ2V0Q2VsbEF0dHJzIiwiZG9tIiwiZXh0cmFBdHRycyIsIndpZHRoQXR0ciIsImdldEF0dHJpYnV0ZSIsIndpZHRocyIsInRlc3QiLCJzcGxpdCIsInMiLCJOdW1iZXIiLCJwcm9wIiwiZ2V0dGVyIiwiZ2V0RnJvbURPTSIsInNldENlbGxBdHRycyIsImpvaW4iLCJzZXR0ZXIiLCJzZXRET01BdHRyIiwidGFibGVOb2RlcyIsIm9wdGlvbnMiLCJjZWxsQXR0cmlidXRlcyIsImNlbGxBdHRycyIsImRlZmF1bHQiLCJjb250ZW50IiwiaXNvbGF0aW5nIiwiZ3JvdXAiLCJ0YWJsZUdyb3VwIiwicGFyc2VET00iLCJ0YWciLCJ0b0RPTSIsInRhYmxlX3JvdyIsInRhYmxlX2NlbGwiLCJjZWxsQ29udGVudCIsImdldEF0dHJzIiwidGFibGVfaGVhZGVyIiwidGFibGVOb2RlVHlwZXMiLCJzY2hlbWEiLCJjYWNoZWQiLCJub2RlcyIsInJvbGUiLCJ0YWJsZUVkaXRpbmdLZXkiLCJjZWxsQXJvdW5kIiwiJHBvcyIsImQiLCJkZXB0aCIsInJlc29sdmUiLCJiZWZvcmUiLCJjZWxsV3JhcHBpbmciLCJpc0luVGFibGUiLCJzdGF0ZSIsIiRoZWFkIiwic2VsZWN0aW9uIiwic2VsZWN0aW9uQ2VsbCIsInNlbCIsIiRhbmNob3JDZWxsIiwiJGhlYWRDZWxsIiwiJGFuY2hvciIsIiRjZWxsIiwiY2VsbE5lYXIiLCJoZWFkIiwiYWZ0ZXIiLCJub2RlQWZ0ZXIiLCJmaXJzdENoaWxkIiwiZG9jIiwibm9kZUJlZm9yZSIsImxhc3RDaGlsZCIsInBvaW50c0F0Q2VsbCIsInBhcmVudCIsIm1vdmVDZWxsRm9yd2FyZCIsImluU2FtZVRhYmxlIiwiJGNlbGxBIiwiJGNlbGxCIiwiZW5kIiwidGFibGVTdGFydCIsIm1vdmVkIiwicmVtb3ZlQ29sU3BhbiIsInNwbGljZSIsInNvbWUiLCJhZGRDb2xTcGFuIiwiY29sdW1uSXNIZWFkZXIiLCJoZWFkZXJDZWxsIiwiaGVhZGVyX2NlbGwiLCJDZWxsU2VsZWN0aW9uIiwiX0NlbGxTZWxlY3Rpb24iLCJjZWxscyIsImZpbHRlciIsInAiLCJyYW5nZXMiLCJmcm9tIiwic2l6ZSIsIiRmcm9tIiwiJHRvIiwibWFwcGluZyIsInRhYmxlQ2hhbmdlZCIsImlzUm93U2VsZWN0aW9uIiwicm93U2VsZWN0aW9uIiwiaXNDb2xTZWxlY3Rpb24iLCJjb2xTZWxlY3Rpb24iLCJiZXR3ZWVuIiwicm93cyIsInJvd0NvbnRlbnQiLCJjZWxsUmVjdCIsImV4dHJhTGVmdCIsImV4dHJhUmlnaHQiLCJjcmVhdGVBbmRGaWxsIiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZSIsImNvcHkiLCJmcmFnbWVudCIsInJlcGxhY2UiLCJ0ciIsImVtcHR5IiwibWFwRnJvbSIsInN0ZXBzIiwiZmluZEZyb20iLCJ0byIsInNldFNlbGVjdGlvbiIsInJlcGxhY2VXaXRoIiwiZm9yRWFjaENlbGwiLCJmIiwiYW5jaG9yVG9wIiwiaGVhZFRvcCIsImFuY2hvckJvdHRvbSIsImhlYWRCb3R0b20iLCJhbmNob3JSZWN0IiwiaGVhZFJlY3QiLCJhbmNob3JMZWZ0IiwiaGVhZExlZnQiLCJhbmNob3JSaWdodCIsImhlYWRSaWdodCIsImVxIiwib3RoZXIiLCJ0b0pTT04iLCJhbmNob3IiLCJmcm9tSlNPTiIsImpzb24iLCJhbmNob3JDZWxsIiwiaGVhZENlbGwiLCJnZXRCb29rbWFyayIsIkNlbGxCb29rbWFyayIsInByb3RvdHlwZSIsInZpc2libGUiLCJqc29uSUQiLCJfQ2VsbEJvb2ttYXJrIiwibmVhciIsImRyYXdDZWxsU2VsZWN0aW9uIiwiY2xhc3MiLCJpc0NlbGxCb3VuZGFyeVNlbGVjdGlvbiIsImFmdGVyRnJvbSIsImJlZm9yZVRvIiwiaXNUZXh0U2VsZWN0aW9uQWNyb3NzQ2VsbHMiLCJmcm9tQ2VsbEJvdW5kYXJ5Tm9kZSIsInRvQ2VsbEJvdW5kYXJ5Tm9kZSIsInBhcmVudE9mZnNldCIsIm5vcm1hbGl6ZVNlbGVjdGlvbiIsImFsbG93VGFibGVOb2RlU2VsZWN0aW9uIiwibm9ybWFsaXplIiwibGFzdENlbGwiLCJQbHVnaW5LZXkyIiwiZml4VGFibGVzS2V5IiwiY2hhbmdlZERlc2NlbmRhbnRzIiwib2xkIiwiY3VyIiwib2Zmc2V0Iiwib2xkU2l6ZSIsImN1clNpemUiLCJvdXRlciIsInNjYW4iLCJzYW1lTWFya3VwIiwibm9kZXNCZXR3ZWVuIiwiZml4VGFibGVzIiwib2xkU3RhdGUiLCJjaGVjayIsImZpeFRhYmxlIiwiZGVzY2VuZGFudHMiLCJ0YWJsZVBvcyIsIm11c3RBZGQiLCJwcm9iIiwic2V0Tm9kZU1hcmt1cCIsImZpcnN0IiwibGFzdCIsImFkZCIsInNpZGUiLCJpbnNlcnQiLCJzZXRNZXRhIiwiRnJhZ21lbnQzIiwiU2xpY2UzIiwiU2VsZWN0aW9uMiIsIlRleHRTZWxlY3Rpb24yIiwia2V5ZG93bkhhbmRsZXIiLCJGcmFnbWVudDIiLCJTbGljZTIiLCJUcmFuc2Zvcm0iLCJwYXN0ZWRDZWxscyIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJmaXRTbGljZSIsImVuc3VyZVJlY3Rhbmd1bGFyIiwiciIsImFwcGVuZCIsIm5vZGVUeXBlIiwiY2xpcENlbGxzIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJhZGRlZCIsIm5ld1Jvd3MiLCJmcmFnIiwiY3JlYXRlQ2hlY2tlZCIsInNvdXJjZSIsImdyb3dUYWJsZSIsInR5cGVzIiwiZW1wdHlIZWFkIiwic3RhcnQyIiwiaGVhZGVyIiwiZW1wdHlSb3ciLCJpc29sYXRlSG9yaXpvbnRhbCIsImZvdW5kIiwiY2VsbFRvcCIsImNlbGxMZWZ0IiwiaXNvbGF0ZVZlcnRpY2FsIiwidXBkYXRlUG9zIiwiaW5zZXJ0Q2VsbHMiLCJkaXNwYXRjaCIsIkVycm9yIiwicmVjb21wIiwibWFwcyIsImhhbmRsZUtleURvd24iLCJBcnJvd0xlZnQiLCJhcnJvdyIsIkFycm93UmlnaHQiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwic2hpZnRBcnJvdyIsIkJhY2tzcGFjZSIsImRlbGV0ZUNlbGxTZWxlY3Rpb24iLCJEZWxldGUiLCJtYXliZVNldFNlbGVjdGlvbiIsInNjcm9sbEludG9WaWV3IiwidmlldyIsImF0RW5kT2ZDZWxsIiwiJG5leHQiLCJuZXdTZWwiLCJjZWxsU2VsIiwiYmFzZUNvbnRlbnQiLCJkb2NDaGFuZ2VkIiwiaGFuZGxlVHJpcGxlQ2xpY2siLCJoYW5kbGVQYXN0ZSIsIl8iLCJoYW5kbGVNb3VzZURvd24iLCJzdGFydEV2ZW50IiwiX2EiLCJjdHJsS2V5IiwibWV0YUtleSIsInN0YXJ0RE9NQ2VsbCIsImRvbUluQ2VsbCIsInRhcmdldCIsInNoaWZ0S2V5Iiwic2V0Q2VsbFNlbGVjdGlvbiIsInByZXZlbnREZWZhdWx0IiwiY2VsbFVuZGVyTW91c2UiLCIkYW5jaG9yMiIsImV2ZW50Iiwic3RhcnRpbmciLCJnZXRTdGF0ZSIsInN0b3AiLCJyb290IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdmUiLCJfZXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5kZXhBZnRlciIsImNlbGxQb3MiLCJkaXJTdHIiLCJlbmRPZlRleHRibG9jayIsInBhcmVudE5vZGUiLCJub2RlTmFtZSIsIm1vdXNlUG9zIiwicG9zQXRDb29yZHMiLCJjbGllbnRYIiwiY2xpZW50WSIsIlBsdWdpbktleTMiLCJEZWNvcmF0aW9uMiIsIkRlY29yYXRpb25TZXQyIiwiVGFibGVWaWV3IiwiY2VsbE1pbldpZHRoIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJjb2xncm91cCIsInVwZGF0ZUNvbHVtbnNPblJlc2l6ZSIsImNvbnRlbnRET00iLCJ1cGRhdGUiLCJpZ25vcmVNdXRhdGlvbiIsInJlY29yZCIsImNvbnRhaW5zIiwib3ZlcnJpZGVDb2wiLCJvdmVycmlkZVZhbHVlIiwidG90YWxXaWR0aCIsImZpeGVkV2lkdGgiLCJuZXh0RE9NIiwiaGFzV2lkdGgiLCJjc3NXaWR0aCIsInN0eWxlIiwibmV4dFNpYmxpbmciLCJyZW1vdmVDaGlsZCIsIm1pbldpZHRoIiwiY29sdW1uUmVzaXppbmdQbHVnaW5LZXkiLCJjb2x1bW5SZXNpemluZyIsImhhbmRsZVdpZHRoIiwiVmlldyIsImxhc3RDb2x1bW5SZXNpemFibGUiLCJwbHVnaW4iLCJpbml0IiwicHJvcHMiLCJub2RlVmlld3MiLCJSZXNpemVTdGF0ZSIsImFwcGx5IiwiYXR0cmlidXRlcyIsInBsdWdpblN0YXRlIiwiYWN0aXZlSGFuZGxlIiwiaGFuZGxlRE9NRXZlbnRzIiwibW91c2Vtb3ZlIiwiaGFuZGxlTW91c2VNb3ZlIiwibW91c2VsZWF2ZSIsImhhbmRsZU1vdXNlTGVhdmUiLCJtb3VzZWRvd24iLCJoYW5kbGVNb3VzZURvd24yIiwiZGVjb3JhdGlvbnMiLCJoYW5kbGVEZWNvcmF0aW9ucyIsIl9SZXNpemVTdGF0ZSIsImRyYWdnaW5nIiwiYWN0aW9uIiwiZ2V0TWV0YSIsInNldEhhbmRsZSIsInNldERyYWdnaW5nIiwiaGFuZGxlIiwiZG9tQ2VsbEFyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVkZ2VDZWxsIiwidXBkYXRlSGFuZGxlIiwiY3VycmVudENvbFdpZHRoIiwic3RhcnRYIiwic3RhcnRXaWR0aCIsImZpbmlzaCIsImV2ZW50MiIsIndpbmRvdyIsInBsdWdpblN0YXRlMiIsInVwZGF0ZUNvbHVtbldpZHRoIiwiZHJhZ2dlZFdpZHRoIiwid2hpY2giLCJkcmFnZ2VkIiwiZGlzcGxheUNvbHVtbldpZHRoIiwiZG9tQXRQb3MiLCJjaGlsZE5vZGVzIiwiZG9tV2lkdGgiLCJvZmZzZXRXaWR0aCIsInBhcnRzIiwiY2xhc3NMaXN0IiwiaW5kZXhPZiIsIm1hcEluZGV4IiwiemVyb2VzIiwiQXJyYXkiLCJmaWxsIiwid2lkZ2V0IiwiRnJhZ21lbnQ0IiwiVGV4dFNlbGVjdGlvbjMiLCJzZWxlY3RlZFJlY3QiLCJhZGRDb2x1bW4iLCJyZWZDb2x1bW4iLCJhZGRDb2x1bW5CZWZvcmUiLCJhZGRDb2x1bW5BZnRlciIsInJlbW92ZUNvbHVtbiIsIm1hcFN0YXJ0IiwiZGVsZXRlIiwiZGVsZXRlQ29sdW1uIiwicm93SXNIZWFkZXIiLCJhZGRSb3ciLCJyb3dQb3MiLCJyZWZSb3ciLCJhZGRSb3dCZWZvcmUiLCJhZGRSb3dBZnRlciIsInJlbW92ZVJvdyIsIm5leHRSb3ciLCJTZXQiLCJoYXMiLCJuZXdQb3MiLCJkZWxldGVSb3ciLCJpc0VtcHR5IiwiYyIsImlzVGV4dGJsb2NrIiwiY2VsbHNPdmVybGFwUmVjdGFuZ2xlIiwiaW5kZXhUb3AiLCJpbmRleExlZnQiLCJpbmRleEJvdHRvbSIsImluZGV4UmlnaHQiLCJtZXJnZUNlbGxzIiwibWVyZ2VkUG9zIiwibWVyZ2VkQ2VsbCIsIm1hcHBlZCIsInNwbGl0Q2VsbCIsIm5vZGVUeXBlcyIsInNwbGl0Q2VsbFdpdGhUeXBlIiwiZ2V0Q2VsbFR5cGUiLCJiYXNlQXR0cnMiLCJzZXRDZWxsQXR0ciIsImRlcHJlY2F0ZWRfdG9nZ2xlSGVhZGVyIiwiaXNIZWFkZXJFbmFibGVkQnlUeXBlIiwiY2VsbFBvc2l0aW9ucyIsInRvZ2dsZUhlYWRlciIsInVzZURlcHJlY2F0ZWRMb2dpYyIsImlzSGVhZGVyUm93RW5hYmxlZCIsImlzSGVhZGVyQ29sdW1uRW5hYmxlZCIsImlzSGVhZGVyRW5hYmxlZCIsInNlbGVjdGlvblN0YXJ0c0F0IiwiY2VsbHNSZWN0IiwibmV3VHlwZSIsImZvckVhY2giLCJyZWxhdGl2ZUNlbGxQb3MiLCJ0b2dnbGVIZWFkZXJSb3ciLCJ0b2dnbGVIZWFkZXJDb2x1bW4iLCJ0b2dnbGVIZWFkZXJDZWxsIiwiZmluZE5leHRDZWxsIiwiZ29Ub05leHRDZWxsIiwiZGlyZWN0aW9uIiwiZGVsZXRlVGFibGUiLCJ0YWJsZUVkaXRpbmciLCJkZWxldGVkIiwibWFwUmVzdWx0IiwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlbiIsImFwcGVuZFRyYW5zYWN0aW9uIiwiX19jbGlwQ2VsbHMiLCJfX2luc2VydENlbGxzIiwiX19wYXN0ZWRDZWxscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-tables/dist/index.js\n");

/***/ })

};
;