"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yjs";
exports.ids = ["vendor-chunks/yjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/yjs/dist/yjs.mjs":
/*!***************************************!*\
  !*** ./node_modules/yjs/dist/yjs.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsolutePosition: () => (/* binding */ AbsolutePosition),\n/* harmony export */   AbstractConnector: () => (/* binding */ AbstractConnector),\n/* harmony export */   AbstractStruct: () => (/* binding */ AbstractStruct),\n/* harmony export */   AbstractType: () => (/* binding */ AbstractType),\n/* harmony export */   Array: () => (/* binding */ YArray),\n/* harmony export */   ContentAny: () => (/* binding */ ContentAny),\n/* harmony export */   ContentBinary: () => (/* binding */ ContentBinary),\n/* harmony export */   ContentDeleted: () => (/* binding */ ContentDeleted),\n/* harmony export */   ContentDoc: () => (/* binding */ ContentDoc),\n/* harmony export */   ContentEmbed: () => (/* binding */ ContentEmbed),\n/* harmony export */   ContentFormat: () => (/* binding */ ContentFormat),\n/* harmony export */   ContentJSON: () => (/* binding */ ContentJSON),\n/* harmony export */   ContentString: () => (/* binding */ ContentString),\n/* harmony export */   ContentType: () => (/* binding */ ContentType),\n/* harmony export */   Doc: () => (/* binding */ Doc),\n/* harmony export */   GC: () => (/* binding */ GC),\n/* harmony export */   ID: () => (/* binding */ ID),\n/* harmony export */   Item: () => (/* binding */ Item),\n/* harmony export */   Map: () => (/* binding */ YMap),\n/* harmony export */   PermanentUserData: () => (/* binding */ PermanentUserData),\n/* harmony export */   RelativePosition: () => (/* binding */ RelativePosition),\n/* harmony export */   Skip: () => (/* binding */ Skip),\n/* harmony export */   Snapshot: () => (/* binding */ Snapshot),\n/* harmony export */   Text: () => (/* binding */ YText),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   UndoManager: () => (/* binding */ UndoManager),\n/* harmony export */   UpdateDecoderV1: () => (/* binding */ UpdateDecoderV1),\n/* harmony export */   UpdateDecoderV2: () => (/* binding */ UpdateDecoderV2),\n/* harmony export */   UpdateEncoderV1: () => (/* binding */ UpdateEncoderV1),\n/* harmony export */   UpdateEncoderV2: () => (/* binding */ UpdateEncoderV2),\n/* harmony export */   XmlElement: () => (/* binding */ YXmlElement),\n/* harmony export */   XmlFragment: () => (/* binding */ YXmlFragment),\n/* harmony export */   XmlHook: () => (/* binding */ YXmlHook),\n/* harmony export */   XmlText: () => (/* binding */ YXmlText),\n/* harmony export */   YArrayEvent: () => (/* binding */ YArrayEvent),\n/* harmony export */   YEvent: () => (/* binding */ YEvent),\n/* harmony export */   YMapEvent: () => (/* binding */ YMapEvent),\n/* harmony export */   YTextEvent: () => (/* binding */ YTextEvent),\n/* harmony export */   YXmlEvent: () => (/* binding */ YXmlEvent),\n/* harmony export */   applyUpdate: () => (/* binding */ applyUpdate),\n/* harmony export */   applyUpdateV2: () => (/* binding */ applyUpdateV2),\n/* harmony export */   cleanupYTextFormatting: () => (/* binding */ cleanupYTextFormatting),\n/* harmony export */   compareIDs: () => (/* binding */ compareIDs),\n/* harmony export */   compareRelativePositions: () => (/* binding */ compareRelativePositions),\n/* harmony export */   convertUpdateFormatV1ToV2: () => (/* binding */ convertUpdateFormatV1ToV2),\n/* harmony export */   convertUpdateFormatV2ToV1: () => (/* binding */ convertUpdateFormatV2ToV1),\n/* harmony export */   createAbsolutePositionFromRelativePosition: () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   createDeleteSet: () => (/* binding */ createDeleteSet),\n/* harmony export */   createDeleteSetFromStructStore: () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   createDocFromSnapshot: () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   createID: () => (/* binding */ createID),\n/* harmony export */   createRelativePositionFromJSON: () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   createRelativePositionFromTypeIndex: () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   createSnapshot: () => (/* binding */ createSnapshot),\n/* harmony export */   decodeRelativePosition: () => (/* binding */ decodeRelativePosition),\n/* harmony export */   decodeSnapshot: () => (/* binding */ decodeSnapshot),\n/* harmony export */   decodeSnapshotV2: () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   decodeStateVector: () => (/* binding */ decodeStateVector),\n/* harmony export */   decodeUpdate: () => (/* binding */ decodeUpdate),\n/* harmony export */   decodeUpdateV2: () => (/* binding */ decodeUpdateV2),\n/* harmony export */   diffUpdate: () => (/* binding */ diffUpdate),\n/* harmony export */   diffUpdateV2: () => (/* binding */ diffUpdateV2),\n/* harmony export */   emptySnapshot: () => (/* binding */ emptySnapshot),\n/* harmony export */   encodeRelativePosition: () => (/* binding */ encodeRelativePosition),\n/* harmony export */   encodeSnapshot: () => (/* binding */ encodeSnapshot),\n/* harmony export */   encodeSnapshotV2: () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   encodeStateAsUpdate: () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   encodeStateAsUpdateV2: () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   encodeStateVector: () => (/* binding */ encodeStateVector),\n/* harmony export */   encodeStateVectorFromUpdate: () => (/* binding */ encodeStateVectorFromUpdate),\n/* harmony export */   encodeStateVectorFromUpdateV2: () => (/* binding */ encodeStateVectorFromUpdateV2),\n/* harmony export */   equalDeleteSets: () => (/* binding */ equalDeleteSets),\n/* harmony export */   equalSnapshots: () => (/* binding */ equalSnapshots),\n/* harmony export */   findIndexSS: () => (/* binding */ findIndexSS),\n/* harmony export */   findRootTypeKey: () => (/* binding */ findRootTypeKey),\n/* harmony export */   getItem: () => (/* binding */ getItem),\n/* harmony export */   getState: () => (/* binding */ getState),\n/* harmony export */   getTypeChildren: () => (/* binding */ getTypeChildren),\n/* harmony export */   isDeleted: () => (/* binding */ isDeleted),\n/* harmony export */   isParentOf: () => (/* binding */ isParentOf),\n/* harmony export */   iterateDeletedStructs: () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   logType: () => (/* binding */ logType),\n/* harmony export */   logUpdate: () => (/* binding */ logUpdate),\n/* harmony export */   logUpdateV2: () => (/* binding */ logUpdateV2),\n/* harmony export */   mergeUpdates: () => (/* binding */ mergeUpdates),\n/* harmony export */   mergeUpdatesV2: () => (/* binding */ mergeUpdatesV2),\n/* harmony export */   obfuscateUpdate: () => (/* binding */ obfuscateUpdate),\n/* harmony export */   obfuscateUpdateV2: () => (/* binding */ obfuscateUpdateV2),\n/* harmony export */   parseUpdateMeta: () => (/* binding */ parseUpdateMeta),\n/* harmony export */   parseUpdateMetaV2: () => (/* binding */ parseUpdateMetaV2),\n/* harmony export */   readUpdate: () => (/* binding */ readUpdate),\n/* harmony export */   readUpdateV2: () => (/* binding */ readUpdateV2),\n/* harmony export */   relativePositionToJSON: () => (/* binding */ relativePositionToJSON),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   snapshotContainsUpdate: () => (/* binding */ snapshotContainsUpdate),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   tryGc: () => (/* binding */ tryGc),\n/* harmony export */   typeListToArraySnapshot: () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   typeMapGetAllSnapshot: () => (/* binding */ typeMapGetAllSnapshot),\n/* harmony export */   typeMapGetSnapshot: () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable */ \"(ssr)/./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/array */ \"(ssr)/./node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ \"(ssr)/./node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ \"(ssr)/./node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/promise */ \"(ssr)/./node_modules/lib0/promise.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/buffer */ \"(ssr)/./node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/binary */ \"(ssr)/./node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/function */ \"(ssr)/./node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/logging */ \"(ssr)/./node_modules/lib0/logging.node.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/logging */ \"(ssr)/./node_modules/lib0/logging.common.js\");\n/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/time */ \"(ssr)/./node_modules/lib0/time.js\");\n/* harmony import */ var lib0_string__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lib0/string */ \"(ssr)/./node_modules/lib0/string.js\");\n/* harmony import */ var lib0_iterator__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lib0/iterator */ \"(ssr)/./node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */ class AbstractConnector extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */ constructor(ydoc, awareness){\n        super();\n        this.doc = ydoc;\n        this.awareness = awareness;\n    }\n}\nclass DeleteItem {\n    /**\n   * @param {number} clock\n   * @param {number} len\n   */ constructor(clock, len){\n        /**\n     * @type {number}\n     */ this.clock = clock;\n        /**\n     * @type {number}\n     */ this.len = len;\n    }\n}\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */ class DeleteSet {\n    constructor(){\n        /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */ this.clients = new Map();\n    }\n}\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */ const iterateDeletedStructs = (transaction, ds, f)=>ds.clients.forEach((deletes, clientid)=>{\n        const structs = /** @type {Array<GC|Item>} */ transaction.doc.store.clients.get(clientid);\n        for(let i = 0; i < deletes.length; i++){\n            const del = deletes[i];\n            iterateStructs(transaction, structs, del.clock, del.len, f);\n        }\n    });\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */ const findIndexDS = (dis, clock)=>{\n    let left = 0;\n    let right = dis.length - 1;\n    while(left <= right){\n        const midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);\n        const mid = dis[midindex];\n        const midclock = mid.clock;\n        if (midclock <= clock) {\n            if (clock < midclock + mid.len) {\n                return midindex;\n            }\n            left = midindex + 1;\n        } else {\n            right = midindex - 1;\n        }\n    }\n    return null;\n};\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */ const isDeleted = (ds, id)=>{\n    const dis = ds.clients.get(id.client);\n    return dis !== undefined && findIndexDS(dis, id.clock) !== null;\n};\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */ const sortAndMergeDeleteSet = (ds)=>{\n    ds.clients.forEach((dels)=>{\n        dels.sort((a, b)=>a.clock - b.clock);\n        // merge items without filtering or splicing the array\n        // i is the current pointer\n        // j refers to the current insert position for the pointed item\n        // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n        let i, j;\n        for(i = 1, j = 1; i < dels.length; i++){\n            const left = dels[j - 1];\n            const right = dels[i];\n            if (left.clock + left.len >= right.clock) {\n                left.len = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(left.len, right.clock + right.len - left.clock);\n            } else {\n                if (j < i) {\n                    dels[j] = right;\n                }\n                j++;\n            }\n        }\n        dels.length = j;\n    });\n};\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */ const mergeDeleteSets = (dss)=>{\n    const merged = new DeleteSet();\n    for(let dssI = 0; dssI < dss.length; dssI++){\n        dss[dssI].clients.forEach((delsLeft, client)=>{\n            if (!merged.clients.has(client)) {\n                // Write all missing keys from current ds and all following.\n                // If merged already contains `client` current ds has already been added.\n                /**\n         * @type {Array<DeleteItem>}\n         */ const dels = delsLeft.slice();\n                for(let i = dssI + 1; i < dss.length; i++){\n                    lib0_array__WEBPACK_IMPORTED_MODULE_2__.appendTo(dels, dss[i].clients.get(client) || []);\n                }\n                merged.clients.set(client, dels);\n            }\n        });\n    }\n    sortAndMergeDeleteSet(merged);\n    return merged;\n};\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */ const addToDeleteSet = (ds, client, clock, length)=>{\n    lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []).push(new DeleteItem(clock, length));\n};\nconst createDeleteSet = ()=>new DeleteSet();\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */ const createDeleteSetFromStructStore = (ss)=>{\n    const ds = createDeleteSet();\n    ss.clients.forEach((structs, client)=>{\n        /**\n     * @type {Array<DeleteItem>}\n     */ const dsitems = [];\n        for(let i = 0; i < structs.length; i++){\n            const struct = structs[i];\n            if (struct.deleted) {\n                const clock = struct.id.clock;\n                let len = struct.length;\n                if (i + 1 < structs.length) {\n                    for(let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]){\n                        len += next.length;\n                    }\n                }\n                dsitems.push(new DeleteItem(clock, len));\n            }\n        }\n        if (dsitems.length > 0) {\n            ds.clients.set(client, dsitems);\n        }\n    });\n    return ds;\n};\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */ const writeDeleteSet = (encoder, ds)=>{\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, ds.clients.size);\n    // Ensure that the delete set is written in a deterministic order\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(ds.clients.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, dsitems])=>{\n        encoder.resetDsCurVal();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client);\n        const len = dsitems.length;\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, len);\n        for(let i = 0; i < len; i++){\n            const item = dsitems[i];\n            encoder.writeDsClock(item.clock);\n            encoder.writeDsLen(item.len);\n        }\n    });\n};\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */ const readDeleteSet = (decoder)=>{\n    const ds = new DeleteSet();\n    const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numClients; i++){\n        decoder.resetDsCurVal();\n        const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        if (numberOfDeletes > 0) {\n            const dsField = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []);\n            for(let i = 0; i < numberOfDeletes; i++){\n                dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n            }\n        }\n    }\n    return ds;\n};\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */ /**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */ const readAndApplyDeleteSet = (decoder, transaction, store)=>{\n    const unappliedDS = new DeleteSet();\n    const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numClients; i++){\n        decoder.resetDsCurVal();\n        const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const structs = store.clients.get(client) || [];\n        const state = getState(store, client);\n        for(let i = 0; i < numberOfDeletes; i++){\n            const clock = decoder.readDsClock();\n            const clockEnd = clock + decoder.readDsLen();\n            if (clock < state) {\n                if (state < clockEnd) {\n                    addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n                }\n                let index = findIndexSS(structs, clock);\n                /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */ // @ts-ignore\n                let struct = structs[index];\n                // split the first item if necessary\n                if (!struct.deleted && struct.id.clock < clock) {\n                    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n                    index++; // increase we now want to use the next struct\n                }\n                while(index < structs.length){\n                    // @ts-ignore\n                    struct = structs[index++];\n                    if (struct.id.clock < clockEnd) {\n                        if (!struct.deleted) {\n                            if (clockEnd < struct.id.clock + struct.length) {\n                                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n                            }\n                            struct.delete(transaction);\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n            }\n        }\n    }\n    if (unappliedDS.clients.size > 0) {\n        const ds = new UpdateEncoderV2();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(ds.restEncoder, 0); // encode 0 structs\n        writeDeleteSet(ds, unappliedDS);\n        return ds.toUint8Array();\n    }\n    return null;\n};\n/**\n * @param {DeleteSet} ds1\n * @param {DeleteSet} ds2\n */ const equalDeleteSets = (ds1, ds2)=>{\n    if (ds1.clients.size !== ds2.clients.size) return false;\n    for (const [client, deleteItems1] of ds1.clients.entries()){\n        const deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ ds2.clients.get(client);\n        if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;\n        for(let i = 0; i < deleteItems1.length; i++){\n            const di1 = deleteItems1[i];\n            const di2 = deleteItems2[i];\n            if (di1.clock !== di2.clock || di1.len !== di2.len) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * @module Y\n */ const generateNewClientId = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uint32;\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()\n */ /**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */ class Doc extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    /**\n   * @param {DocOpts} opts configuration\n   */ constructor({ guid = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uuidv4(), collectionid = null, gc = true, gcFilter = ()=>true, meta = null, autoLoad = false, shouldLoad = true } = {}){\n        super();\n        this.gc = gc;\n        this.gcFilter = gcFilter;\n        this.clientID = generateNewClientId();\n        this.guid = guid;\n        this.collectionid = collectionid;\n        /**\n     * @type {Map<string, AbstractType<YEvent<any>>>}\n     */ this.share = new Map();\n        this.store = new StructStore();\n        /**\n     * @type {Transaction | null}\n     */ this._transaction = null;\n        /**\n     * @type {Array<Transaction>}\n     */ this._transactionCleanups = [];\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocs = new Set();\n        /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */ this._item = null;\n        this.shouldLoad = shouldLoad;\n        this.autoLoad = autoLoad;\n        this.meta = meta;\n        /**\n     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.\n     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.\n     *\n     * @type {boolean}\n     */ this.isLoaded = false;\n        /**\n     * This is set to true when the connection provider has successfully synced with a backend.\n     * Note that when using peer-to-peer providers this event may not provide very useful.\n     * Also note that not all providers implement this feature. Provider authors are encouraged to fire\n     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is\n     * lost (with false as a parameter).\n     */ this.isSynced = false;\n        /**\n     * Promise that resolves once the document has been loaded from a presistence provider.\n     */ this.whenLoaded = lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create((resolve)=>{\n            this.on(\"load\", ()=>{\n                this.isLoaded = true;\n                resolve(this);\n            });\n        });\n        const provideSyncedPromise = ()=>lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create((resolve)=>{\n                /**\n       * @param {boolean} isSynced\n       */ const eventHandler = (isSynced)=>{\n                    if (isSynced === undefined || isSynced === true) {\n                        this.off(\"sync\", eventHandler);\n                        resolve();\n                    }\n                };\n                this.on(\"sync\", eventHandler);\n            });\n        this.on(\"sync\", (isSynced)=>{\n            if (isSynced === false && this.isSynced) {\n                this.whenSynced = provideSyncedPromise();\n            }\n            this.isSynced = isSynced === undefined || isSynced === true;\n            if (this.isSynced && !this.isLoaded) {\n                this.emit(\"load\", []);\n            }\n        });\n        /**\n     * Promise that resolves once the document has been synced with a backend.\n     * This promise is recreated when the connection is lost.\n     * Note the documentation about the `isSynced` property.\n     */ this.whenSynced = provideSyncedPromise();\n    }\n    /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */ load() {\n        const item = this._item;\n        if (item !== null && !this.shouldLoad) {\n            transact(/** @type {any} */ item.parent.doc, (transaction)=>{\n                transaction.subdocsLoaded.add(this);\n            }, null, true);\n        }\n        this.shouldLoad = true;\n    }\n    getSubdocs() {\n        return this.subdocs;\n    }\n    getSubdocGuids() {\n        return new Set(lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).map((doc)=>doc.guid));\n    }\n    /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */ transact(f, origin = null) {\n        return transact(this, f, origin);\n    }\n    /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @template {typeof AbstractType<any>} Type\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */ get(name, TypeConstructor = /** @type {any} */ AbstractType) {\n        const type = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(this.share, name, ()=>{\n            // @ts-ignore\n            const t = new TypeConstructor();\n            t._integrate(this, null);\n            return t;\n        });\n        const Constr = type.constructor;\n        if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n            if (Constr === AbstractType) {\n                // @ts-ignore\n                const t = new TypeConstructor();\n                t._map = type._map;\n                type._map.forEach(/** @param {Item?} n */ (n)=>{\n                    for(; n !== null; n = n.left){\n                        // @ts-ignore\n                        n.parent = t;\n                    }\n                });\n                t._start = type._start;\n                for(let n = t._start; n !== null; n = n.right){\n                    n.parent = t;\n                }\n                t._length = type._length;\n                this.share.set(name, t);\n                t._integrate(this, null);\n                return /** @type {InstanceType<Type>} */ t;\n            } else {\n                throw new Error(`Type with the name ${name} has already been defined with a different constructor`);\n            }\n        }\n        return /** @type {InstanceType<Type>} */ type;\n    }\n    /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */ getArray(name = \"\") {\n        return /** @type {YArray<T>} */ this.get(name, YArray);\n    }\n    /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */ getText(name = \"\") {\n        return this.get(name, YText);\n    }\n    /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */ getMap(name = \"\") {\n        return /** @type {YMap<T>} */ this.get(name, YMap);\n    }\n    /**\n   * @param {string} [name]\n   * @return {YXmlElement}\n   *\n   * @public\n   */ getXmlElement(name = \"\") {\n        return /** @type {YXmlElement<{[key:string]:string}>} */ this.get(name, YXmlElement);\n    }\n    /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */ getXmlFragment(name = \"\") {\n        return this.get(name, YXmlFragment);\n    }\n    /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */ toJSON() {\n        /**\n     * @type {Object<string, any>}\n     */ const doc = {};\n        this.share.forEach((value, key)=>{\n            doc[key] = value.toJSON();\n        });\n        return doc;\n    }\n    /**\n   * Emit `destroy` event and unregister all event handlers.\n   */ destroy() {\n        lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).forEach((subdoc)=>subdoc.destroy());\n        const item = this._item;\n        if (item !== null) {\n            this._item = null;\n            const content = /** @type {ContentDoc} */ item.content;\n            content.doc = new Doc({\n                guid: this.guid,\n                ...content.opts,\n                shouldLoad: false\n            });\n            content.doc._item = item;\n            transact(/** @type {any} */ item.parent.doc, (transaction)=>{\n                const doc = content.doc;\n                if (!item.deleted) {\n                    transaction.subdocsAdded.add(doc);\n                }\n                transaction.subdocsRemoved.add(this);\n            }, null, true);\n        }\n        this.emit(\"destroyed\", [\n            true\n        ]);\n        this.emit(\"destroy\", [\n            this\n        ]);\n        super.destroy();\n    }\n    /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */ on(eventName, f) {\n        super.on(eventName, f);\n    }\n    /**\n   * @param {string} eventName\n   * @param {function} f\n   */ off(eventName, f) {\n        super.off(eventName, f);\n    }\n}\nclass DSDecoderV1 {\n    /**\n   * @param {decoding.Decoder} decoder\n   */ constructor(decoder){\n        this.restDecoder = decoder;\n    }\n    resetDsCurVal() {\n    // nop\n    }\n    /**\n   * @return {number}\n   */ readDsClock() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * @return {number}\n   */ readDsLen() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n}\nclass UpdateDecoderV1 extends DSDecoderV1 {\n    /**\n   * @return {ID}\n   */ readLeftID() {\n        return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder));\n    }\n    /**\n   * @return {ID}\n   */ readRightID() {\n        return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder));\n    }\n    /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */ readClient() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * @return {number} info An unsigned 8-bit integer\n   */ readInfo() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8(this.restDecoder);\n    }\n    /**\n   * @return {string}\n   */ readString() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder);\n    }\n    /**\n   * @return {boolean} isKey\n   */ readParentInfo() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) === 1;\n    }\n    /**\n   * @return {number} info An unsigned 8-bit integer\n   */ readTypeRef() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */ readLen() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * @return {any}\n   */ readAny() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);\n    }\n    /**\n   * @return {Uint8Array}\n   */ readBuf() {\n        return lib0_buffer__WEBPACK_IMPORTED_MODULE_8__.copyUint8Array(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder));\n    }\n    /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */ readJSON() {\n        return JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder));\n    }\n    /**\n   * @return {string}\n   */ readKey() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder);\n    }\n}\nclass DSDecoderV2 {\n    /**\n   * @param {decoding.Decoder} decoder\n   */ constructor(decoder){\n        /**\n     * @private\n     */ this.dsCurrVal = 0;\n        this.restDecoder = decoder;\n    }\n    resetDsCurVal() {\n        this.dsCurrVal = 0;\n    }\n    /**\n   * @return {number}\n   */ readDsClock() {\n        this.dsCurrVal += lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n        return this.dsCurrVal;\n    }\n    /**\n   * @return {number}\n   */ readDsLen() {\n        const diff = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) + 1;\n        this.dsCurrVal += diff;\n        return diff;\n    }\n}\nclass UpdateDecoderV2 extends DSDecoderV2 {\n    /**\n   * @param {decoding.Decoder} decoder\n   */ constructor(decoder){\n        super(decoder);\n        /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */ this.keys = [];\n        lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder); // read feature flag - currently unused\n        this.keyClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.clientDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.leftClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.rightClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.infoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n        this.stringDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.StringDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.parentInfoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n        this.typeRefDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.lenDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    }\n    /**\n   * @return {ID}\n   */ readLeftID() {\n        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());\n    }\n    /**\n   * @return {ID}\n   */ readRightID() {\n        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());\n    }\n    /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */ readClient() {\n        return this.clientDecoder.read();\n    }\n    /**\n   * @return {number} info An unsigned 8-bit integer\n   */ readInfo() {\n        return /** @type {number} */ this.infoDecoder.read();\n    }\n    /**\n   * @return {string}\n   */ readString() {\n        return this.stringDecoder.read();\n    }\n    /**\n   * @return {boolean}\n   */ readParentInfo() {\n        return this.parentInfoDecoder.read() === 1;\n    }\n    /**\n   * @return {number} An unsigned 8-bit integer\n   */ readTypeRef() {\n        return this.typeRefDecoder.read();\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */ readLen() {\n        return this.lenDecoder.read();\n    }\n    /**\n   * @return {any}\n   */ readAny() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);\n    }\n    /**\n   * @return {Uint8Array}\n   */ readBuf() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder);\n    }\n    /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */ readJSON() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);\n    }\n    /**\n   * @return {string}\n   */ readKey() {\n        const keyClock = this.keyClockDecoder.read();\n        if (keyClock < this.keys.length) {\n            return this.keys[keyClock];\n        } else {\n            const key = this.stringDecoder.read();\n            this.keys.push(key);\n            return key;\n        }\n    }\n}\nclass DSEncoderV1 {\n    constructor(){\n        this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    }\n    toUint8Array() {\n        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder);\n    }\n    resetDsCurVal() {\n    // nop\n    }\n    /**\n   * @param {number} clock\n   */ writeDsClock(clock) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, clock);\n    }\n    /**\n   * @param {number} len\n   */ writeDsLen(len) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n    }\n}\nclass UpdateEncoderV1 extends DSEncoderV1 {\n    /**\n   * @param {ID} id\n   */ writeLeftID(id) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n    }\n    /**\n   * @param {ID} id\n   */ writeRightID(id) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n    }\n    /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */ writeClient(client) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, client);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeInfo(info) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(this.restEncoder, info);\n    }\n    /**\n   * @param {string} s\n   */ writeString(s) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, s);\n    }\n    /**\n   * @param {boolean} isYKey\n   */ writeParentInfo(isYKey) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeTypeRef(info) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, info);\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */ writeLen(len) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n    }\n    /**\n   * @param {any} any\n   */ writeAny(any) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n    }\n    /**\n   * @param {Uint8Array} buf\n   */ writeBuf(buf) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n    }\n    /**\n   * @param {any} embed\n   */ writeJSON(embed) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, JSON.stringify(embed));\n    }\n    /**\n   * @param {string} key\n   */ writeKey(key) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, key);\n    }\n}\nclass DSEncoderV2 {\n    constructor(){\n        this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder(); // encodes all the rest / non-optimized\n        this.dsCurrVal = 0;\n    }\n    toUint8Array() {\n        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder);\n    }\n    resetDsCurVal() {\n        this.dsCurrVal = 0;\n    }\n    /**\n   * @param {number} clock\n   */ writeDsClock(clock) {\n        const diff = clock - this.dsCurrVal;\n        this.dsCurrVal = clock;\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, diff);\n    }\n    /**\n   * @param {number} len\n   */ writeDsLen(len) {\n        if (len === 0) {\n            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len - 1);\n        this.dsCurrVal += len;\n    }\n}\nclass UpdateEncoderV2 extends DSEncoderV2 {\n    constructor(){\n        super();\n        /**\n     * @type {Map<string,number>}\n     */ this.keyMap = new Map();\n        /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */ this.keyClock = 0;\n        this.keyClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n        this.clientEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n        this.leftClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n        this.rightClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n        this.infoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n        this.stringEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n        this.parentInfoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n        this.typeRefEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n        this.lenEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    }\n    toUint8Array() {\n        const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.infoEncoder));\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.parentInfoEncoder));\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n        // @note The rest encoder is appended! (note the missing var)\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder));\n        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);\n    }\n    /**\n   * @param {ID} id\n   */ writeLeftID(id) {\n        this.clientEncoder.write(id.client);\n        this.leftClockEncoder.write(id.clock);\n    }\n    /**\n   * @param {ID} id\n   */ writeRightID(id) {\n        this.clientEncoder.write(id.client);\n        this.rightClockEncoder.write(id.clock);\n    }\n    /**\n   * @param {number} client\n   */ writeClient(client) {\n        this.clientEncoder.write(client);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeInfo(info) {\n        this.infoEncoder.write(info);\n    }\n    /**\n   * @param {string} s\n   */ writeString(s) {\n        this.stringEncoder.write(s);\n    }\n    /**\n   * @param {boolean} isYKey\n   */ writeParentInfo(isYKey) {\n        this.parentInfoEncoder.write(isYKey ? 1 : 0);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeTypeRef(info) {\n        this.typeRefEncoder.write(info);\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */ writeLen(len) {\n        this.lenEncoder.write(len);\n    }\n    /**\n   * @param {any} any\n   */ writeAny(any) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n    }\n    /**\n   * @param {Uint8Array} buf\n   */ writeBuf(buf) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n    }\n    /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */ writeJSON(embed) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, embed);\n    }\n    /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */ writeKey(key) {\n        const clock = this.keyMap.get(key);\n        if (clock === undefined) {\n            /**\n       * @todo uncomment to introduce this feature finally\n       *\n       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.\n       * Furthermore, I forgot to set the keyclock. So everything was working fine.\n       *\n       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).\n       *\n       * I don't know yet how to reintroduce this feature..\n       *\n       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.\n       *\n       */ // this.keyMap.set(key, this.keyClock)\n            this.keyClockEncoder.write(this.keyClock++);\n            this.stringEncoder.write(key);\n        } else {\n            this.keyClockEncoder.write(clock);\n        }\n    }\n}\n/**\n * @module encoding\n */ /*\n * We use the first five bits in the info flag for determining the type of the struct.\n *\n * 0: GC\n * 1: Item with Deleted content\n * 2: Item with JSON content\n * 3: Item with Binary content\n * 4: Item with String content\n * 5: Item with Embed content (for richtext content)\n * 6: Item with Format content (a formatting marker for richtext content)\n * 7: Item with Type\n */ /**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */ const writeStructs = (encoder, structs, client, clock)=>{\n    // write first id\n    clock = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(clock, structs[0].id.clock); // make sure the first id exists\n    const startNewStructs = findIndexSS(structs, clock);\n    // write # encoded structs\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n    encoder.writeClient(client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n    const firstStruct = structs[startNewStructs];\n    // write first struct with an offset\n    firstStruct.write(encoder, clock - firstStruct.id.clock);\n    for(let i = startNewStructs + 1; i < structs.length; i++){\n        structs[i].write(encoder, 0);\n    }\n};\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */ const writeClientsStructs = (encoder, store, _sm)=>{\n    // we filter all valid _sm entries into sm\n    const sm = new Map();\n    _sm.forEach((clock, client)=>{\n        // only write if new structs are available\n        if (getState(store, client) > clock) {\n            sm.set(client, clock);\n        }\n    });\n    getStateVector(store).forEach((_clock, client)=>{\n        if (!_sm.has(client)) {\n            sm.set(client, 0);\n        }\n    });\n    // write # states that were updated\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sm.size);\n    // Write items with higher client ids first\n    // This heavily improves the conflict algorithm.\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sm.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{\n        writeStructs(encoder, /** @type {Array<GC|Item>} */ store.clients.get(client), client, clock);\n    });\n};\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */ const readClientsStructRefs = (decoder, doc)=>{\n    /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */ const clientRefs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numOfStateUpdates; i++){\n        const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        /**\n     * @type {Array<GC|Item>}\n     */ const refs = new Array(numberOfStructs);\n        const client = decoder.readClient();\n        let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        // const start = performance.now()\n        clientRefs.set(client, {\n            i: 0,\n            refs\n        });\n        for(let i = 0; i < numberOfStructs; i++){\n            const info = decoder.readInfo();\n            switch(lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info){\n                case 0:\n                    {\n                        const len = decoder.readLen();\n                        refs[i] = new GC(createID(client, clock), len);\n                        clock += len;\n                        break;\n                    }\n                case 10:\n                    {\n                        // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n                        const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n                        refs[i] = new Skip(createID(client, clock), len);\n                        clock += len;\n                        break;\n                    }\n                default:\n                    {\n                        /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */ const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n                        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n                        // and we read the next string as parentYKey.\n                        // It indicates how we store/retrieve parent from `y.share`\n                        // @type {string|null}\n                        const struct = new Item(createID(client, clock), null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content\n                        );\n                        /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */ refs[i] = struct;\n                        clock += struct.length;\n                    }\n            }\n        }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n    }\n    return clientRefs;\n};\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */ const integrateStructs = (transaction, store, clientsStructRefs)=>{\n    /**\n   * @type {Array<Item | GC>}\n   */ const stack = [];\n    // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n    let clientsStructRefsIds = lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(clientsStructRefs.keys()).sort((a, b)=>a - b);\n    if (clientsStructRefsIds.length === 0) {\n        return null;\n    }\n    const getNextStructTarget = ()=>{\n        if (clientsStructRefsIds.length === 0) {\n            return null;\n        }\n        let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n        while(nextStructsTarget.refs.length === nextStructsTarget.i){\n            clientsStructRefsIds.pop();\n            if (clientsStructRefsIds.length > 0) {\n                nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n            } else {\n                return null;\n            }\n        }\n        return nextStructsTarget;\n    };\n    let curStructsTarget = getNextStructTarget();\n    if (curStructsTarget === null) {\n        return null;\n    }\n    /**\n   * @type {StructStore}\n   */ const restStructs = new StructStore();\n    const missingSV = new Map();\n    /**\n   * @param {number} client\n   * @param {number} clock\n   */ const updateMissingSv = (client, clock)=>{\n        const mclock = missingSV.get(client);\n        if (mclock == null || mclock > clock) {\n            missingSV.set(client, clock);\n        }\n    };\n    /**\n   * @type {GC|Item}\n   */ let stackHead = /** @type {any} */ curStructsTarget.refs[/** @type {any} */ curStructsTarget.i++];\n    // caching the state because it is used very often\n    const state = new Map();\n    const addStackToRestSS = ()=>{\n        for (const item of stack){\n            const client = item.id.client;\n            const unapplicableItems = clientsStructRefs.get(client);\n            if (unapplicableItems) {\n                // decrement because we weren't able to apply previous operation\n                unapplicableItems.i--;\n                restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n                clientsStructRefs.delete(client);\n                unapplicableItems.i = 0;\n                unapplicableItems.refs = [];\n            } else {\n                // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n                restStructs.clients.set(client, [\n                    item\n                ]);\n            }\n            // remove client from clientsStructRefsIds to prevent users from applying the same update again\n            clientsStructRefsIds = clientsStructRefsIds.filter((c)=>c !== client);\n        }\n        stack.length = 0;\n    };\n    // iterate over all struct readers until we are done\n    while(true){\n        if (stackHead.constructor !== Skip) {\n            const localClock = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(state, stackHead.id.client, ()=>getState(store, stackHead.id.client));\n            const offset = localClock - stackHead.id.clock;\n            if (offset < 0) {\n                // update from the same client is missing\n                stack.push(stackHead);\n                updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n                // hid a dead wall, add all items from stack to restSS\n                addStackToRestSS();\n            } else {\n                const missing = stackHead.getMissing(transaction, store);\n                if (missing !== null) {\n                    stack.push(stackHead);\n                    // get the struct reader that has the missing struct\n                    /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */ const structRefs = clientsStructRefs.get(/** @type {number} */ missing) || {\n                        refs: [],\n                        i: 0\n                    };\n                    if (structRefs.refs.length === structRefs.i) {\n                        // This update message causally depends on another update message that doesn't exist yet\n                        updateMissingSv(/** @type {number} */ missing, getState(store, missing));\n                        addStackToRestSS();\n                    } else {\n                        stackHead = structRefs.refs[structRefs.i++];\n                        continue;\n                    }\n                } else if (offset === 0 || offset < stackHead.length) {\n                    // all fine, apply the stackhead\n                    stackHead.integrate(transaction, offset);\n                    state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n                }\n            }\n        }\n        // iterate to next stackHead\n        if (stack.length > 0) {\n            stackHead = /** @type {GC|Item} */ stack.pop();\n        } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n            stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];\n        } else {\n            curStructsTarget = getNextStructTarget();\n            if (curStructsTarget === null) {\n                break;\n            } else {\n                stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];\n            }\n        }\n    }\n    if (restStructs.clients.size > 0) {\n        const encoder = new UpdateEncoderV2();\n        writeClientsStructs(encoder, restStructs, new Map());\n        // write empty deleteset\n        // writeDeleteSet(encoder, new DeleteSet())\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n        return {\n            missing: missingSV,\n            update: encoder.toUint8Array()\n        };\n    }\n    return null;\n};\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */ const writeStructsFromTransaction = (encoder, transaction)=>writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */ const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder))=>transact(ydoc, (transaction)=>{\n        // force that transaction.local is set to non-local\n        transaction.local = false;\n        let retry = false;\n        const doc = transaction.doc;\n        const store = doc.store;\n        // let start = performance.now()\n        const ss = readClientsStructRefs(structDecoder, doc);\n        // console.log('time to read structs: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        // console.log('time to merge: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        const restStructs = integrateStructs(transaction, store, ss);\n        const pending = store.pendingStructs;\n        if (pending) {\n            // check if we can apply something\n            for (const [client, clock] of pending.missing){\n                if (clock < getState(store, client)) {\n                    retry = true;\n                    break;\n                }\n            }\n            if (restStructs) {\n                // merge restStructs into store.pending\n                for (const [client, clock] of restStructs.missing){\n                    const mclock = pending.missing.get(client);\n                    if (mclock == null || mclock > clock) {\n                        pending.missing.set(client, clock);\n                    }\n                }\n                pending.update = mergeUpdatesV2([\n                    pending.update,\n                    restStructs.update\n                ]);\n            }\n        } else {\n            store.pendingStructs = restStructs;\n        }\n        // console.log('time to integrate: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n        if (store.pendingDs) {\n            // @todo we could make a lower-bound state-vector check as we do above\n            const pendingDSUpdate = new UpdateDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(store.pendingDs));\n            lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n            const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n            if (dsRest && dsRest2) {\n                // case 1: ds1 != null && ds2 != null\n                store.pendingDs = mergeUpdatesV2([\n                    dsRest,\n                    dsRest2\n                ]);\n            } else {\n                // case 2: ds1 != null\n                // case 3: ds2 != null\n                // case 4: ds1 == null && ds2 == null\n                store.pendingDs = dsRest || dsRest2;\n            }\n        } else {\n            // Either dsRest == null && pendingDs == null OR dsRest != null\n            store.pendingDs = dsRest;\n        }\n        // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        if (retry) {\n            const update = /** @type {{update: Uint8Array}} */ store.pendingStructs.update;\n            store.pendingStructs = null;\n            applyUpdateV2(transaction.doc, update);\n        }\n    }, transactionOrigin, false);\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */ const readUpdate = (decoder, ydoc, transactionOrigin)=>readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */ const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2)=>{\n    const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update);\n    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */ const applyUpdate = (ydoc, update, transactionOrigin)=>applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */ const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map())=>{\n    writeClientsStructs(encoder, doc.store, targetStateVector);\n    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([\n    0\n]), encoder = new UpdateEncoderV2())=>{\n    const targetStateVector = decodeStateVector(encodedTargetStateVector);\n    writeStateAsUpdate(encoder, doc, targetStateVector);\n    const updates = [\n        encoder.toUint8Array()\n    ];\n    // also add the pending updates (if there are any)\n    if (doc.store.pendingDs) {\n        updates.push(doc.store.pendingDs);\n    }\n    if (doc.store.pendingStructs) {\n        updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n        if (encoder.constructor === UpdateEncoderV1) {\n            return mergeUpdates(updates.map((update, i)=>i === 0 ? update : convertUpdateFormatV2ToV1(update)));\n        } else if (encoder.constructor === UpdateEncoderV2) {\n            return mergeUpdatesV2(updates);\n        }\n    }\n    return updates[0];\n};\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateAsUpdate = (doc, encodedTargetStateVector)=>encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */ const readStateVector = (decoder)=>{\n    const ss = new Map();\n    const ssLength = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < ssLength; i++){\n        const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        ss.set(client, clock);\n    }\n    return ss;\n};\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */ // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */ const decodeStateVector = (decodedState)=>readStateVector(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(decodedState)));\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */ const writeStateVector = (encoder, sv)=>{\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sv.size);\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sv.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n    });\n    return encoder;\n};\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */ const writeDocumentStateVector = (encoder, doc)=>writeStateVector(encoder, getStateVector(doc.store));\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2())=>{\n    if (doc instanceof Map) {\n        writeStateVector(encoder, doc);\n    } else {\n        writeDocumentStateVector(encoder, doc);\n    }\n    return encoder.toUint8Array();\n};\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateVector = (doc)=>encodeStateVectorV2(doc, new DSEncoderV1());\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */ class EventHandler {\n    constructor(){\n        /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */ this.l = [];\n    }\n}\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */ const createEventHandler = ()=>new EventHandler();\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */ const addEventHandlerListener = (eventHandler, f)=>eventHandler.l.push(f);\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */ const removeEventHandlerListener = (eventHandler, f)=>{\n    const l = eventHandler.l;\n    const len = l.length;\n    eventHandler.l = l.filter((g)=>f !== g);\n    if (len === eventHandler.l.length) {\n        console.error(\"[yjs] Tried to remove event handler that doesn't exist.\");\n    }\n};\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */ const callEventHandlerListeners = (eventHandler, arg0, arg1)=>lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll(eventHandler.l, [\n        arg0,\n        arg1\n    ]);\nclass ID {\n    /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */ constructor(client, clock){\n        /**\n     * Client id\n     * @type {number}\n     */ this.client = client;\n        /**\n     * unique per client id, continuous number\n     * @type {number}\n     */ this.clock = clock;\n    }\n}\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */ const compareIDs = (a, b)=>a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */ const createID = (client, clock)=>new ID(client, clock);\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */ const writeID = (encoder, id)=>{\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.clock);\n};\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */ const readID = (decoder)=>createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder));\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */ const findRootTypeKey = (type)=>{\n    // @ts-ignore _y must be defined, otherwise unexpected case\n    for (const [key, value] of type.doc.share.entries()){\n        if (value === type) {\n            return key;\n        }\n    }\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n};\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */ const isParentOf = (parent, child)=>{\n    while(child !== null){\n        if (child.parent === parent) {\n            return true;\n        }\n        child = /** @type {AbstractType<any>} */ child.parent._item;\n    }\n    return false;\n};\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */ const logType = (type)=>{\n    const res = [];\n    let n = type._start;\n    while(n){\n        res.push(n);\n        n = n.right;\n    }\n    console.log(\"Children: \", res);\n    console.log(\"Children content: \", res.filter((m)=>!m.deleted).map((m)=>m.content));\n};\nclass PermanentUserData {\n    /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */ constructor(doc, storeType = doc.getMap(\"users\")){\n        /**\n     * @type {Map<string,DeleteSet>}\n     */ const dss = new Map();\n        this.yusers = storeType;\n        this.doc = doc;\n        /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */ this.clients = new Map();\n        this.dss = dss;\n        /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */ const initUser = (user, userDescription)=>{\n            /**\n       * @type {YArray<Uint8Array>}\n       */ const ds = user.get(\"ds\");\n            const ids = user.get(\"ids\");\n            const addClientId = /** @param {number} clientid */ (clientid)=>this.clients.set(clientid, userDescription);\n            ds.observe(/** @param {YArrayEvent<any>} event */ (event)=>{\n                event.changes.added.forEach((item)=>{\n                    item.content.getContent().forEach((encodedDs)=>{\n                        if (encodedDs instanceof Uint8Array) {\n                            this.dss.set(userDescription, mergeDeleteSets([\n                                this.dss.get(userDescription) || createDeleteSet(),\n                                readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs)))\n                            ]));\n                        }\n                    });\n                });\n            });\n            this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs)=>readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs))))));\n            ids.observe(/** @param {YArrayEvent<any>} event */ (event)=>event.changes.added.forEach((item)=>item.content.getContent().forEach(addClientId)));\n            ids.forEach(addClientId);\n        };\n        // observe users\n        storeType.observe((event)=>{\n            event.keysChanged.forEach((userDescription)=>initUser(storeType.get(userDescription), userDescription));\n        });\n        // add intial data\n        storeType.forEach(initUser);\n    }\n    /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} conf\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */ setUserMapping(doc, clientid, userDescription, { filter = ()=>true } = {}) {\n        const users = this.yusers;\n        let user = users.get(userDescription);\n        if (!user) {\n            user = new YMap();\n            user.set(\"ids\", new YArray());\n            user.set(\"ds\", new YArray());\n            users.set(userDescription, user);\n        }\n        user.get(\"ids\").push([\n            clientid\n        ]);\n        users.observe((_event)=>{\n            setTimeout(()=>{\n                const userOverwrite = users.get(userDescription);\n                if (userOverwrite !== user) {\n                    // user was overwritten, port all data over to the next user object\n                    // @todo Experiment with Y.Sets here\n                    user = userOverwrite;\n                    // @todo iterate over old type\n                    this.clients.forEach((_userDescription, clientid)=>{\n                        if (userDescription === _userDescription) {\n                            user.get(\"ids\").push([\n                                clientid\n                            ]);\n                        }\n                    });\n                    const encoder = new DSEncoderV1();\n                    const ds = this.dss.get(userDescription);\n                    if (ds) {\n                        writeDeleteSet(encoder, ds);\n                        user.get(\"ds\").push([\n                            encoder.toUint8Array()\n                        ]);\n                    }\n                }\n            }, 0);\n        });\n        doc.on(\"afterTransaction\", /** @param {Transaction} transaction */ (transaction)=>{\n            setTimeout(()=>{\n                const yds = user.get(\"ds\");\n                const ds = transaction.deleteSet;\n                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n                    const encoder = new DSEncoderV1();\n                    writeDeleteSet(encoder, ds);\n                    yds.push([\n                        encoder.toUint8Array()\n                    ]);\n                }\n            });\n        });\n    }\n    /**\n   * @param {number} clientid\n   * @return {any}\n   */ getUserByClientId(clientid) {\n        return this.clients.get(clientid) || null;\n    }\n    /**\n   * @param {ID} id\n   * @return {string | null}\n   */ getUserByDeletedId(id) {\n        for (const [userDescription, ds] of this.dss.entries()){\n            if (isDeleted(ds, id)) {\n                return userDescription;\n            }\n        }\n        return null;\n    }\n}\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */ class RelativePosition {\n    /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */ constructor(type, tname, item, assoc = 0){\n        /**\n     * @type {ID|null}\n     */ this.type = type;\n        /**\n     * @type {string|null}\n     */ this.tname = tname;\n        /**\n     * @type {ID | null}\n     */ this.item = item;\n        /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */ this.assoc = assoc;\n    }\n}\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */ const relativePositionToJSON = (rpos)=>{\n    const json = {};\n    if (rpos.type) {\n        json.type = rpos.type;\n    }\n    if (rpos.tname) {\n        json.tname = rpos.tname;\n    }\n    if (rpos.item) {\n        json.item = rpos.item;\n    }\n    if (rpos.assoc != null) {\n        json.assoc = rpos.assoc;\n    }\n    return json;\n};\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */ const createRelativePositionFromJSON = (json)=>new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\nclass AbsolutePosition {\n    /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */ constructor(type, index, assoc = 0){\n        /**\n     * @type {AbstractType<any>}\n     */ this.type = type;\n        /**\n     * @type {number}\n     */ this.index = index;\n        this.assoc = assoc;\n    }\n}\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */ const createAbsolutePosition = (type, index, assoc = 0)=>new AbsolutePosition(type, index, assoc);\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */ const createRelativePosition = (type, item, assoc)=>{\n    let typeid = null;\n    let tname = null;\n    if (type._item === null) {\n        tname = findRootTypeKey(type);\n    } else {\n        typeid = createID(type._item.id.client, type._item.id.clock);\n    }\n    return new RelativePosition(typeid, tname, item, assoc);\n};\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */ const createRelativePositionFromTypeIndex = (type, index, assoc = 0)=>{\n    let t = type._start;\n    if (assoc < 0) {\n        // associated to the left character or the beginning of a type, increment index if possible.\n        if (index === 0) {\n            return createRelativePosition(type, null, assoc);\n        }\n        index--;\n    }\n    while(t !== null){\n        if (!t.deleted && t.countable) {\n            if (t.length > index) {\n                // case 1: found position somewhere in the linked list\n                return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);\n            }\n            index -= t.length;\n        }\n        if (t.right === null && assoc < 0) {\n            // left-associated position, return last available id\n            return createRelativePosition(type, t.lastId, assoc);\n        }\n        t = t.right;\n    }\n    return createRelativePosition(type, null, assoc);\n};\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */ const writeRelativePosition = (encoder, rpos)=>{\n    const { type, tname, item, assoc } = rpos;\n    if (item !== null) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0);\n        writeID(encoder, item);\n    } else if (tname !== null) {\n        // case 2: found position at the end of the list and type is stored in y.share\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 1);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, tname);\n    } else if (type !== null) {\n        // case 3: found position at the end of the list and type is attached to an item\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 2);\n        writeID(encoder, type);\n    } else {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarInt(encoder, assoc);\n    return encoder;\n};\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */ const encodeRelativePosition = (rpos)=>{\n    const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    writeRelativePosition(encoder, rpos);\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);\n};\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */ const readRelativePosition = (decoder)=>{\n    let type = null;\n    let tname = null;\n    let itemID = null;\n    switch(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)){\n        case 0:\n            // case 1: found position somewhere in the linked list\n            itemID = readID(decoder);\n            break;\n        case 1:\n            // case 2: found position at the end of the list and type is stored in y.share\n            tname = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder);\n            break;\n        case 2:\n            {\n                // case 3: found position at the end of the list and type is attached to an item\n                type = readID(decoder);\n            }\n    }\n    const assoc = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.hasContent(decoder) ? lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarInt(decoder) : 0;\n    return new RelativePosition(type, tname, itemID, assoc);\n};\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */ const decodeRelativePosition = (uint8Array)=>readRelativePosition(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(uint8Array));\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */ const createAbsolutePositionFromRelativePosition = (rpos, doc)=>{\n    const store = doc.store;\n    const rightID = rpos.item;\n    const typeID = rpos.type;\n    const tname = rpos.tname;\n    const assoc = rpos.assoc;\n    let type = null;\n    let index = 0;\n    if (rightID !== null) {\n        if (getState(store, rightID.client) <= rightID.clock) {\n            return null;\n        }\n        const res = followRedone(store, rightID);\n        const right = res.item;\n        if (!(right instanceof Item)) {\n            return null;\n        }\n        type = /** @type {AbstractType<any>} */ right.parent;\n        if (type._item === null || !type._item.deleted) {\n            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary\n            let n = right.left;\n            while(n !== null){\n                if (!n.deleted && n.countable) {\n                    index += n.length;\n                }\n                n = n.left;\n            }\n        }\n    } else {\n        if (tname !== null) {\n            type = doc.get(tname);\n        } else if (typeID !== null) {\n            if (getState(store, typeID.client) <= typeID.clock) {\n                // type does not exist yet\n                return null;\n            }\n            const { item } = followRedone(store, typeID);\n            if (item instanceof Item && item.content instanceof ContentType) {\n                type = item.content.type;\n            } else {\n                // struct is garbage collected\n                return null;\n            }\n        } else {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        if (assoc >= 0) {\n            index = type._length;\n        } else {\n            index = 0;\n        }\n    }\n    return createAbsolutePosition(type, index, rpos.assoc);\n};\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */ const compareRelativePositions = (a, b)=>a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;\nclass Snapshot {\n    /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */ constructor(ds, sv){\n        /**\n     * @type {DeleteSet}\n     */ this.ds = ds;\n        /**\n     * State Map\n     * @type {Map<number,number>}\n     */ this.sv = sv;\n    }\n}\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */ const equalSnapshots = (snap1, snap2)=>{\n    const ds1 = snap1.ds.clients;\n    const ds2 = snap2.ds.clients;\n    const sv1 = snap1.sv;\n    const sv2 = snap2.sv;\n    if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n        return false;\n    }\n    for (const [key, value] of sv1.entries()){\n        if (sv2.get(key) !== value) {\n            return false;\n        }\n    }\n    for (const [client, dsitems1] of ds1.entries()){\n        const dsitems2 = ds2.get(client) || [];\n        if (dsitems1.length !== dsitems2.length) {\n            return false;\n        }\n        for(let i = 0; i < dsitems1.length; i++){\n            const dsitem1 = dsitems1[i];\n            const dsitem2 = dsitems2[i];\n            if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */ const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2())=>{\n    writeDeleteSet(encoder, snapshot.ds);\n    writeStateVector(encoder, snapshot.sv);\n    return encoder.toUint8Array();\n};\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */ const encodeSnapshot = (snapshot)=>encodeSnapshotV2(snapshot, new DSEncoderV1());\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */ const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)))=>{\n    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));\n};\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */ const decodeSnapshot = (buf)=>decodeSnapshotV2(buf, new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)));\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */ const createSnapshot = (ds, sm)=>new Snapshot(ds, sm);\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */ const snapshot = (doc)=>createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */ const splitSnapshotAffectedStructs = (transaction, snapshot)=>{\n    const meta = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create);\n    const store = transaction.doc.store;\n    // check if we already split for this snapshot\n    if (!meta.has(snapshot)) {\n        snapshot.sv.forEach((clock, client)=>{\n            if (clock < getState(store, client)) {\n                getItemCleanStart(transaction, createID(client, clock));\n            }\n        });\n        iterateDeletedStructs(transaction, snapshot.ds, (_item)=>{});\n        meta.add(snapshot);\n    }\n};\n/**\n * @example\n *  const ydoc = new Y.Doc({ gc: false })\n *  ydoc.getText().insert(0, 'world!')\n *  const snapshot = Y.snapshot(ydoc)\n *  ydoc.getText().insert(0, 'hello ')\n *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)\n *  assert(restored.getText().toString() === 'world!')\n *\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */ const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc())=>{\n    if (originDoc.gc) {\n        // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n        throw new Error(\"Garbage-collection must be disabled in `originDoc`!\");\n    }\n    const { sv, ds } = snapshot;\n    const encoder = new UpdateEncoderV2();\n    originDoc.transact((transaction)=>{\n        let size = 0;\n        sv.forEach((clock)=>{\n            if (clock > 0) {\n                size++;\n            }\n        });\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, size);\n        // splitting the structs before writing them to the encoder\n        for (const [client, clock] of sv){\n            if (clock === 0) {\n                continue;\n            }\n            if (clock < getState(originDoc.store, client)) {\n                getItemCleanStart(transaction, createID(client, clock));\n            }\n            const structs = originDoc.store.clients.get(client) || [];\n            const lastStructIndex = findIndexSS(structs, clock - 1);\n            // write # encoded structs\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n            encoder.writeClient(client);\n            // first clock written is 0\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n            for(let i = 0; i <= lastStructIndex; i++){\n                structs[i].write(encoder, 0);\n            }\n        }\n        writeDeleteSet(encoder, ds);\n    });\n    applyUpdateV2(newDoc, encoder.toUint8Array(), \"snapshot\");\n    return newDoc;\n};\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n */ const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2)=>{\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n            return false;\n        }\n    }\n    const mergedDS = mergeDeleteSets([\n        snapshot.ds,\n        readDeleteSet(updateDecoder)\n    ]);\n    return equalDeleteSets(snapshot.ds, mergedDS);\n};\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n */ const snapshotContainsUpdate = (snapshot, update)=>snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);\nclass StructStore {\n    constructor(){\n        /**\n     * @type {Map<number,Array<GC|Item>>}\n     */ this.clients = new Map();\n        /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */ this.pendingStructs = null;\n        /**\n     * @type {null | Uint8Array}\n     */ this.pendingDs = null;\n    }\n}\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */ const getStateVector = (store)=>{\n    const sm = new Map();\n    store.clients.forEach((structs, client)=>{\n        const struct = structs[structs.length - 1];\n        sm.set(client, struct.id.clock + struct.length);\n    });\n    return sm;\n};\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */ const getState = (store, client)=>{\n    const structs = store.clients.get(client);\n    if (structs === undefined) {\n        return 0;\n    }\n    const lastStruct = structs[structs.length - 1];\n    return lastStruct.id.clock + lastStruct.length;\n};\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */ const addStruct = (store, struct)=>{\n    let structs = store.clients.get(struct.id.client);\n    if (structs === undefined) {\n        structs = [];\n        store.clients.set(struct.id.client, structs);\n    } else {\n        const lastStruct = structs[structs.length - 1];\n        if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n    }\n    structs.push(struct);\n};\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */ const findIndexSS = (structs, clock)=>{\n    let left = 0;\n    let right = structs.length - 1;\n    let mid = structs[right];\n    let midclock = mid.id.clock;\n    if (midclock === clock) {\n        return right;\n    }\n    // @todo does it even make sense to pivot the search?\n    // If a good split misses, it might actually increase the time to find the correct item.\n    // Currently, the only advantage is that search with pivoting might find the item on the first try.\n    let midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor(clock / (midclock + mid.length - 1) * right); // pivoting the search\n    while(left <= right){\n        mid = structs[midindex];\n        midclock = mid.id.clock;\n        if (midclock <= clock) {\n            if (clock < midclock + mid.length) {\n                return midindex;\n            }\n            left = midindex + 1;\n        } else {\n            right = midindex - 1;\n        }\n        midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);\n    }\n    // Always check state before looking for a struct in StructStore\n    // Therefore the case of not finding a struct is unexpected\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */ const find = (store, id)=>{\n    /**\n   * @type {Array<GC|Item>}\n   */ // @ts-ignore\n    const structs = store.clients.get(id.client);\n    return structs[findIndexSS(structs, id.clock)];\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */ const getItem = /** @type {function(StructStore,ID):Item} */ find;\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */ const findIndexCleanStart = (transaction, structs, clock)=>{\n    const index = findIndexSS(structs, clock);\n    const struct = structs[index];\n    if (struct.id.clock < clock && struct instanceof Item) {\n        structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n        return index + 1;\n    }\n    return index;\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */ const getItemCleanStart = (transaction, id)=>{\n    const structs = /** @type {Array<Item>} */ transaction.doc.store.clients.get(id.client);\n    return structs[findIndexCleanStart(transaction, structs, id.clock)];\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */ const getItemCleanEnd = (transaction, store, id)=>{\n    /**\n   * @type {Array<Item>}\n   */ // @ts-ignore\n    const structs = store.clients.get(id.client);\n    const index = findIndexSS(structs, id.clock);\n    const struct = structs[index];\n    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n        structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n    }\n    return struct;\n};\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */ const replaceStruct = (store, struct, newStruct)=>{\n    const structs = /** @type {Array<GC|Item>} */ store.clients.get(struct.id.client);\n    structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */ const iterateStructs = (transaction, structs, clockStart, len, f)=>{\n    if (len === 0) {\n        return;\n    }\n    const clockEnd = clockStart + len;\n    let index = findIndexCleanStart(transaction, structs, clockStart);\n    let struct;\n    do {\n        struct = structs[index++];\n        if (clockEnd < struct.id.clock + struct.length) {\n            findIndexCleanStart(transaction, structs, clockEnd);\n        }\n        f(struct);\n    }while (index < structs.length && structs[index].id.clock < clockEnd);\n};\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */ class Transaction {\n    /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */ constructor(doc, origin, local){\n        /**\n     * The Yjs instance.\n     * @type {Doc}\n     */ this.doc = doc;\n        /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */ this.deleteSet = new DeleteSet();\n        /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */ this.beforeState = getStateVector(doc.store);\n        /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */ this.afterState = new Map();\n        /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}\n     */ this.changed = new Map();\n        /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}\n     */ this.changedParentTypes = new Map();\n        /**\n     * @type {Array<AbstractStruct>}\n     */ this._mergeStructs = [];\n        /**\n     * @type {any}\n     */ this.origin = origin;\n        /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */ this.meta = new Map();\n        /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */ this.local = local;\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocsAdded = new Set();\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocsRemoved = new Set();\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocsLoaded = new Set();\n        /**\n     * @type {boolean}\n     */ this._needFormattingCleanup = false;\n    }\n}\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */ const writeUpdateMessageFromTransaction = (encoder, transaction)=>{\n    if (transaction.deleteSet.clients.size === 0 && !lib0_map__WEBPACK_IMPORTED_MODULE_3__.any(transaction.afterState, (clock, client)=>transaction.beforeState.get(client) !== clock)) {\n        return false;\n    }\n    sortAndMergeDeleteSet(transaction.deleteSet);\n    writeStructsFromTransaction(encoder, transaction);\n    writeDeleteSet(encoder, transaction.deleteSet);\n    return true;\n};\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent<any>>} type\n * @param {string|null} parentSub\n */ const addChangedTypeToTransaction = (transaction, type, parentSub)=>{\n    const item = type._item;\n    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {\n        lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.changed, type, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create).add(parentSub);\n    }\n};\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n * @return {number} # of merged structs\n */ const tryToMergeWithLefts = (structs, pos)=>{\n    let right = structs[pos];\n    let left = structs[pos - 1];\n    let i = pos;\n    for(; i > 0; right = left, left = structs[--i - 1]){\n        if (left.deleted === right.deleted && left.constructor === right.constructor) {\n            if (left.mergeWith(right)) {\n                if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ right.parent._map.get(right.parentSub) === right) {\n                    /** @type {AbstractType<any>} */ right.parent._map.set(right.parentSub, /** @type {Item} */ left);\n                }\n                continue;\n            }\n        }\n        break;\n    }\n    const merged = pos - i;\n    if (merged) {\n        // remove all merged structs from the array\n        structs.splice(pos + 1 - merged, merged);\n    }\n    return merged;\n};\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */ const tryGcDeleteSet = (ds, store, gcFilter)=>{\n    for (const [client, deleteItems] of ds.clients.entries()){\n        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n        for(let di = deleteItems.length - 1; di >= 0; di--){\n            const deleteItem = deleteItems[di];\n            const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n            for(let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]){\n                const struct = structs[si];\n                if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n                    break;\n                }\n                if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n                    struct.gc(store, false);\n                }\n            }\n        }\n    }\n};\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */ const tryMergeDeleteSet = (ds, store)=>{\n    // try to merge deleted / gc'd items\n    // merge from right to left for better efficiecy and so we don't miss any merge targets\n    ds.clients.forEach((deleteItems, client)=>{\n        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n        for(let di = deleteItems.length - 1; di >= 0; di--){\n            const deleteItem = deleteItems[di];\n            // start with merging the item next to the last deleted item\n            const mostRightIndexToCheck = lib0_math__WEBPACK_IMPORTED_MODULE_1__.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n            for(let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]){\n                si -= 1 + tryToMergeWithLefts(structs, si);\n            }\n        }\n    });\n};\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */ const tryGc = (ds, store, gcFilter)=>{\n    tryGcDeleteSet(ds, store, gcFilter);\n    tryMergeDeleteSet(ds, store);\n};\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */ const cleanupTransactions = (transactionCleanups, i)=>{\n    if (i < transactionCleanups.length) {\n        const transaction = transactionCleanups[i];\n        const doc = transaction.doc;\n        const store = doc.store;\n        const ds = transaction.deleteSet;\n        const mergeStructs = transaction._mergeStructs;\n        try {\n            sortAndMergeDeleteSet(ds);\n            transaction.afterState = getStateVector(transaction.doc.store);\n            doc.emit(\"beforeObserverCalls\", [\n                transaction,\n                doc\n            ]);\n            /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */ const fs = [];\n            // observe events on changed types\n            transaction.changed.forEach((subs, itemtype)=>fs.push(()=>{\n                    if (itemtype._item === null || !itemtype._item.deleted) {\n                        itemtype._callObserver(transaction, subs);\n                    }\n                }));\n            fs.push(()=>{\n                // deep observe events\n                transaction.changedParentTypes.forEach((events, type)=>{\n                    // We need to think about the possibility that the user transforms the\n                    // Y.Doc in the event.\n                    if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n                        events = events.filter((event)=>event.target._item === null || !event.target._item.deleted);\n                        events.forEach((event)=>{\n                            event.currentTarget = type;\n                            // path is relative to the current target\n                            event._path = null;\n                        });\n                        // sort events by path length so that top-level events are fired first.\n                        events.sort((event1, event2)=>event1.path.length - event2.path.length);\n                        // We don't need to check for events.length\n                        // because we know it has at least one element\n                        callEventHandlerListeners(type._dEH, events, transaction);\n                    }\n                });\n            });\n            fs.push(()=>doc.emit(\"afterTransaction\", [\n                    transaction,\n                    doc\n                ]));\n            (0,lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll)(fs, []);\n            if (transaction._needFormattingCleanup) {\n                cleanupYTextAfterTransaction(transaction);\n            }\n        } finally{\n            // Replace deleted items with ItemDeleted / GC.\n            // This is where content is actually remove from the Yjs Doc.\n            if (doc.gc) {\n                tryGcDeleteSet(ds, store, doc.gcFilter);\n            }\n            tryMergeDeleteSet(ds, store);\n            // on all affected store.clients props, try to merge\n            transaction.afterState.forEach((clock, client)=>{\n                const beforeClock = transaction.beforeState.get(client) || 0;\n                if (beforeClock !== clock) {\n                    const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n                    // we iterate from right to left so we can safely remove entries\n                    const firstChangePos = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(findIndexSS(structs, beforeClock), 1);\n                    for(let i = structs.length - 1; i >= firstChangePos;){\n                        i -= 1 + tryToMergeWithLefts(structs, i);\n                    }\n                }\n            });\n            // try to merge mergeStructs\n            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n            //        but at the moment DS does not handle duplicates\n            for(let i = mergeStructs.length - 1; i >= 0; i--){\n                const { client, clock } = mergeStructs[i].id;\n                const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n                const replacedStructPos = findIndexSS(structs, clock);\n                if (replacedStructPos + 1 < structs.length) {\n                    if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n                        continue; // no need to perform next check, both are already merged\n                    }\n                }\n                if (replacedStructPos > 0) {\n                    tryToMergeWithLefts(structs, replacedStructPos);\n                }\n            }\n            if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n                lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(lib0_logging__WEBPACK_IMPORTED_MODULE_14__.ORANGE, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.BOLD, \"[yjs] \", lib0_logging__WEBPACK_IMPORTED_MODULE_14__.UNBOLD, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.RED, \"Changed the client-id because another client seems to be using it.\");\n                doc.clientID = generateNewClientId();\n            }\n            // @todo Merge all the transactions into one and provide send the data as a single update message\n            doc.emit(\"afterTransactionCleanup\", [\n                transaction,\n                doc\n            ]);\n            if (doc._observers.has(\"update\")) {\n                const encoder = new UpdateEncoderV1();\n                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n                if (hasContent) {\n                    doc.emit(\"update\", [\n                        encoder.toUint8Array(),\n                        transaction.origin,\n                        doc,\n                        transaction\n                    ]);\n                }\n            }\n            if (doc._observers.has(\"updateV2\")) {\n                const encoder = new UpdateEncoderV2();\n                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n                if (hasContent) {\n                    doc.emit(\"updateV2\", [\n                        encoder.toUint8Array(),\n                        transaction.origin,\n                        doc,\n                        transaction\n                    ]);\n                }\n            }\n            const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n                subdocsAdded.forEach((subdoc)=>{\n                    subdoc.clientID = doc.clientID;\n                    if (subdoc.collectionid == null) {\n                        subdoc.collectionid = doc.collectionid;\n                    }\n                    doc.subdocs.add(subdoc);\n                });\n                subdocsRemoved.forEach((subdoc)=>doc.subdocs.delete(subdoc));\n                doc.emit(\"subdocs\", [\n                    {\n                        loaded: subdocsLoaded,\n                        added: subdocsAdded,\n                        removed: subdocsRemoved\n                    },\n                    doc,\n                    transaction\n                ]);\n                subdocsRemoved.forEach((subdoc)=>subdoc.destroy());\n            }\n            if (transactionCleanups.length <= i + 1) {\n                doc._transactionCleanups = [];\n                doc.emit(\"afterAllTransactions\", [\n                    doc,\n                    transactionCleanups\n                ]);\n            } else {\n                cleanupTransactions(transactionCleanups, i + 1);\n            }\n        }\n    }\n};\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @template T\n * @param {Doc} doc\n * @param {function(Transaction):T} f\n * @param {any} [origin=true]\n * @return {T}\n *\n * @function\n */ const transact = (doc, f, origin = null, local = true)=>{\n    const transactionCleanups = doc._transactionCleanups;\n    let initialCall = false;\n    /**\n   * @type {any}\n   */ let result = null;\n    if (doc._transaction === null) {\n        initialCall = true;\n        doc._transaction = new Transaction(doc, origin, local);\n        transactionCleanups.push(doc._transaction);\n        if (transactionCleanups.length === 1) {\n            doc.emit(\"beforeAllTransactions\", [\n                doc\n            ]);\n        }\n        doc.emit(\"beforeTransaction\", [\n            doc._transaction,\n            doc\n        ]);\n    }\n    try {\n        result = f(doc._transaction);\n    } finally{\n        if (initialCall) {\n            const finishCleanup = doc._transaction === transactionCleanups[0];\n            doc._transaction = null;\n            if (finishCleanup) {\n                // The first transaction ended, now process observer calls.\n                // Observer call may create new transactions for which we need to call the observers and do cleanup.\n                // We don't want to nest these calls, so we execute these calls one after\n                // another.\n                // Also we need to ensure that all cleanups are called, even if the\n                // observes throw errors.\n                // This file is full of hacky try {} finally {} blocks to ensure that an\n                // event can throw errors and also that the cleanup is called.\n                cleanupTransactions(transactionCleanups, 0);\n            }\n        }\n    }\n    return result;\n};\nclass StackItem {\n    /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */ constructor(deletions, insertions){\n        this.insertions = insertions;\n        this.deletions = deletions;\n        /**\n     * Use this to save and restore metadata like selection range\n     */ this.meta = new Map();\n    }\n}\n/**\n * @param {Transaction} tr\n * @param {UndoManager} um\n * @param {StackItem} stackItem\n */ const clearUndoManagerStackItem = (tr, um, stackItem)=>{\n    iterateDeletedStructs(tr, stackItem.deletions, (item)=>{\n        if (item instanceof Item && um.scope.some((type)=>isParentOf(type, item))) {\n            keepItem(item, false);\n        }\n    });\n};\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */ const popStackItem = (undoManager, stack, eventType)=>{\n    /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */ let result = null;\n    /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */ let _tr = null;\n    const doc = undoManager.doc;\n    const scope = undoManager.scope;\n    transact(doc, (transaction)=>{\n        while(stack.length > 0 && result === null){\n            const store = doc.store;\n            const stackItem = /** @type {StackItem} */ stack.pop();\n            /**\n       * @type {Set<Item>}\n       */ const itemsToRedo = new Set();\n            /**\n       * @type {Array<Item>}\n       */ const itemsToDelete = [];\n            let performedChange = false;\n            iterateDeletedStructs(transaction, stackItem.insertions, (struct)=>{\n                if (struct instanceof Item) {\n                    if (struct.redone !== null) {\n                        let { item, diff } = followRedone(store, struct.id);\n                        if (diff > 0) {\n                            item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n                        }\n                        struct = item;\n                    }\n                    if (!struct.deleted && scope.some((type)=>isParentOf(type, /** @type {Item} */ struct))) {\n                        itemsToDelete.push(struct);\n                    }\n                }\n            });\n            iterateDeletedStructs(transaction, stackItem.deletions, (struct)=>{\n                if (struct instanceof Item && scope.some((type)=>isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n                !isDeleted(stackItem.insertions, struct.id)) {\n                    itemsToRedo.add(struct);\n                }\n            });\n            itemsToRedo.forEach((struct)=>{\n                performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n            });\n            // We want to delete in reverse order so that children are deleted before\n            // parents, so we have more information available when items are filtered.\n            for(let i = itemsToDelete.length - 1; i >= 0; i--){\n                const item = itemsToDelete[i];\n                if (undoManager.deleteFilter(item)) {\n                    item.delete(transaction);\n                    performedChange = true;\n                }\n            }\n            result = performedChange ? stackItem : null;\n        }\n        transaction.changed.forEach((subProps, type)=>{\n            // destroy search marker if necessary\n            if (subProps.has(null) && type._searchMarker) {\n                type._searchMarker.length = 0;\n            }\n        });\n        _tr = transaction;\n    }, undoManager);\n    if (result != null) {\n        const changedParentTypes = _tr.changedParentTypes;\n        undoManager.emit(\"stack-item-popped\", [\n            {\n                stackItem: result,\n                type: eventType,\n                changedParentTypes\n            },\n            undoManager\n        ]);\n    }\n    return result;\n};\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter what an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).\n * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.\n */ /**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'|'stack-cleared'|'stack-item-updated'>}\n */ class UndoManager extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n    /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */ constructor(typeScope, { captureTimeout = 500, captureTransaction = (_tr)=>true, deleteFilter = ()=>true, trackedOrigins = new Set([\n        null\n    ]), ignoreRemoteMapChanges = false, doc = /** @type {Doc} */ lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(typeScope) ? typeScope[0].doc : typeScope.doc } = {}){\n        super();\n        /**\n     * @type {Array<AbstractType<any>>}\n     */ this.scope = [];\n        this.doc = doc;\n        this.addToScope(typeScope);\n        this.deleteFilter = deleteFilter;\n        trackedOrigins.add(this);\n        this.trackedOrigins = trackedOrigins;\n        this.captureTransaction = captureTransaction;\n        /**\n     * @type {Array<StackItem>}\n     */ this.undoStack = [];\n        /**\n     * @type {Array<StackItem>}\n     */ this.redoStack = [];\n        /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */ this.undoing = false;\n        this.redoing = false;\n        this.lastChange = 0;\n        this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n        this.captureTimeout = captureTimeout;\n        /**\n     * @param {Transaction} transaction\n     */ this.afterTransactionHandler = (transaction)=>{\n            // Only track certain transactions\n            if (!this.captureTransaction(transaction) || !this.scope.some((type)=>transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {\n                return;\n            }\n            const undoing = this.undoing;\n            const redoing = this.redoing;\n            const stack = undoing ? this.redoStack : this.undoStack;\n            if (undoing) {\n                this.stopCapturing(); // next undo should not be appended to last stack item\n            } else if (!redoing) {\n                // neither undoing nor redoing: delete redoStack\n                this.clear(false, true);\n            }\n            const insertions = new DeleteSet();\n            transaction.afterState.forEach((endClock, client)=>{\n                const startClock = transaction.beforeState.get(client) || 0;\n                const len = endClock - startClock;\n                if (len > 0) {\n                    addToDeleteSet(insertions, client, startClock, len);\n                }\n            });\n            const now = lib0_time__WEBPACK_IMPORTED_MODULE_15__.getUnixTime();\n            let didAdd = false;\n            if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n                // append change to last stack op\n                const lastOp = stack[stack.length - 1];\n                lastOp.deletions = mergeDeleteSets([\n                    lastOp.deletions,\n                    transaction.deleteSet\n                ]);\n                lastOp.insertions = mergeDeleteSets([\n                    lastOp.insertions,\n                    insertions\n                ]);\n            } else {\n                // create a new stack op\n                stack.push(new StackItem(transaction.deleteSet, insertions));\n                didAdd = true;\n            }\n            if (!undoing && !redoing) {\n                this.lastChange = now;\n            }\n            // make sure that deleted structs are not gc'd\n            iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ (item)=>{\n                if (item instanceof Item && this.scope.some((type)=>isParentOf(type, item))) {\n                    keepItem(item, true);\n                }\n            });\n            const changeEvent = [\n                {\n                    stackItem: stack[stack.length - 1],\n                    origin: transaction.origin,\n                    type: undoing ? \"redo\" : \"undo\",\n                    changedParentTypes: transaction.changedParentTypes\n                },\n                this\n            ];\n            if (didAdd) {\n                this.emit(\"stack-item-added\", changeEvent);\n            } else {\n                this.emit(\"stack-item-updated\", changeEvent);\n            }\n        };\n        this.doc.on(\"afterTransaction\", this.afterTransactionHandler);\n        this.doc.on(\"destroy\", ()=>{\n            this.destroy();\n        });\n    }\n    /**\n   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes\n   */ addToScope(ytypes) {\n        ytypes = lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(ytypes) ? ytypes : [\n            ytypes\n        ];\n        ytypes.forEach((ytype)=>{\n            if (this.scope.every((yt)=>yt !== ytype)) {\n                if (ytype.doc !== this.doc) lib0_logging__WEBPACK_IMPORTED_MODULE_13__.warn(\"[yjs#509] Not same Y.Doc\"); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509\n                this.scope.push(ytype);\n            }\n        });\n    }\n    /**\n   * @param {any} origin\n   */ addTrackedOrigin(origin) {\n        this.trackedOrigins.add(origin);\n    }\n    /**\n   * @param {any} origin\n   */ removeTrackedOrigin(origin) {\n        this.trackedOrigins.delete(origin);\n    }\n    clear(clearUndoStack = true, clearRedoStack = true) {\n        if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {\n            this.doc.transact((tr)=>{\n                if (clearUndoStack) {\n                    this.undoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));\n                    this.undoStack = [];\n                }\n                if (clearRedoStack) {\n                    this.redoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));\n                    this.redoStack = [];\n                }\n                this.emit(\"stack-cleared\", [\n                    {\n                        undoStackCleared: clearUndoStack,\n                        redoStackCleared: clearRedoStack\n                    }\n                ]);\n            });\n        }\n    }\n    /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */ stopCapturing() {\n        this.lastChange = 0;\n    }\n    /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */ undo() {\n        this.undoing = true;\n        let res;\n        try {\n            res = popStackItem(this, this.undoStack, \"undo\");\n        } finally{\n            this.undoing = false;\n        }\n        return res;\n    }\n    /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */ redo() {\n        this.redoing = true;\n        let res;\n        try {\n            res = popStackItem(this, this.redoStack, \"redo\");\n        } finally{\n            this.redoing = false;\n        }\n        return res;\n    }\n    /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */ canUndo() {\n        return this.undoStack.length > 0;\n    }\n    /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */ canRedo() {\n        return this.redoStack.length > 0;\n    }\n    destroy() {\n        this.trackedOrigins.delete(this);\n        this.doc.off(\"afterTransaction\", this.afterTransactionHandler);\n        super.destroy();\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */ function* lazyStructReaderGenerator(decoder) {\n    const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numOfStateUpdates; i++){\n        const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const client = decoder.readClient();\n        let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        for(let i = 0; i < numberOfStructs; i++){\n            const info = decoder.readInfo();\n            // @todo use switch instead of ifs\n            if (info === 10) {\n                const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n                yield new Skip(createID(client, clock), len);\n                clock += len;\n            } else if ((lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) !== 0) {\n                const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n                // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n                // and we read the next string as parentYKey.\n                // It indicates how we store/retrieve parent from `y.share`\n                // @type {string|null}\n                const struct = new Item(createID(client, clock), null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, // @ts-ignore Force writing a string here.\n                cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content\n                );\n                yield struct;\n                clock += struct.length;\n            } else {\n                const len = decoder.readLen();\n                yield new GC(createID(client, clock), len);\n                clock += len;\n            }\n        }\n    }\n}\nclass LazyStructReader {\n    /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */ constructor(decoder, filterSkips){\n        this.gen = lazyStructReaderGenerator(decoder);\n        /**\n     * @type {null | Item | Skip | GC}\n     */ this.curr = null;\n        this.done = false;\n        this.filterSkips = filterSkips;\n        this.next();\n    }\n    /**\n   * @return {Item | GC | Skip |null}\n   */ next() {\n        // ignore \"Skip\" structs\n        do {\n            this.curr = this.gen.next().value || null;\n        }while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);\n        return this.curr;\n    }\n}\n/**\n * @param {Uint8Array} update\n *\n */ const logUpdate = (update)=>logUpdateV2(update, UpdateDecoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */ const logUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{\n    const structs = [];\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        structs.push(curr);\n    }\n    lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(\"Structs: \", structs);\n    const ds = readDeleteSet(updateDecoder);\n    lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(\"DeleteSet: \", ds);\n};\n/**\n * @param {Uint8Array} update\n *\n */ const decodeUpdate = (update)=>decodeUpdateV2(update, UpdateDecoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */ const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{\n    const structs = [];\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        structs.push(curr);\n    }\n    return {\n        structs,\n        ds: readDeleteSet(updateDecoder)\n    };\n};\nclass LazyStructWriter {\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ constructor(encoder){\n        this.currClient = 0;\n        this.startClock = 0;\n        this.written = 0;\n        this.encoder = encoder;\n        /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */ this.clientStructs = [];\n    }\n}\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */ const mergeUpdates = (updates)=>mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */ const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2)=>{\n    const encoder = new YEncoder();\n    const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n    let curr = updateDecoder.curr;\n    if (curr !== null) {\n        let size = 0;\n        let currClient = curr.id.client;\n        let stopCounting = curr.id.clock !== 0; // must start at 0\n        let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n        for(; curr !== null; curr = updateDecoder.next()){\n            if (currClient !== curr.id.client) {\n                if (currClock !== 0) {\n                    size++;\n                    // We found a new client\n                    // write what we have to the encoder\n                    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n                    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n                }\n                currClient = curr.id.client;\n                currClock = 0;\n                stopCounting = curr.id.clock !== 0;\n            }\n            // we ignore skips\n            if (curr.constructor === Skip) {\n                stopCounting = true;\n            }\n            if (!stopCounting) {\n                currClock = curr.id.clock + curr.length;\n            }\n        }\n        // write what we have\n        if (currClock !== 0) {\n            size++;\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n        }\n        // prepend the size of the state vector\n        const enc = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(enc, size);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder(enc, encoder.restEncoder);\n        encoder.restEncoder = enc;\n        return encoder.toUint8Array();\n    } else {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n        return encoder.toUint8Array();\n    }\n};\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */ const encodeStateVectorFromUpdate = (update)=>encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */ const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2)=>{\n    /**\n   * @type {Map<number, number>}\n   */ const from = new Map();\n    /**\n   * @type {Map<number, number>}\n   */ const to = new Map();\n    const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n    let curr = updateDecoder.curr;\n    if (curr !== null) {\n        let currClient = curr.id.client;\n        let currClock = curr.id.clock;\n        // write the beginning to `from`\n        from.set(currClient, currClock);\n        for(; curr !== null; curr = updateDecoder.next()){\n            if (currClient !== curr.id.client) {\n                // We found a new client\n                // write the end to `to`\n                to.set(currClient, currClock);\n                // write the beginning to `from`\n                from.set(curr.id.client, curr.id.clock);\n                // update currClient\n                currClient = curr.id.client;\n            }\n            currClock = curr.id.clock + curr.length;\n        }\n        // write the end to `to`\n        to.set(currClient, currClock);\n    }\n    return {\n        from,\n        to\n    };\n};\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */ const parseUpdateMeta = (update)=>parseUpdateMetaV2(update, UpdateDecoderV1);\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */ const sliceStruct = (left, diff)=>{\n    if (left.constructor === GC) {\n        const { client, clock } = left.id;\n        return new GC(createID(client, clock + diff), left.length - diff);\n    } else if (left.constructor === Skip) {\n        const { client, clock } = left.id;\n        return new Skip(createID(client, clock + diff), left.length - diff);\n    } else {\n        const leftItem = /** @type {Item} */ left;\n        const { client, clock } = leftItem.id;\n        return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));\n    }\n};\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */ const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{\n    if (updates.length === 1) {\n        return updates[0];\n    }\n    const updateDecoders = updates.map((update)=>new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)));\n    let lazyStructDecoders = updateDecoders.map((decoder)=>new LazyStructReader(decoder, true));\n    /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */ let currWrite = null;\n    const updateEncoder = new YEncoder();\n    // write structs lazily\n    const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n    // Note: We need to ensure that all lazyStructDecoders are fully consumed\n    // Note: Should merge document updates whenever possible - even from different updates\n    // Note: Should handle that some operations cannot be applied yet ()\n    while(true){\n        // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content\n        lazyStructDecoders = lazyStructDecoders.filter((dec)=>dec.curr !== null);\n        lazyStructDecoders.sort(/** @type {function(any,any):number} */ (dec1, dec2)=>{\n            if (dec1.curr.id.client === dec2.curr.id.client) {\n                const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n                if (clockDiff === 0) {\n                    // @todo remove references to skip since the structDecoders must filter Skips.\n                    return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.\n                    ;\n                } else {\n                    return clockDiff;\n                }\n            } else {\n                return dec2.curr.id.client - dec1.curr.id.client;\n            }\n        });\n        if (lazyStructDecoders.length === 0) {\n            break;\n        }\n        const currDecoder = lazyStructDecoders[0];\n        // write from currDecoder until the next operation is from another client or if filler-struct\n        // then we need to reorder the decoders and find the next operation to write\n        const firstClient = /** @type {Item | GC} */ currDecoder.curr.id.client;\n        if (currWrite !== null) {\n            let curr = /** @type {Item | GC | null} */ currDecoder.curr;\n            let iterated = false;\n            // iterate until we find something that we haven't written already\n            // remember: first the high client-ids are written\n            while(curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client){\n                curr = currDecoder.next();\n                iterated = true;\n            }\n            if (curr === null || // current decoder is empty\n            curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n            iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates\n            ) {\n                continue;\n            }\n            if (firstClient !== currWrite.struct.id.client) {\n                writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n                currWrite = {\n                    struct: curr,\n                    offset: 0\n                };\n                currDecoder.next();\n            } else {\n                if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n                    // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n                    if (currWrite.struct.constructor === Skip) {\n                        // extend existing skip\n                        currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n                    } else {\n                        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n                        const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n                        /**\n             * @type {Skip}\n             */ const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n                        currWrite = {\n                            struct,\n                            offset: 0\n                        };\n                    }\n                } else {\n                    const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n                    if (diff > 0) {\n                        if (currWrite.struct.constructor === Skip) {\n                            // prefer to slice Skip because the other struct might contain more information\n                            currWrite.struct.length -= diff;\n                        } else {\n                            curr = sliceStruct(curr, diff);\n                        }\n                    }\n                    if (!currWrite.struct.mergeWith(/** @type {any} */ curr)) {\n                        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n                        currWrite = {\n                            struct: curr,\n                            offset: 0\n                        };\n                        currDecoder.next();\n                    }\n                }\n            }\n        } else {\n            currWrite = {\n                struct: /** @type {Item | GC} */ currDecoder.curr,\n                offset: 0\n            };\n            currDecoder.next();\n        }\n        for(let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()){\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = {\n                struct: next,\n                offset: 0\n            };\n        }\n    }\n    if (currWrite !== null) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = null;\n    }\n    finishLazyStructWriting(lazyStructEncoder);\n    const dss = updateDecoders.map((decoder)=>readDeleteSet(decoder));\n    const ds = mergeDeleteSets(dss);\n    writeDeleteSet(updateEncoder, ds);\n    return updateEncoder.toUint8Array();\n};\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */ const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{\n    const state = decodeStateVector(sv);\n    const encoder = new YEncoder();\n    const lazyStructWriter = new LazyStructWriter(encoder);\n    const decoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const reader = new LazyStructReader(decoder, false);\n    while(reader.curr){\n        const curr = reader.curr;\n        const currClient = curr.id.client;\n        const svClock = state.get(currClient) || 0;\n        if (reader.curr.constructor === Skip) {\n            // the first written struct shouldn't be a skip\n            reader.next();\n            continue;\n        }\n        if (curr.id.clock + curr.length > svClock) {\n            writeStructToLazyStructWriter(lazyStructWriter, curr, lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(svClock - curr.id.clock, 0));\n            reader.next();\n            while(reader.curr && reader.curr.id.client === currClient){\n                writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n                reader.next();\n            }\n        } else {\n            // read until something new comes up\n            while(reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock){\n                reader.next();\n            }\n        }\n    }\n    finishLazyStructWriting(lazyStructWriter);\n    // write ds\n    const ds = readDeleteSet(decoder);\n    writeDeleteSet(encoder, ds);\n    return encoder.toUint8Array();\n};\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */ const diffUpdate = (update, sv)=>diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n/**\n * @param {LazyStructWriter} lazyWriter\n */ const flushLazyStructWriter = (lazyWriter)=>{\n    if (lazyWriter.written > 0) {\n        lazyWriter.clientStructs.push({\n            written: lazyWriter.written,\n            restEncoder: lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(lazyWriter.encoder.restEncoder)\n        });\n        lazyWriter.encoder.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n        lazyWriter.written = 0;\n    }\n};\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */ const writeStructToLazyStructWriter = (lazyWriter, struct, offset)=>{\n    // flush curr if we start another client\n    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n        flushLazyStructWriter(lazyWriter);\n    }\n    if (lazyWriter.written === 0) {\n        lazyWriter.currClient = struct.id.client;\n        // write next client\n        lazyWriter.encoder.writeClient(struct.id.client);\n        // write startClock\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n    }\n    struct.write(lazyWriter.encoder, offset);\n    lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */ const finishLazyStructWriting = (lazyWriter)=>{\n    flushLazyStructWriter(lazyWriter);\n    // this is a fresh encoder because we called flushCurr\n    const restEncoder = lazyWriter.encoder.restEncoder;\n    /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */ // write # states that were updated - i.e. the clients\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n    for(let i = 0; i < lazyWriter.clientStructs.length; i++){\n        const partStructs = lazyWriter.clientStructs[i];\n        /**\n     * Works similarly to `writeStructs`\n     */ // write # encoded structs\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, partStructs.written);\n        // write the rest of the fragment\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(restEncoder, partStructs.restEncoder);\n    }\n};\n/**\n * @param {Uint8Array} update\n * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder\n * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder\n */ const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder)=>{\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    const updateEncoder = new YEncoder();\n    const lazyWriter = new LazyStructWriter(updateEncoder);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n    }\n    finishLazyStructWriting(lazyWriter);\n    const ds = readDeleteSet(updateDecoder);\n    writeDeleteSet(updateEncoder, ds);\n    return updateEncoder.toUint8Array();\n};\n/**\n * @typedef {Object} ObfuscatorOptions\n * @property {boolean} [ObfuscatorOptions.formatting=true]\n * @property {boolean} [ObfuscatorOptions.subdocs=true]\n * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName\n */ /**\n * @param {ObfuscatorOptions} obfuscator\n */ const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {})=>{\n    let i = 0;\n    const mapKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const nodeNameCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const formattingKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const formattingValueCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range\n    /**\n   * @param {Item|GC|Skip} block\n   * @return {Item|GC|Skip}\n   */ return (block)=>{\n        switch(block.constructor){\n            case GC:\n            case Skip:\n                return block;\n            case Item:\n                {\n                    const item = /** @type {Item} */ block;\n                    const content = item.content;\n                    switch(content.constructor){\n                        case ContentDeleted:\n                            break;\n                        case ContentType:\n                            {\n                                if (yxml) {\n                                    const type = /** @type {ContentType} */ content.type;\n                                    if (type instanceof YXmlElement) {\n                                        type.nodeName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.nodeName, ()=>\"node-\" + i);\n                                    }\n                                    if (type instanceof YXmlHook) {\n                                        type.hookName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.hookName, ()=>\"hook-\" + i);\n                                    }\n                                }\n                                break;\n                            }\n                        case ContentAny:\n                            {\n                                const c = /** @type {ContentAny} */ content;\n                                c.arr = c.arr.map(()=>i);\n                                break;\n                            }\n                        case ContentBinary:\n                            {\n                                const c = /** @type {ContentBinary} */ content;\n                                c.content = new Uint8Array([\n                                    i\n                                ]);\n                                break;\n                            }\n                        case ContentDoc:\n                            {\n                                const c = /** @type {ContentDoc} */ content;\n                                if (subdocs) {\n                                    c.opts = {};\n                                    c.doc.guid = i + \"\";\n                                }\n                                break;\n                            }\n                        case ContentEmbed:\n                            {\n                                const c = /** @type {ContentEmbed} */ content;\n                                c.embed = {};\n                                break;\n                            }\n                        case ContentFormat:\n                            {\n                                const c = /** @type {ContentFormat} */ content;\n                                if (formatting) {\n                                    c.key = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingKeyCache, c.key, ()=>i + \"\");\n                                    c.value = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingValueCache, c.value, ()=>({\n                                            i\n                                        }));\n                                }\n                                break;\n                            }\n                        case ContentJSON:\n                            {\n                                const c = /** @type {ContentJSON} */ content;\n                                c.arr = c.arr.map(()=>i);\n                                break;\n                            }\n                        case ContentString:\n                            {\n                                const c = /** @type {ContentString} */ content;\n                                c.str = lib0_string__WEBPACK_IMPORTED_MODULE_16__.repeat(i % 10 + \"\", c.str.length);\n                                break;\n                            }\n                        default:\n                            // unknown content type\n                            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n                    }\n                    if (item.parentSub) {\n                        item.parentSub = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(mapKeyCache, item.parentSub, ()=>i + \"\");\n                    }\n                    i++;\n                    return block;\n                }\n            default:\n                // unknown block-type\n                lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n    };\n};\n/**\n * This function obfuscates the content of a Yjs update. This is useful to share\n * buggy Yjs documents while significantly limiting the possibility that a\n * developer can on the user. Note that it might still be possible to deduce\n * some information by analyzing the \"structure\" of the document or by analyzing\n * the typing behavior using the CRDT-related metadata that is still kept fully\n * intact.\n *\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */ const obfuscateUpdate = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\n/**\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */ const obfuscateUpdateV2 = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\n/**\n * @param {Uint8Array} update\n */ const convertUpdateFormatV1ToV2 = (update)=>convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV1, UpdateEncoderV2);\n/**\n * @param {Uint8Array} update\n */ const convertUpdateFormatV2ToV1 = (update)=>convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV2, UpdateEncoderV1);\nconst errorComputeChanges = \"You must not compute changes after the event-handler fired.\";\n/**\n * @template {AbstractType<any>} T\n * YEvent describes the changes on a YType.\n */ class YEvent {\n    /**\n   * @param {T} target The changed type.\n   * @param {Transaction} transaction\n   */ constructor(target, transaction){\n        /**\n     * The type on which this event was created on.\n     * @type {T}\n     */ this.target = target;\n        /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */ this.currentTarget = target;\n        /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */ this.transaction = transaction;\n        /**\n     * @type {Object|null}\n     */ this._changes = null;\n        /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */ this._keys = null;\n        /**\n     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */ this._delta = null;\n        /**\n     * @type {Array<string|number>|null}\n     */ this._path = null;\n    }\n    /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */ get path() {\n        return this._path || (this._path = getPathTo(this.currentTarget, this.target));\n    }\n    /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */ deletes(struct) {\n        return isDeleted(this.transaction.deleteSet, struct.id);\n    }\n    /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */ get keys() {\n        if (this._keys === null) {\n            if (this.transaction.doc._transactionCleanups.length === 0) {\n                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges);\n            }\n            const keys = new Map();\n            const target = this.target;\n            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);\n            changed.forEach((key)=>{\n                if (key !== null) {\n                    const item = /** @type {Item} */ target._map.get(key);\n                    /**\n           * @type {'delete' | 'add' | 'update'}\n           */ let action;\n                    let oldValue;\n                    if (this.adds(item)) {\n                        let prev = item.left;\n                        while(prev !== null && this.adds(prev)){\n                            prev = prev.left;\n                        }\n                        if (this.deletes(item)) {\n                            if (prev !== null && this.deletes(prev)) {\n                                action = \"delete\";\n                                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());\n                            } else {\n                                return;\n                            }\n                        } else {\n                            if (prev !== null && this.deletes(prev)) {\n                                action = \"update\";\n                                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());\n                            } else {\n                                action = \"add\";\n                                oldValue = undefined;\n                            }\n                        }\n                    } else {\n                        if (this.deletes(item)) {\n                            action = \"delete\";\n                            oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(/** @type {Item} */ item.content.getContent());\n                        } else {\n                            return; // nop\n                        }\n                    }\n                    keys.set(key, {\n                        action,\n                        oldValue\n                    });\n                }\n            });\n            this._keys = keys;\n        }\n        return this._keys;\n    }\n    /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */ get delta() {\n        return this.changes.delta;\n    }\n    /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */ adds(struct) {\n        return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);\n    }\n    /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */ get changes() {\n        let changes = this._changes;\n        if (changes === null) {\n            if (this.transaction.doc._transactionCleanups.length === 0) {\n                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges);\n            }\n            const target = this.target;\n            const added = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n            const deleted = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n            /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */ const delta = [];\n            changes = {\n                added,\n                deleted,\n                delta,\n                keys: this.keys\n            };\n            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);\n            if (changed.has(null)) {\n                /**\n         * @type {any}\n         */ let lastOp = null;\n                const packOp = ()=>{\n                    if (lastOp) {\n                        delta.push(lastOp);\n                    }\n                };\n                for(let item = target._start; item !== null; item = item.right){\n                    if (item.deleted) {\n                        if (this.deletes(item) && !this.adds(item)) {\n                            if (lastOp === null || lastOp.delete === undefined) {\n                                packOp();\n                                lastOp = {\n                                    delete: 0\n                                };\n                            }\n                            lastOp.delete += item.length;\n                            deleted.add(item);\n                        } // else nop\n                    } else {\n                        if (this.adds(item)) {\n                            if (lastOp === null || lastOp.insert === undefined) {\n                                packOp();\n                                lastOp = {\n                                    insert: []\n                                };\n                            }\n                            lastOp.insert = lastOp.insert.concat(item.content.getContent());\n                            added.add(item);\n                        } else {\n                            if (lastOp === null || lastOp.retain === undefined) {\n                                packOp();\n                                lastOp = {\n                                    retain: 0\n                                };\n                            }\n                            lastOp.retain += item.length;\n                        }\n                    }\n                }\n                if (lastOp !== null && lastOp.retain === undefined) {\n                    packOp();\n                }\n            }\n            this._changes = changes;\n        }\n        return /** @type {any} */ changes;\n    }\n}\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */ const getPathTo = (parent, child)=>{\n    const path = [];\n    while(child._item !== null && child !== parent){\n        if (child._item.parentSub !== null) {\n            // parent is map-ish\n            path.unshift(child._item.parentSub);\n        } else {\n            // parent is array-ish\n            let i = 0;\n            let c = /** @type {AbstractType<any>} */ child._item.parent._start;\n            while(c !== child._item && c !== null){\n                if (!c.deleted) {\n                    i++;\n                }\n                c = c.right;\n            }\n            path.unshift(i);\n        }\n        child = /** @type {AbstractType<any>} */ child._item.parent;\n    }\n    return path;\n};\nconst maxSearchMarker = 80;\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */ let globalSearchMarkerTimestamp = 0;\nclass ArraySearchMarker {\n    /**\n   * @param {Item} p\n   * @param {number} index\n   */ constructor(p, index){\n        p.marker = true;\n        this.p = p;\n        this.index = index;\n        this.timestamp = globalSearchMarkerTimestamp++;\n    }\n}\n/**\n * @param {ArraySearchMarker} marker\n */ const refreshMarkerTimestamp = (marker)=>{\n    marker.timestamp = globalSearchMarkerTimestamp++;\n};\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */ const overwriteMarker = (marker, p, index)=>{\n    marker.p.marker = false;\n    marker.p = p;\n    p.marker = true;\n    marker.index = index;\n    marker.timestamp = globalSearchMarkerTimestamp++;\n};\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */ const markPosition = (searchMarker, p, index)=>{\n    if (searchMarker.length >= maxSearchMarker) {\n        // override oldest marker (we don't want to create more objects)\n        const marker = searchMarker.reduce((a, b)=>a.timestamp < b.timestamp ? a : b);\n        overwriteMarker(marker, p, index);\n        return marker;\n    } else {\n        // create new marker\n        const pm = new ArraySearchMarker(p, index);\n        searchMarker.push(pm);\n        return pm;\n    }\n};\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */ const findMarker = (yarray, index)=>{\n    if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n        return null;\n    }\n    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b)=>lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - a.index) < lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - b.index) ? a : b);\n    let p = yarray._start;\n    let pindex = 0;\n    if (marker !== null) {\n        p = marker.p;\n        pindex = marker.index;\n        refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n    }\n    // iterate to right if possible\n    while(p.right !== null && pindex < index){\n        if (!p.deleted && p.countable) {\n            if (index < pindex + p.length) {\n                break;\n            }\n            pindex += p.length;\n        }\n        p = p.right;\n    }\n    // iterate to left if necessary (might be that pindex > index)\n    while(p.left !== null && pindex > index){\n        p = p.left;\n        if (!p.deleted && p.countable) {\n            pindex -= p.length;\n        }\n    }\n    // we want to make sure that p can't be merged with left, because that would screw up everything\n    // in that cas just return what we have (it is most likely the best marker anyway)\n    // iterate to left until p can't be merged with left\n    while(p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock){\n        p = p.left;\n        if (!p.deleted && p.countable) {\n            pindex -= p.length;\n        }\n    }\n    // @todo remove!\n    // assure position\n    // {\n    //   let start = yarray._start\n    //   let pos = 0\n    //   while (start !== p) {\n    //     if (!start.deleted && start.countable) {\n    //       pos += start.length\n    //     }\n    //     start = /** @type {Item} */ (start.right)\n    //   }\n    //   if (pos !== pindex) {\n    //     debugger\n    //     throw new Error('Gotcha position fail!')\n    //   }\n    // }\n    // if (marker) {\n    //   if (window.lengthes == null) {\n    //     window.lengthes = []\n    //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n    //   }\n    //   window.lengthes.push(marker.index - pindex)\n    //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n    // }\n    if (marker !== null && lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ p.parent.length / maxSearchMarker) {\n        // adjust existing marker\n        overwriteMarker(marker, p, pindex);\n        return marker;\n    } else {\n        // create new marker\n        return markPosition(yarray._searchMarker, p, pindex);\n    }\n};\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */ const updateMarkerChanges = (searchMarker, index, len)=>{\n    for(let i = searchMarker.length - 1; i >= 0; i--){\n        const m = searchMarker[i];\n        if (len > 0) {\n            /**\n       * @type {Item|null}\n       */ let p = m.p;\n            p.marker = false;\n            // Ideally we just want to do a simple position comparison, but this will only work if\n            // search markers don't point to deleted items for formats.\n            // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n            while(p && (p.deleted || !p.countable)){\n                p = p.left;\n                if (p && !p.deleted && p.countable) {\n                    // adjust position. the loop should break now\n                    m.index -= p.length;\n                }\n            }\n            if (p === null || p.marker === true) {\n                // remove search marker if updated position is null or if position is already marked\n                searchMarker.splice(i, 1);\n                continue;\n            }\n            m.p = p;\n            p.marker = true;\n        }\n        if (index < m.index || len > 0 && index === m.index) {\n            m.index = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(index, m.index + len);\n        }\n    }\n};\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */ const getTypeChildren = (t)=>{\n    let s = t._start;\n    const arr = [];\n    while(s){\n        arr.push(s);\n        s = s.right;\n    }\n    return arr;\n};\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */ const callTypeObservers = (type, transaction, event)=>{\n    const changedType = type;\n    const changedParentTypes = transaction.changedParentTypes;\n    while(true){\n        // @ts-ignore\n        lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(changedParentTypes, type, ()=>[]).push(event);\n        if (type._item === null) {\n            break;\n        }\n        type = /** @type {AbstractType<any>} */ type._item.parent;\n    }\n    callEventHandlerListeners(changedType._eH, event, transaction);\n};\n/**\n * @template EventType\n * Abstract Yjs Type class\n */ class AbstractType {\n    constructor(){\n        /**\n     * @type {Item|null}\n     */ this._item = null;\n        /**\n     * @type {Map<string,Item>}\n     */ this._map = new Map();\n        /**\n     * @type {Item|null}\n     */ this._start = null;\n        /**\n     * @type {Doc|null}\n     */ this.doc = null;\n        this._length = 0;\n        /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */ this._eH = createEventHandler();\n        /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent<any>>,Transaction>}\n     */ this._dEH = createEventHandler();\n        /**\n     * @type {null | Array<ArraySearchMarker>}\n     */ this._searchMarker = null;\n    }\n    /**\n   * @return {AbstractType<any>|null}\n   */ get parent() {\n        return this._item ? /** @type {AbstractType<any>} */ this._item.parent : null;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */ _integrate(y, item) {\n        this.doc = y;\n        this._item = item;\n    }\n    /**\n   * @return {AbstractType<EventType>}\n   */ _copy() {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @return {AbstractType<EventType>}\n   */ clone() {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */ _write(_encoder) {}\n    /**\n   * The first non-deleted item\n   */ get _first() {\n        let n = this._start;\n        while(n !== null && n.deleted){\n            n = n.right;\n        }\n        return n;\n    }\n    /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, _parentSubs) {\n        if (!transaction.local && this._searchMarker) {\n            this._searchMarker.length = 0;\n        }\n    }\n    /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */ observe(f) {\n        addEventHandlerListener(this._eH, f);\n    }\n    /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */ observeDeep(f) {\n        addEventHandlerListener(this._dEH, f);\n    }\n    /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */ unobserve(f) {\n        removeEventHandlerListener(this._eH, f);\n    }\n    /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */ unobserveDeep(f) {\n        removeEventHandlerListener(this._dEH, f);\n    }\n    /**\n   * @abstract\n   * @return {any}\n   */ toJSON() {}\n}\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */ const typeListSlice = (type, start, end)=>{\n    if (start < 0) {\n        start = type._length + start;\n    }\n    if (end < 0) {\n        end = type._length + end;\n    }\n    let len = end - start;\n    const cs = [];\n    let n = type._start;\n    while(n !== null && len > 0){\n        if (n.countable && !n.deleted) {\n            const c = n.content.getContent();\n            if (c.length <= start) {\n                start -= c.length;\n            } else {\n                for(let i = start; i < c.length && len > 0; i++){\n                    cs.push(c[i]);\n                    len--;\n                }\n                start = 0;\n            }\n        }\n        n = n.right;\n    }\n    return cs;\n};\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */ const typeListToArray = (type)=>{\n    const cs = [];\n    let n = type._start;\n    while(n !== null){\n        if (n.countable && !n.deleted) {\n            const c = n.content.getContent();\n            for(let i = 0; i < c.length; i++){\n                cs.push(c[i]);\n            }\n        }\n        n = n.right;\n    }\n    return cs;\n};\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */ const typeListToArraySnapshot = (type, snapshot)=>{\n    const cs = [];\n    let n = type._start;\n    while(n !== null){\n        if (n.countable && isVisible(n, snapshot)) {\n            const c = n.content.getContent();\n            for(let i = 0; i < c.length; i++){\n                cs.push(c[i]);\n            }\n        }\n        n = n.right;\n    }\n    return cs;\n};\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */ const typeListForEach = (type, f)=>{\n    let index = 0;\n    let n = type._start;\n    while(n !== null){\n        if (n.countable && !n.deleted) {\n            const c = n.content.getContent();\n            for(let i = 0; i < c.length; i++){\n                f(c[i], index++, type);\n            }\n        }\n        n = n.right;\n    }\n};\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */ const typeListMap = (type, f)=>{\n    /**\n   * @type {Array<any>}\n   */ const result = [];\n    typeListForEach(type, (c, i)=>{\n        result.push(f(c, i, type));\n    });\n    return result;\n};\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */ const typeListCreateIterator = (type)=>{\n    let n = type._start;\n    /**\n   * @type {Array<any>|null}\n   */ let currentContent = null;\n    let currentContentIndex = 0;\n    return {\n        [Symbol.iterator] () {\n            return this;\n        },\n        next: ()=>{\n            // find some content\n            if (currentContent === null) {\n                while(n !== null && n.deleted){\n                    n = n.right;\n                }\n                // check if we reached the end, no need to check currentContent, because it does not exist\n                if (n === null) {\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n                // we found n, so we can set currentContent\n                currentContent = n.content.getContent();\n                currentContentIndex = 0;\n                n = n.right; // we used the content of n, now iterate to next\n            }\n            const value = currentContent[currentContentIndex++];\n            // check if we need to empty currentContent\n            if (currentContent.length <= currentContentIndex) {\n                currentContent = null;\n            }\n            return {\n                done: false,\n                value\n            };\n        }\n    };\n};\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */ const typeListGet = (type, index)=>{\n    const marker = findMarker(type, index);\n    let n = type._start;\n    if (marker !== null) {\n        n = marker.p;\n        index -= marker.index;\n    }\n    for(; n !== null; n = n.right){\n        if (!n.deleted && n.countable) {\n            if (index < n.length) {\n                return n.content.getContent()[index];\n            }\n            index -= n.length;\n        }\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */ const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content)=>{\n    let left = referenceItem;\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    const store = doc.store;\n    const right = referenceItem === null ? parent._start : referenceItem.right;\n    /**\n   * @type {Array<Object|Array<any>|number|null>}\n   */ let jsonContent = [];\n    const packJsonContent = ()=>{\n        if (jsonContent.length > 0) {\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n            left.integrate(transaction, 0);\n            jsonContent = [];\n        }\n    };\n    content.forEach((c)=>{\n        if (c === null) {\n            jsonContent.push(c);\n        } else {\n            switch(c.constructor){\n                case Number:\n                case Object:\n                case Boolean:\n                case Array:\n                case String:\n                    jsonContent.push(c);\n                    break;\n                default:\n                    packJsonContent();\n                    switch(c.constructor){\n                        case Uint8Array:\n                        case ArrayBuffer:\n                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ c)));\n                            left.integrate(transaction, 0);\n                            break;\n                        case Doc:\n                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ c));\n                            left.integrate(transaction, 0);\n                            break;\n                        default:\n                            if (c instanceof AbstractType) {\n                                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                                left.integrate(transaction, 0);\n                            } else {\n                                throw new Error(\"Unexpected content type in insert operation\");\n                            }\n                    }\n            }\n        }\n    });\n    packJsonContent();\n};\nconst lengthExceeded = ()=>lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(\"Length exceeded!\");\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */ const typeListInsertGenerics = (transaction, parent, index, content)=>{\n    if (index > parent._length) {\n        throw lengthExceeded();\n    }\n    if (index === 0) {\n        if (parent._searchMarker) {\n            updateMarkerChanges(parent._searchMarker, index, content.length);\n        }\n        return typeListInsertGenericsAfter(transaction, parent, null, content);\n    }\n    const startIndex = index;\n    const marker = findMarker(parent, index);\n    let n = parent._start;\n    if (marker !== null) {\n        n = marker.p;\n        index -= marker.index;\n        // we need to iterate one to the left so that the algorithm works\n        if (index === 0) {\n            // @todo refactor this as it actually doesn't consider formats\n            n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n            index += n && n.countable && !n.deleted ? n.length : 0;\n        }\n    }\n    for(; n !== null; n = n.right){\n        if (!n.deleted && n.countable) {\n            if (index <= n.length) {\n                if (index < n.length) {\n                    // insert in-between\n                    getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n                }\n                break;\n            }\n            index -= n.length;\n        }\n    }\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\n/**\n * Pushing content is special as we generally want to push after the last item. So we don't have to update\n * the serach marker.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */ const typeListPushGenerics = (transaction, parent, content)=>{\n    // Use the marker with the highest index and iterate to the right.\n    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker)=>currMarker.index > maxMarker.index ? currMarker : maxMarker, {\n        index: 0,\n        p: parent._start\n    });\n    let n = marker.p;\n    if (n) {\n        while(n.right){\n            n = n.right;\n        }\n    }\n    return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */ const typeListDelete = (transaction, parent, index, length)=>{\n    if (length === 0) {\n        return;\n    }\n    const startIndex = index;\n    const startLength = length;\n    const marker = findMarker(parent, index);\n    let n = parent._start;\n    if (marker !== null) {\n        n = marker.p;\n        index -= marker.index;\n    }\n    // compute the first item to be deleted\n    for(; n !== null && index > 0; n = n.right){\n        if (!n.deleted && n.countable) {\n            if (index < n.length) {\n                getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n            }\n            index -= n.length;\n        }\n    }\n    // delete all items until done\n    while(length > 0 && n !== null){\n        if (!n.deleted) {\n            if (length < n.length) {\n                getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n            }\n            n.delete(transaction);\n            length -= n.length;\n        }\n        n = n.right;\n    }\n    if (length > 0) {\n        throw lengthExceeded();\n    }\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */ );\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */ const typeMapDelete = (transaction, parent, key)=>{\n    const c = parent._map.get(key);\n    if (c !== undefined) {\n        c.delete(transaction);\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */ const typeMapSet = (transaction, parent, key, value)=>{\n    const left = parent._map.get(key) || null;\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    let content;\n    if (value == null) {\n        content = new ContentAny([\n            value\n        ]);\n    } else {\n        switch(value.constructor){\n            case Number:\n            case Object:\n            case Boolean:\n            case Array:\n            case String:\n                content = new ContentAny([\n                    value\n                ]);\n                break;\n            case Uint8Array:\n                content = new ContentBinary(/** @type {Uint8Array} */ value);\n                break;\n            case Doc:\n                content = new ContentDoc(/** @type {Doc} */ value);\n                break;\n            default:\n                if (value instanceof AbstractType) {\n                    content = new ContentType(value);\n                } else {\n                    throw new Error(\"Unexpected content type\");\n                }\n        }\n    }\n    new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */ const typeMapGet = (parent, key)=>{\n    const val = parent._map.get(key);\n    return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;\n};\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */ const typeMapGetAll = (parent)=>{\n    /**\n   * @type {Object<string,any>}\n   */ const res = {};\n    parent._map.forEach((value, key)=>{\n        if (!value.deleted) {\n            res[key] = value.content.getContent()[value.length - 1];\n        }\n    });\n    return res;\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */ const typeMapHas = (parent, key)=>{\n    const val = parent._map.get(key);\n    return val !== undefined && !val.deleted;\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */ const typeMapGetSnapshot = (parent, key, snapshot)=>{\n    let v = parent._map.get(key) || null;\n    while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))){\n        v = v.left;\n    }\n    return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {Snapshot} snapshot\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */ const typeMapGetAllSnapshot = (parent, snapshot)=>{\n    /**\n   * @type {Object<string,any>}\n   */ const res = {};\n    parent._map.forEach((value, key)=>{\n        /**\n     * @type {Item|null}\n     */ let v = value;\n        while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))){\n            v = v.left;\n        }\n        if (v !== null && isVisible(v, snapshot)) {\n            res[key] = v.content.getContent()[v.length - 1];\n        }\n    });\n    return res;\n};\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */ const createMapIterator = (map)=>lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorFilter(map.entries(), /** @param {any} entry */ (entry)=>!entry[1].deleted);\n/**\n * @module YArray\n */ /**\n * Event that describes the changes on a YArray\n * @template T\n * @extends YEvent<YArray<T>>\n */ class YArrayEvent extends YEvent {\n    /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */ constructor(yarray, transaction){\n        super(yarray, transaction);\n        this._transaction = transaction;\n    }\n}\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */ class YArray extends AbstractType {\n    constructor(){\n        super();\n        /**\n     * @type {Array<any>?}\n     * @private\n     */ this._prelimContent = [];\n        /**\n     * @type {Array<ArraySearchMarker>}\n     */ this._searchMarker = [];\n    }\n    /**\n   * Construct a new YArray containing the specified items.\n   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */ static from(items) {\n        /**\n     * @type {YArray<T>}\n     */ const a = new YArray();\n        a.push(items);\n        return a;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        this.insert(0, /** @type {Array<any>} */ this._prelimContent);\n        this._prelimContent = null;\n    }\n    /**\n   * @return {YArray<T>}\n   */ _copy() {\n        return new YArray();\n    }\n    /**\n   * @return {YArray<T>}\n   */ clone() {\n        /**\n     * @type {YArray<T>}\n     */ const arr = new YArray();\n        arr.insert(0, this.toArray().map((el)=>el instanceof AbstractType ? /** @type {typeof el} */ el.clone() : el));\n        return arr;\n    }\n    get length() {\n        return this._prelimContent === null ? this._length : this._prelimContent.length;\n    }\n    /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        super._callObserver(transaction, parentSubs);\n        callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n    }\n    /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */ insert(index, content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListInsertGenerics(transaction, this, index, /** @type {any} */ content);\n            });\n        } else {\n            /** @type {Array<any>} */ this._prelimContent.splice(index, 0, ...content);\n        }\n    }\n    /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */ push(content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListPushGenerics(transaction, this, /** @type {any} */ content);\n            });\n        } else {\n            /** @type {Array<any>} */ this._prelimContent.push(...content);\n        }\n    }\n    /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */ unshift(content) {\n        this.insert(0, content);\n    }\n    /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */ delete(index, length = 1) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListDelete(transaction, this, index, length);\n            });\n        } else {\n            /** @type {Array<any>} */ this._prelimContent.splice(index, length);\n        }\n    }\n    /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */ get(index) {\n        return typeListGet(this, index);\n    }\n    /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */ toArray() {\n        return typeListToArray(this);\n    }\n    /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */ slice(start = 0, end = this.length) {\n        return typeListSlice(this, start, end);\n    }\n    /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */ toJSON() {\n        return this.map((c)=>c instanceof AbstractType ? c.toJSON() : c);\n    }\n    /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */ map(f) {\n        return typeListMap(this, /** @type {any} */ f);\n    }\n    /**\n   * Executes a provided function once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */ forEach(f) {\n        typeListForEach(this, f);\n    }\n    /**\n   * @return {IterableIterator<T>}\n   */ [Symbol.iterator]() {\n        return typeListCreateIterator(this);\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YArrayRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */ const readYArray = (_decoder)=>new YArray();\n/**\n * @module YMap\n */ /**\n * @template T\n * @extends YEvent<YMap<T>>\n * Event that describes the changes on a YMap.\n */ class YMapEvent extends YEvent {\n    /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */ constructor(ymap, transaction, subs){\n        super(ymap, transaction);\n        this.keysChanged = subs;\n    }\n}\n/**\n * @template MapType\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<MapType>>\n * @implements {Iterable<[string, MapType]>}\n */ class YMap extends AbstractType {\n    /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */ constructor(entries){\n        super();\n        /**\n     * @type {Map<string,any>?}\n     * @private\n     */ this._prelimContent = null;\n        if (entries === undefined) {\n            this._prelimContent = new Map();\n        } else {\n            this._prelimContent = new Map(entries);\n        }\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item); /** @type {Map<string, any>} */ \n        this._prelimContent.forEach((value, key)=>{\n            this.set(key, value);\n        });\n        this._prelimContent = null;\n    }\n    /**\n   * @return {YMap<MapType>}\n   */ _copy() {\n        return new YMap();\n    }\n    /**\n   * @return {YMap<MapType>}\n   */ clone() {\n        /**\n     * @type {YMap<MapType>}\n     */ const map = new YMap();\n        this.forEach((value, key)=>{\n            map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ value.clone() : value);\n        });\n        return map;\n    }\n    /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n    }\n    /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */ toJSON() {\n        /**\n     * @type {Object<string,MapType>}\n     */ const map = {};\n        this._map.forEach((item, key)=>{\n            if (!item.deleted) {\n                const v = item.content.getContent()[item.length - 1];\n                map[key] = v instanceof AbstractType ? v.toJSON() : v;\n            }\n        });\n        return map;\n    }\n    /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */ get size() {\n        return [\n            ...createMapIterator(this._map)\n        ].length;\n    }\n    /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */ keys() {\n        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>v[0]);\n    }\n    /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<MapType>}\n   */ values() {\n        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>v[1].content.getContent()[v[1].length - 1]);\n    }\n    /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */ entries() {\n        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>/** @type {any} */ [\n                v[0],\n                v[1].content.getContent()[v[1].length - 1]\n            ]);\n    }\n    /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */ forEach(f) {\n        this._map.forEach((item, key)=>{\n            if (!item.deleted) {\n                f(item.content.getContent()[item.length - 1], key, this);\n            }\n        });\n    }\n    /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */ delete(key) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapDelete(transaction, this, key);\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimContent.delete(key);\n        }\n    }\n    /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */ set(key, value) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapSet(transaction, this, key, /** @type {any} */ value);\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimContent.set(key, value);\n        }\n        return value;\n    }\n    /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */ get(key) {\n        return /** @type {any} */ typeMapGet(this, key);\n    }\n    /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */ has(key) {\n        return typeMapHas(this, key);\n    }\n    /**\n   * Removes all elements from this YMap.\n   */ clear() {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                this.forEach(function(_value, key, map) {\n                    typeMapDelete(transaction, map, key);\n                });\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimContent.clear();\n        }\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YMapRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */ const readYMap = (_decoder)=>new YMap();\n/**\n * @module YText\n */ /**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */ const equalAttrs = (a, b)=>a === b || typeof a === \"object\" && typeof b === \"object\" && a && b && lib0_object__WEBPACK_IMPORTED_MODULE_18__.equalFlat(a, b);\nclass ItemTextListPosition {\n    /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */ constructor(left, right, index, currentAttributes){\n        this.left = left;\n        this.right = right;\n        this.index = index;\n        this.currentAttributes = currentAttributes;\n    }\n    /**\n   * Only call this if you know that this.right is defined\n   */ forward() {\n        if (this.right === null) {\n            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        switch(this.right.content.constructor){\n            case ContentFormat:\n                if (!this.right.deleted) {\n                    updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ this.right.content);\n                }\n                break;\n            default:\n                if (!this.right.deleted) {\n                    this.index += this.right.length;\n                }\n                break;\n        }\n        this.left = this.right;\n        this.right = this.right.right;\n    }\n}\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */ const findNextPosition = (transaction, pos, count)=>{\n    while(pos.right !== null && count > 0){\n        switch(pos.right.content.constructor){\n            case ContentFormat:\n                if (!pos.right.deleted) {\n                    updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ pos.right.content);\n                }\n                break;\n            default:\n                if (!pos.right.deleted) {\n                    if (count < pos.right.length) {\n                        // split right\n                        getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n                    }\n                    pos.index += pos.right.length;\n                    count -= pos.right.length;\n                }\n                break;\n        }\n        pos.left = pos.right;\n        pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n    }\n    return pos;\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {boolean} useSearchMarker\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */ const findPosition = (transaction, parent, index, useSearchMarker)=>{\n    const currentAttributes = new Map();\n    const marker = useSearchMarker ? findMarker(parent, index) : null;\n    if (marker) {\n        const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n        return findNextPosition(transaction, pos, index - marker.index);\n    } else {\n        const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n        return findNextPosition(transaction, pos, index);\n    }\n};\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */ const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes)=>{\n    // check if we really need to remove attributes\n    while(currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ currPos.right.content.key), /** @type {ContentFormat} */ currPos.right.content.value))){\n        if (!currPos.right.deleted) {\n            negatedAttributes.delete(/** @type {ContentFormat} */ currPos.right.content.key);\n        }\n        currPos.forward();\n    }\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    negatedAttributes.forEach((val, key)=>{\n        const left = currPos.left;\n        const right = currPos.right;\n        const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n        nextFormat.integrate(transaction, 0);\n        currPos.right = nextFormat;\n        currPos.forward();\n    });\n};\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */ const updateCurrentAttributes = (currentAttributes, format)=>{\n    const { key, value } = format;\n    if (value === null) {\n        currentAttributes.delete(key);\n    } else {\n        currentAttributes.set(key, value);\n    }\n};\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */ const minimizeAttributeChanges = (currPos, attributes)=>{\n    // go right while attributes[right.key] === right.value (or right is deleted)\n    while(true){\n        if (currPos.right === null) {\n            break;\n        } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[/** @type {ContentFormat} */ currPos.right.content.key] || null, /** @type {ContentFormat} */ currPos.right.content.value)) ;\n        else {\n            break;\n        }\n        currPos.forward();\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/ const insertAttributes = (transaction, parent, currPos, attributes)=>{\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    const negatedAttributes = new Map();\n    // insert format-start items\n    for(const key in attributes){\n        const val = attributes[key];\n        const currentVal = currPos.currentAttributes.get(key) || null;\n        if (!equalAttrs(currentVal, val)) {\n            // save negated attribute (set null if currentVal undefined)\n            negatedAttributes.set(key, currentVal);\n            const { left, right } = currPos;\n            currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n            currPos.right.integrate(transaction, 0);\n            currPos.forward();\n        }\n    }\n    return negatedAttributes;\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object|AbstractType<any>} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/ const insertText = (transaction, parent, currPos, text, attributes)=>{\n    currPos.currentAttributes.forEach((_val, key)=>{\n        if (attributes[key] === undefined) {\n            attributes[key] = null;\n        }\n    });\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    minimizeAttributeChanges(currPos, attributes);\n    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n    // insert content\n    const content = text.constructor === String ? new ContentString(/** @type {string} */ text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);\n    let { left, right, index } = currPos;\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n    }\n    right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n    right.integrate(transaction, 0);\n    currPos.right = right;\n    currPos.index = index;\n    currPos.forward();\n    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */ const formatText = (transaction, parent, currPos, length, attributes)=>{\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    minimizeAttributeChanges(currPos, attributes);\n    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n    // iterate until first non-format or null is found\n    // delete all formats with attributes[format.key] != null\n    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there\n    // eslint-disable-next-line no-labels\n    iterationLoop: while(currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))){\n        if (!currPos.right.deleted) {\n            switch(currPos.right.content.constructor){\n                case ContentFormat:\n                    {\n                        const { key, value } = /** @type {ContentFormat} */ currPos.right.content;\n                        const attr = attributes[key];\n                        if (attr !== undefined) {\n                            if (equalAttrs(attr, value)) {\n                                negatedAttributes.delete(key);\n                            } else {\n                                if (length === 0) {\n                                    break iterationLoop;\n                                }\n                                negatedAttributes.set(key, value);\n                            }\n                            currPos.right.delete(transaction);\n                        } else {\n                            currPos.currentAttributes.set(key, value);\n                        }\n                        break;\n                    }\n                default:\n                    if (length < currPos.right.length) {\n                        getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n                    }\n                    length -= currPos.right.length;\n                    break;\n            }\n        }\n        currPos.forward();\n    }\n    // Quill just assumes that the editor starts with a newline and that it always\n    // ends with a newline. We only insert that newline when a new newline is\n    // inserted - i.e when length is bigger than type.length\n    if (length > 0) {\n        let newlines = \"\";\n        for(; length > 0; length--){\n            newlines += \"\\n\";\n        }\n        currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n        currPos.right.integrate(transaction, 0);\n        currPos.forward();\n    }\n    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} currAttributes\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */ const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes)=>{\n    /**\n   * @type {Item|null}\n   */ let end = start;\n    /**\n   * @type {Map<string,ContentFormat>}\n   */ const endFormats = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    while(end && (!end.countable || end.deleted)){\n        if (!end.deleted && end.content.constructor === ContentFormat) {\n            const cf = /** @type {ContentFormat} */ end.content;\n            endFormats.set(cf.key, cf);\n        }\n        end = end.right;\n    }\n    let cleanups = 0;\n    let reachedCurr = false;\n    while(start !== end){\n        if (curr === start) {\n            reachedCurr = true;\n        }\n        if (!start.deleted) {\n            const content = start.content;\n            switch(content.constructor){\n                case ContentFormat:\n                    {\n                        const { key, value } = /** @type {ContentFormat} */ content;\n                        const startAttrValue = startAttributes.get(key) || null;\n                        if (endFormats.get(key) !== content || startAttrValue === value) {\n                            // Either this format is overwritten or it is not necessary because the attribute already existed.\n                            start.delete(transaction);\n                            cleanups++;\n                            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {\n                                if (startAttrValue === null) {\n                                    currAttributes.delete(key);\n                                } else {\n                                    currAttributes.set(key, startAttrValue);\n                                }\n                            }\n                        }\n                        if (!reachedCurr && !start.deleted) {\n                            updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ content);\n                        }\n                        break;\n                    }\n            }\n        }\n        start = /** @type {Item} */ start.right;\n    }\n    return cleanups;\n};\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */ const cleanupContextlessFormattingGap = (transaction, item)=>{\n    // iterate until item.right is null or content\n    while(item && item.right && (item.right.deleted || !item.right.countable)){\n        item = item.right;\n    }\n    const attrs = new Set();\n    // iterate back until a content item is found\n    while(item && (item.deleted || !item.countable)){\n        if (!item.deleted && item.content.constructor === ContentFormat) {\n            const key = /** @type {ContentFormat} */ item.content.key;\n            if (attrs.has(key)) {\n                item.delete(transaction);\n            } else {\n                attrs.add(key);\n            }\n        }\n        item = item.left;\n    }\n};\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */ const cleanupYTextFormatting = (type)=>{\n    let res = 0;\n    transact(/** @type {Doc} */ type.doc, (transaction)=>{\n        let start = /** @type {Item} */ type._start;\n        let end = type._start;\n        let startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n        const currentAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(startAttributes);\n        while(end){\n            if (end.deleted === false) {\n                switch(end.content.constructor){\n                    case ContentFormat:\n                        updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ end.content);\n                        break;\n                    default:\n                        res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n                        startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currentAttributes);\n                        start = end;\n                        break;\n                }\n            }\n            end = end.right;\n        }\n    });\n    return res;\n};\n/**\n * This will be called by the transction once the event handlers are called to potentially cleanup\n * formatting attributes.\n *\n * @param {Transaction} transaction\n */ const cleanupYTextAfterTransaction = (transaction)=>{\n    /**\n   * @type {Set<YText>}\n   */ const needFullCleanup = new Set();\n    // check if another formatting item was inserted\n    const doc = transaction.doc;\n    for (const [client, afterClock] of transaction.afterState.entries()){\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n            continue;\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ doc.store.clients.get(client), clock, afterClock, (item)=>{\n            if (!item.deleted && /** @type {Item} */ item.content.constructor === ContentFormat && item.constructor !== GC) {\n                needFullCleanup.add(/** @type {any} */ item.parent);\n            }\n        });\n    }\n    // cleanup in a new transaction\n    transact(doc, (t)=>{\n        iterateDeletedStructs(transaction, transaction.deleteSet, (item)=>{\n            if (item instanceof GC || !/** @type {YText} */ item.parent._hasFormatting || needFullCleanup.has(/** @type {YText} */ item.parent)) {\n                return;\n            }\n            const parent = /** @type {YText} */ item.parent;\n            if (item.content.constructor === ContentFormat) {\n                needFullCleanup.add(parent);\n            } else {\n                // If no formatting attribute was inserted or deleted, we can make due with contextless\n                // formatting cleanups.\n                // Contextless: it is not necessary to compute currentAttributes for the affected position.\n                cleanupContextlessFormattingGap(t, item);\n            }\n        });\n        // If a formatting item was inserted, we simply clean the whole type.\n        // We need to compute currentAttributes for the current position anyway.\n        for (const yText of needFullCleanup){\n            cleanupYTextFormatting(yText);\n        }\n    });\n};\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */ const deleteText = (transaction, currPos, length)=>{\n    const startLength = length;\n    const startAttrs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currPos.currentAttributes);\n    const start = currPos.right;\n    while(length > 0 && currPos.right !== null){\n        if (currPos.right.deleted === false) {\n            switch(currPos.right.content.constructor){\n                case ContentType:\n                case ContentEmbed:\n                case ContentString:\n                    if (length < currPos.right.length) {\n                        getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n                    }\n                    length -= currPos.right.length;\n                    currPos.right.delete(transaction);\n                    break;\n            }\n        }\n        currPos.forward();\n    }\n    if (start) {\n        cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n    }\n    const parent = /** @type {AbstractType<any>} */ /** @type {Item} */ (currPos.left || currPos.right).parent;\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n    }\n    return currPos;\n};\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */ /**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */ /**\n * @extends YEvent<YText>\n * Event that describes the changes on a YText type.\n */ class YTextEvent extends YEvent {\n    /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */ constructor(ytext, transaction, subs){\n        super(ytext, transaction);\n        /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */ this.childListChanged = false;\n        /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */ this.keysChanged = new Set();\n        subs.forEach((sub)=>{\n            if (sub === null) {\n                this.childListChanged = true;\n            } else {\n                this.keysChanged.add(sub);\n            }\n        });\n    }\n    /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */ get changes() {\n        if (this._changes === null) {\n            /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}\n       */ const changes = {\n                keys: this.keys,\n                delta: this.delta,\n                added: new Set(),\n                deleted: new Set()\n            };\n            this._changes = changes;\n        }\n        return /** @type {any} */ this._changes;\n    }\n    /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */ get delta() {\n        if (this._delta === null) {\n            const y = /** @type {Doc} */ this.target.doc;\n            /**\n       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */ const delta = [];\n            transact(y, (transaction)=>{\n                const currentAttributes = new Map(); // saves all current attributes for insert\n                const oldAttributes = new Map();\n                let item = this.target._start;\n                /**\n         * @type {string?}\n         */ let action = null;\n                /**\n         * @type {Object<string,any>}\n         */ const attributes = {}; // counts added or removed new attributes for retain\n                /**\n         * @type {string|object}\n         */ let insert = \"\";\n                let retain = 0;\n                let deleteLen = 0;\n                const addOp = ()=>{\n                    if (action !== null) {\n                        /**\n             * @type {any}\n             */ let op = null;\n                        switch(action){\n                            case \"delete\":\n                                if (deleteLen > 0) {\n                                    op = {\n                                        delete: deleteLen\n                                    };\n                                }\n                                deleteLen = 0;\n                                break;\n                            case \"insert\":\n                                if (typeof insert === \"object\" || insert.length > 0) {\n                                    op = {\n                                        insert\n                                    };\n                                    if (currentAttributes.size > 0) {\n                                        op.attributes = {};\n                                        currentAttributes.forEach((value, key)=>{\n                                            if (value !== null) {\n                                                op.attributes[key] = value;\n                                            }\n                                        });\n                                    }\n                                }\n                                insert = \"\";\n                                break;\n                            case \"retain\":\n                                if (retain > 0) {\n                                    op = {\n                                        retain\n                                    };\n                                    if (!lib0_object__WEBPACK_IMPORTED_MODULE_18__.isEmpty(attributes)) {\n                                        op.attributes = lib0_object__WEBPACK_IMPORTED_MODULE_18__.assign({}, attributes);\n                                    }\n                                }\n                                retain = 0;\n                                break;\n                        }\n                        if (op) delta.push(op);\n                        action = null;\n                    }\n                };\n                while(item !== null){\n                    switch(item.content.constructor){\n                        case ContentType:\n                        case ContentEmbed:\n                            if (this.adds(item)) {\n                                if (!this.deletes(item)) {\n                                    addOp();\n                                    action = \"insert\";\n                                    insert = item.content.getContent()[0];\n                                    addOp();\n                                }\n                            } else if (this.deletes(item)) {\n                                if (action !== \"delete\") {\n                                    addOp();\n                                    action = \"delete\";\n                                }\n                                deleteLen += 1;\n                            } else if (!item.deleted) {\n                                if (action !== \"retain\") {\n                                    addOp();\n                                    action = \"retain\";\n                                }\n                                retain += 1;\n                            }\n                            break;\n                        case ContentString:\n                            if (this.adds(item)) {\n                                if (!this.deletes(item)) {\n                                    if (action !== \"insert\") {\n                                        addOp();\n                                        action = \"insert\";\n                                    }\n                                    insert += /** @type {ContentString} */ item.content.str;\n                                }\n                            } else if (this.deletes(item)) {\n                                if (action !== \"delete\") {\n                                    addOp();\n                                    action = \"delete\";\n                                }\n                                deleteLen += item.length;\n                            } else if (!item.deleted) {\n                                if (action !== \"retain\") {\n                                    addOp();\n                                    action = \"retain\";\n                                }\n                                retain += item.length;\n                            }\n                            break;\n                        case ContentFormat:\n                            {\n                                const { key, value } = /** @type {ContentFormat} */ item.content;\n                                if (this.adds(item)) {\n                                    if (!this.deletes(item)) {\n                                        const curVal = currentAttributes.get(key) || null;\n                                        if (!equalAttrs(curVal, value)) {\n                                            if (action === \"retain\") {\n                                                addOp();\n                                            }\n                                            if (equalAttrs(value, oldAttributes.get(key) || null)) {\n                                                delete attributes[key];\n                                            } else {\n                                                attributes[key] = value;\n                                            }\n                                        } else if (value !== null) {\n                                            item.delete(transaction);\n                                        }\n                                    }\n                                } else if (this.deletes(item)) {\n                                    oldAttributes.set(key, value);\n                                    const curVal = currentAttributes.get(key) || null;\n                                    if (!equalAttrs(curVal, value)) {\n                                        if (action === \"retain\") {\n                                            addOp();\n                                        }\n                                        attributes[key] = curVal;\n                                    }\n                                } else if (!item.deleted) {\n                                    oldAttributes.set(key, value);\n                                    const attr = attributes[key];\n                                    if (attr !== undefined) {\n                                        if (!equalAttrs(attr, value)) {\n                                            if (action === \"retain\") {\n                                                addOp();\n                                            }\n                                            if (value === null) {\n                                                delete attributes[key];\n                                            } else {\n                                                attributes[key] = value;\n                                            }\n                                        } else if (attr !== null) {\n                                            item.delete(transaction);\n                                        }\n                                    }\n                                }\n                                if (!item.deleted) {\n                                    if (action === \"insert\") {\n                                        addOp();\n                                    }\n                                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ item.content);\n                                }\n                                break;\n                            }\n                    }\n                    item = item.right;\n                }\n                addOp();\n                while(delta.length > 0){\n                    const lastOp = delta[delta.length - 1];\n                    if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n                        // retain delta's if they don't assign attributes\n                        delta.pop();\n                    } else {\n                        break;\n                    }\n                }\n            });\n            this._delta = delta;\n        }\n        return /** @type {any} */ this._delta;\n    }\n}\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */ class YText extends AbstractType {\n    /**\n   * @param {String} [string] The initial value of the YText.\n   */ constructor(string){\n        super();\n        /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */ this._pending = string !== undefined ? [\n            ()=>this.insert(0, string)\n        ] : [];\n        /**\n     * @type {Array<ArraySearchMarker>|null}\n     */ this._searchMarker = [];\n        /**\n     * Whether this YText contains formatting attributes.\n     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)\n     */ this._hasFormatting = false;\n    }\n    /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */ get length() {\n        return this._length;\n    }\n    /**\n   * @param {Doc} y\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        try {\n            /** @type {Array<function>} */ this._pending.forEach((f)=>f());\n        } catch (e) {\n            console.error(e);\n        }\n        this._pending = null;\n    }\n    _copy() {\n        return new YText();\n    }\n    /**\n   * @return {YText}\n   */ clone() {\n        const text = new YText();\n        text.applyDelta(this.toDelta());\n        return text;\n    }\n    /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        super._callObserver(transaction, parentSubs);\n        const event = new YTextEvent(this, transaction, parentSubs);\n        callTypeObservers(this, transaction, event);\n        // If a remote change happened, we try to cleanup potential formatting duplicates.\n        if (!transaction.local && this._hasFormatting) {\n            transaction._needFormattingCleanup = true;\n        }\n    }\n    /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */ toString() {\n        let str = \"\";\n        /**\n     * @type {Item|null}\n     */ let n = this._start;\n        while(n !== null){\n            if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n                str += /** @type {ContentString} */ n.content.str;\n            }\n            n = n.right;\n        }\n        return str;\n    }\n    /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */ toJSON() {\n        return this.toString();\n    }\n    /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  opts\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */ applyDelta(delta, { sanitize = true } = {}) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n                for(let i = 0; i < delta.length; i++){\n                    const op = delta[i];\n                    if (op.insert !== undefined) {\n                        // Quill assumes that the content starts with an empty paragraph.\n                        // Yjs/Y.Text assumes that it starts empty. We always hide that\n                        // there is a newline at the end of the content.\n                        // If we omit this step, clients will see a different number of\n                        // paragraphs, but nothing bad will happen.\n                        const ins = !sanitize && typeof op.insert === \"string\" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === \"\\n\" ? op.insert.slice(0, -1) : op.insert;\n                        if (typeof ins !== \"string\" || ins.length > 0) {\n                            insertText(transaction, this, currPos, ins, op.attributes || {});\n                        }\n                    } else if (op.retain !== undefined) {\n                        formatText(transaction, this, currPos, op.retain, op.attributes || {});\n                    } else if (op.delete !== undefined) {\n                        deleteText(transaction, currPos, op.delete);\n                    }\n                }\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.applyDelta(delta));\n        }\n    }\n    /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */ toDelta(snapshot, prevSnapshot, computeYChange) {\n        /**\n     * @type{Array<any>}\n     */ const ops = [];\n        const currentAttributes = new Map();\n        const doc = /** @type {Doc} */ this.doc;\n        let str = \"\";\n        let n = this._start;\n        function packStr() {\n            if (str.length > 0) {\n                // pack str with attributes to ops\n                /**\n         * @type {Object<string,any>}\n         */ const attributes = {};\n                let addAttributes = false;\n                currentAttributes.forEach((value, key)=>{\n                    addAttributes = true;\n                    attributes[key] = value;\n                });\n                /**\n         * @type {Object<string,any>}\n         */ const op = {\n                    insert: str\n                };\n                if (addAttributes) {\n                    op.attributes = attributes;\n                }\n                ops.push(op);\n                str = \"\";\n            }\n        }\n        const computeDelta = ()=>{\n            while(n !== null){\n                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) {\n                    switch(n.content.constructor){\n                        case ContentString:\n                            {\n                                const cur = currentAttributes.get(\"ychange\");\n                                if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                                    if (cur === undefined || cur.user !== n.id.client || cur.type !== \"removed\") {\n                                        packStr();\n                                        currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"removed\", n.id) : {\n                                            type: \"removed\"\n                                        });\n                                    }\n                                } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                                    if (cur === undefined || cur.user !== n.id.client || cur.type !== \"added\") {\n                                        packStr();\n                                        currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"added\", n.id) : {\n                                            type: \"added\"\n                                        });\n                                    }\n                                } else if (cur !== undefined) {\n                                    packStr();\n                                    currentAttributes.delete(\"ychange\");\n                                }\n                                str += /** @type {ContentString} */ n.content.str;\n                                break;\n                            }\n                        case ContentType:\n                        case ContentEmbed:\n                            {\n                                packStr();\n                                /**\n               * @type {Object<string,any>}\n               */ const op = {\n                                    insert: n.content.getContent()[0]\n                                };\n                                if (currentAttributes.size > 0) {\n                                    const attrs = /** @type {Object<string,any>} */ {};\n                                    op.attributes = attrs;\n                                    currentAttributes.forEach((value, key)=>{\n                                        attrs[key] = value;\n                                    });\n                                }\n                                ops.push(op);\n                                break;\n                            }\n                        case ContentFormat:\n                            if (isVisible(n, snapshot)) {\n                                packStr();\n                                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ n.content);\n                            }\n                            break;\n                    }\n                }\n                n = n.right;\n            }\n            packStr();\n        };\n        if (snapshot || prevSnapshot) {\n            // snapshots are merged again after the transaction, so we need to keep the\n            // transaction alive until we are done\n            transact(doc, (transaction)=>{\n                if (snapshot) {\n                    splitSnapshotAffectedStructs(transaction, snapshot);\n                }\n                if (prevSnapshot) {\n                    splitSnapshotAffectedStructs(transaction, prevSnapshot);\n                }\n                computeDelta();\n            }, \"cleanup\");\n        } else {\n            computeDelta();\n        }\n        return ops;\n    }\n    /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */ insert(index, text, attributes) {\n        if (text.length <= 0) {\n            return;\n        }\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                const pos = findPosition(transaction, this, index, !attributes);\n                if (!attributes) {\n                    attributes = {};\n                    // @ts-ignore\n                    pos.currentAttributes.forEach((v, k)=>{\n                        attributes[k] = v;\n                    });\n                }\n                insertText(transaction, this, pos, text, attributes);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.insert(index, text, attributes));\n        }\n    }\n    /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} [attributes] Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */ insertEmbed(index, embed, attributes) {\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                const pos = findPosition(transaction, this, index, !attributes);\n                insertText(transaction, this, pos, embed, attributes || {});\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.insertEmbed(index, embed, attributes || {}));\n        }\n    }\n    /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */ delete(index, length) {\n        if (length === 0) {\n            return;\n        }\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                deleteText(transaction, findPosition(transaction, this, index, true), length);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.delete(index, length));\n        }\n    }\n    /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */ format(index, length, attributes) {\n        if (length === 0) {\n            return;\n        }\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                const pos = findPosition(transaction, this, index, false);\n                if (pos.right === null) {\n                    return;\n                }\n                formatText(transaction, this, pos, length, attributes);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.format(index, length, attributes));\n        }\n    }\n    /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */ removeAttribute(attributeName) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapDelete(transaction, this, attributeName);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.removeAttribute(attributeName));\n        }\n    }\n    /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */ setAttribute(attributeName, attributeValue) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapSet(transaction, this, attributeName, attributeValue);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.setAttribute(attributeName, attributeValue));\n        }\n    }\n    /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */ getAttribute(attributeName) {\n        return /** @type {any} */ typeMapGet(this, attributeName);\n    }\n    /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */ getAttributes() {\n        return typeMapGetAll(this);\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YTextRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YText}\n *\n * @private\n * @function\n */ const readYText = (_decoder)=>new YText();\n/**\n * @module YXml\n */ /**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */ /**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */ /**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */ class YXmlTreeWalker {\n    /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */ constructor(root, f = ()=>true){\n        this._filter = f;\n        this._root = root;\n        /**\n     * @type {Item}\n     */ this._currentNode = /** @type {Item} */ root._start;\n        this._firstCall = true;\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */ next() {\n        /**\n     * @type {Item|null}\n     */ let n = this._currentNode;\n        let type = n && n.content && /** @type {any} */ n.content.type;\n        if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {\n            do {\n                type = /** @type {any} */ n.content.type;\n                if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n                    // walk down in the tree\n                    n = type._start;\n                } else {\n                    // walk right or up in the tree\n                    while(n !== null){\n                        if (n.right !== null) {\n                            n = n.right;\n                            break;\n                        } else if (n.parent === this._root) {\n                            n = null;\n                        } else {\n                            n = /** @type {AbstractType<any>} */ n.parent._item;\n                        }\n                    }\n                }\n            }while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ n.content.type)));\n        }\n        this._firstCall = false;\n        if (n === null) {\n            // @ts-ignore\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        this._currentNode = n;\n        return {\n            value: /** @type {any} */ n.content.type,\n            done: false\n        };\n    }\n}\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */ class YXmlFragment extends AbstractType {\n    constructor(){\n        super();\n        /**\n     * @type {Array<any>|null}\n     */ this._prelimContent = [];\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get firstChild() {\n        const first = this._first;\n        return first ? first.content.getContent()[0] : null;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        this.insert(0, /** @type {Array<any>} */ this._prelimContent);\n        this._prelimContent = null;\n    }\n    _copy() {\n        return new YXmlFragment();\n    }\n    /**\n   * @return {YXmlFragment}\n   */ clone() {\n        const el = new YXmlFragment();\n        // @ts-ignore\n        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));\n        return el;\n    }\n    get length() {\n        return this._prelimContent === null ? this._length : this._prelimContent.length;\n    }\n    /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */ createTreeWalker(filter) {\n        return new YXmlTreeWalker(this, filter);\n    }\n    /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */ querySelector(query) {\n        query = query.toUpperCase();\n        // @ts-ignore\n        const iterator = new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query);\n        const next = iterator.next();\n        if (next.done) {\n            return null;\n        } else {\n            return next.value;\n        }\n    }\n    /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */ querySelectorAll(query) {\n        query = query.toUpperCase();\n        // @ts-ignore\n        return lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query));\n    }\n    /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n    }\n    /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */ toString() {\n        return typeListMap(this, (xml)=>xml.toString()).join(\"\");\n    }\n    /**\n   * @return {string}\n   */ toJSON() {\n        return this.toString();\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks = {}, binding) {\n        const fragment = _document.createDocumentFragment();\n        if (binding !== undefined) {\n            binding._createAssociation(fragment, this);\n        }\n        typeListForEach(this, (xmlType)=>{\n            fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n        });\n        return fragment;\n    }\n    /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */ insert(index, content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListInsertGenerics(transaction, this, index, content);\n            });\n        } else {\n            // @ts-ignore _prelimContent is defined because this is not yet integrated\n            this._prelimContent.splice(index, 0, ...content);\n        }\n    }\n    /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */ insertAfter(ref, content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                const refItem = ref && ref instanceof AbstractType ? ref._item : ref;\n                typeListInsertGenericsAfter(transaction, this, refItem, content);\n            });\n        } else {\n            const pc = /** @type {Array<any>} */ this._prelimContent;\n            const index = ref === null ? 0 : pc.findIndex((el)=>el === ref) + 1;\n            if (index === 0 && ref !== null) {\n                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(\"Reference item not found\");\n            }\n            pc.splice(index, 0, ...content);\n        }\n    }\n    /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */ delete(index, length = 1) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListDelete(transaction, this, index, length);\n            });\n        } else {\n            // @ts-ignore _prelimContent is defined because this is not yet integrated\n            this._prelimContent.splice(index, length);\n        }\n    }\n    /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */ toArray() {\n        return typeListToArray(this);\n    }\n    /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */ push(content) {\n        this.insert(this.length, content);\n    }\n    /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */ unshift(content) {\n        this.insert(0, content);\n    }\n    /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */ get(index) {\n        return typeListGet(this, index);\n    }\n    /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */ slice(start = 0, end = this.length) {\n        return typeListSlice(this, start, end);\n    }\n    /**\n   * Executes a provided function on once on overy child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */ forEach(f) {\n        typeListForEach(this, f);\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlFragmentRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */ const readYXmlFragment = (_decoder)=>new YXmlFragment();\n/**\n * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes\n */ /**\n * An YXmlElement imitates the behavior of a\n * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n *\n * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]\n */ class YXmlElement extends YXmlFragment {\n    constructor(nodeName = \"UNDEFINED\"){\n        super();\n        this.nodeName = nodeName;\n        /**\n     * @type {Map<string, any>|null}\n     */ this._prelimAttrs = new Map();\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get nextSibling() {\n        const n = this._item ? this._item.next : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get prevSibling() {\n        const n = this._item ? this._item.prev : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        /** @type {Map<string, any>} */ this._prelimAttrs.forEach((value, key)=>{\n            this.setAttribute(key, value);\n        });\n        this._prelimAttrs = null;\n    }\n    /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */ _copy() {\n        return new YXmlElement(this.nodeName);\n    }\n    /**\n   * @return {YXmlElement<KV>}\n   */ clone() {\n        /**\n     * @type {YXmlElement<KV>}\n     */ const el = new YXmlElement(this.nodeName);\n        const attrs = this.getAttributes();\n        lib0_object__WEBPACK_IMPORTED_MODULE_18__.forEach(attrs, (value, key)=>{\n            if (typeof value === \"string\") {\n                el.setAttribute(key, value);\n            }\n        });\n        // @ts-ignore\n        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));\n        return el;\n    }\n    /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */ toString() {\n        const attrs = this.getAttributes();\n        const stringBuilder = [];\n        const keys = [];\n        for(const key in attrs){\n            keys.push(key);\n        }\n        keys.sort();\n        const keysLen = keys.length;\n        for(let i = 0; i < keysLen; i++){\n            const key = keys[i];\n            stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n        }\n        const nodeName = this.nodeName.toLocaleLowerCase();\n        const attrsString = stringBuilder.length > 0 ? \" \" + stringBuilder.join(\" \") : \"\";\n        return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;\n    }\n    /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */ removeAttribute(attributeName) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapDelete(transaction, this, attributeName);\n            });\n        } else {\n            /** @type {Map<string,any>} */ this._prelimAttrs.delete(attributeName);\n        }\n    }\n    /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */ setAttribute(attributeName, attributeValue) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapSet(transaction, this, attributeName, attributeValue);\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimAttrs.set(attributeName, attributeValue);\n        }\n    }\n    /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {KV[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */ getAttribute(attributeName) {\n        return /** @type {any} */ typeMapGet(this, attributeName);\n    }\n    /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */ hasAttribute(attributeName) {\n        return /** @type {any} */ typeMapHas(this, attributeName);\n    }\n    /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */ getAttributes(snapshot) {\n        return /** @type {any} */ snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this);\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks = {}, binding) {\n        const dom = _document.createElement(this.nodeName);\n        const attrs = this.getAttributes();\n        for(const key in attrs){\n            const value = attrs[key];\n            if (typeof value === \"string\") {\n                dom.setAttribute(key, value);\n            }\n        }\n        typeListForEach(this, (yxml)=>{\n            dom.appendChild(yxml.toDOM(_document, hooks, binding));\n        });\n        if (binding !== undefined) {\n            binding._createAssociation(dom, this);\n        }\n        return dom;\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlElementRefID);\n        encoder.writeKey(this.nodeName);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */ const readYXmlElement = (decoder)=>new YXmlElement(decoder.readKey());\n/**\n * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */ class YXmlEvent extends YEvent {\n    /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */ constructor(target, subs, transaction){\n        super(target, transaction);\n        /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */ this.childListChanged = false;\n        /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */ this.attributesChanged = new Set();\n        subs.forEach((sub)=>{\n            if (sub === null) {\n                this.childListChanged = true;\n            } else {\n                this.attributesChanged.add(sub);\n            }\n        });\n    }\n}\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */ class YXmlHook extends YMap {\n    /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */ constructor(hookName){\n        super();\n        /**\n     * @type {string}\n     */ this.hookName = hookName;\n    }\n    /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */ _copy() {\n        return new YXmlHook(this.hookName);\n    }\n    /**\n   * @return {YXmlHook}\n   */ clone() {\n        const el = new YXmlHook(this.hookName);\n        this.forEach((value, key)=>{\n            el.set(key, value);\n        });\n        return el;\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks = {}, binding) {\n        const hook = hooks[this.hookName];\n        let dom;\n        if (hook !== undefined) {\n            dom = hook.createDom(this);\n        } else {\n            dom = document.createElement(this.hookName);\n        }\n        dom.setAttribute(\"data-yjs-hook\", this.hookName);\n        if (binding !== undefined) {\n            binding._createAssociation(dom, this);\n        }\n        return dom;\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlHookRefID);\n        encoder.writeKey(this.hookName);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */ const readYXmlHook = (decoder)=>new YXmlHook(decoder.readKey());\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */ class YXmlText extends YText {\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get nextSibling() {\n        const n = this._item ? this._item.next : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get prevSibling() {\n        const n = this._item ? this._item.prev : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    _copy() {\n        return new YXmlText();\n    }\n    /**\n   * @return {YXmlText}\n   */ clone() {\n        const text = new YXmlText();\n        text.applyDelta(this.toDelta());\n        return text;\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks, binding) {\n        const dom = _document.createTextNode(this.toString());\n        if (binding !== undefined) {\n            binding._createAssociation(dom, this);\n        }\n        return dom;\n    }\n    toString() {\n        // @ts-ignore\n        return this.toDelta().map((delta)=>{\n            const nestedNodes = [];\n            for(const nodeName in delta.attributes){\n                const attrs = [];\n                for(const key in delta.attributes[nodeName]){\n                    attrs.push({\n                        key,\n                        value: delta.attributes[nodeName][key]\n                    });\n                }\n                // sort attributes to get a unique order\n                attrs.sort((a, b)=>a.key < b.key ? -1 : 1);\n                nestedNodes.push({\n                    nodeName,\n                    attrs\n                });\n            }\n            // sort node order to get a unique order\n            nestedNodes.sort((a, b)=>a.nodeName < b.nodeName ? -1 : 1);\n            // now convert to dom string\n            let str = \"\";\n            for(let i = 0; i < nestedNodes.length; i++){\n                const node = nestedNodes[i];\n                str += `<${node.nodeName}`;\n                for(let j = 0; j < node.attrs.length; j++){\n                    const attr = node.attrs[j];\n                    str += ` ${attr.key}=\"${attr.value}\"`;\n                }\n                str += \">\";\n            }\n            str += delta.insert;\n            for(let i = nestedNodes.length - 1; i >= 0; i--){\n                str += `</${nestedNodes[i].nodeName}>`;\n            }\n            return str;\n        }).join(\"\");\n    }\n    /**\n   * @return {string}\n   */ toJSON() {\n        return this.toString();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlTextRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */ const readYXmlText = (decoder)=>new YXmlText();\nclass AbstractStruct {\n    /**\n   * @param {ID} id\n   * @param {number} length\n   */ constructor(id, length){\n        this.id = id;\n        this.length = length;\n    }\n    /**\n   * @type {boolean}\n   */ get deleted() {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */ write(encoder, offset, encodingRef) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n}\nconst structGCRefNumber = 0;\n/**\n * @private\n */ class GC extends AbstractStruct {\n    get deleted() {\n        return true;\n    }\n    delete() {}\n    /**\n   * @param {GC} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        if (this.constructor !== right.constructor) {\n            return false;\n        }\n        this.length += right.length;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        if (offset > 0) {\n            this.id.clock += offset;\n            this.length -= offset;\n        }\n        addStruct(transaction.doc.store, this);\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeInfo(structGCRefNumber);\n        encoder.writeLen(this.length - offset);\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */ getMissing(transaction, store) {\n        return null;\n    }\n}\nclass ContentBinary {\n    /**\n   * @param {Uint8Array} content\n   */ constructor(content){\n        this.content = content;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.content\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentBinary}\n   */ copy() {\n        return new ContentBinary(this.content);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeBuf(this.content);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 3;\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */ const readContentBinary = (decoder)=>new ContentBinary(decoder.readBuf());\nclass ContentDeleted {\n    /**\n   * @param {number} len\n   */ constructor(len){\n        this.len = len;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.len;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return false;\n    }\n    /**\n   * @return {ContentDeleted}\n   */ copy() {\n        return new ContentDeleted(this.len);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */ splice(offset) {\n        const right = new ContentDeleted(this.len - offset);\n        this.len = offset;\n        return right;\n    }\n    /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.len += right.len;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {\n        addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n        item.markDeleted();\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeLen(this.len - offset);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 1;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */ const readContentDeleted = (decoder)=>new ContentDeleted(decoder.readLen());\n/**\n * @param {string} guid\n * @param {Object<string, any>} opts\n */ const createDocFromOpts = (guid, opts)=>new Doc({\n        guid,\n        ...opts,\n        shouldLoad: opts.shouldLoad || opts.autoLoad || false\n    });\n/**\n * @private\n */ class ContentDoc {\n    /**\n   * @param {Doc} doc\n   */ constructor(doc){\n        if (doc._item) {\n            console.error(\"This document was already integrated as a sub-document. You should create a second instance instead with the same guid.\");\n        }\n        /**\n     * @type {Doc}\n     */ this.doc = doc;\n        /**\n     * @type {any}\n     */ const opts = {};\n        this.opts = opts;\n        if (!doc.gc) {\n            opts.gc = false;\n        }\n        if (doc.autoLoad) {\n            opts.autoLoad = true;\n        }\n        if (doc.meta !== null) {\n            opts.meta = doc.meta;\n        }\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.doc\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentDoc}\n   */ copy() {\n        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {\n        // this needs to be reflected in doc.destroy as well\n        this.doc._item = item;\n        transaction.subdocsAdded.add(this.doc);\n        if (this.doc.shouldLoad) {\n            transaction.subdocsLoaded.add(this.doc);\n        }\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {\n        if (transaction.subdocsAdded.has(this.doc)) {\n            transaction.subdocsAdded.delete(this.doc);\n        } else {\n            transaction.subdocsRemoved.add(this.doc);\n        }\n    }\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeString(this.doc.guid);\n        encoder.writeAny(this.opts);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 9;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */ const readContentDoc = (decoder)=>new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\n/**\n * @private\n */ class ContentEmbed {\n    /**\n   * @param {Object} embed\n   */ constructor(embed){\n        this.embed = embed;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.embed\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentEmbed}\n   */ copy() {\n        return new ContentEmbed(this.embed);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeJSON(this.embed);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 5;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */ const readContentEmbed = (decoder)=>new ContentEmbed(decoder.readJSON());\n/**\n * @private\n */ class ContentFormat {\n    /**\n   * @param {string} key\n   * @param {Object} value\n   */ constructor(key, value){\n        this.key = key;\n        this.value = value;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return false;\n    }\n    /**\n   * @return {ContentFormat}\n   */ copy() {\n        return new ContentFormat(this.key, this.value);\n    }\n    /**\n   * @param {number} _offset\n   * @return {ContentFormat}\n   */ splice(_offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentFormat} _right\n   * @return {boolean}\n   */ mergeWith(_right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} _transaction\n   * @param {Item} item\n   */ integrate(_transaction, item) {\n        // @todo searchmarker are currently unsupported for rich text documents\n        const p = /** @type {YText} */ item.parent;\n        p._searchMarker = null;\n        p._hasFormatting = true;\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeKey(this.key);\n        encoder.writeJSON(this.value);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 6;\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */ const readContentFormat = (decoder)=>new ContentFormat(decoder.readKey(), decoder.readJSON());\n/**\n * @private\n */ class ContentJSON {\n    /**\n   * @param {Array<any>} arr\n   */ constructor(arr){\n        /**\n     * @type {Array<any>}\n     */ this.arr = arr;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.arr.length;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return this.arr;\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentJSON}\n   */ copy() {\n        return new ContentJSON(this.arr);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */ splice(offset) {\n        const right = new ContentJSON(this.arr.slice(offset));\n        this.arr = this.arr.slice(0, offset);\n        return right;\n    }\n    /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.arr = this.arr.concat(right.arr);\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        const len = this.arr.length;\n        encoder.writeLen(len - offset);\n        for(let i = offset; i < len; i++){\n            const c = this.arr[i];\n            encoder.writeString(c === undefined ? \"undefined\" : JSON.stringify(c));\n        }\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 2;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */ const readContentJSON = (decoder)=>{\n    const len = decoder.readLen();\n    const cs = [];\n    for(let i = 0; i < len; i++){\n        const c = decoder.readString();\n        if (c === \"undefined\") {\n            cs.push(undefined);\n        } else {\n            cs.push(JSON.parse(c));\n        }\n    }\n    return new ContentJSON(cs);\n};\nclass ContentAny {\n    /**\n   * @param {Array<any>} arr\n   */ constructor(arr){\n        /**\n     * @type {Array<any>}\n     */ this.arr = arr;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.arr.length;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return this.arr;\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentAny}\n   */ copy() {\n        return new ContentAny(this.arr);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */ splice(offset) {\n        const right = new ContentAny(this.arr.slice(offset));\n        this.arr = this.arr.slice(0, offset);\n        return right;\n    }\n    /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.arr = this.arr.concat(right.arr);\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        const len = this.arr.length;\n        encoder.writeLen(len - offset);\n        for(let i = offset; i < len; i++){\n            const c = this.arr[i];\n            encoder.writeAny(c);\n        }\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 8;\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */ const readContentAny = (decoder)=>{\n    const len = decoder.readLen();\n    const cs = [];\n    for(let i = 0; i < len; i++){\n        cs.push(decoder.readAny());\n    }\n    return new ContentAny(cs);\n};\n/**\n * @private\n */ class ContentString {\n    /**\n   * @param {string} str\n   */ constructor(str){\n        /**\n     * @type {string}\n     */ this.str = str;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.str.length;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return this.str.split(\"\");\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentString}\n   */ copy() {\n        return new ContentString(this.str);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentString}\n   */ splice(offset) {\n        const right = new ContentString(this.str.slice(offset));\n        this.str = this.str.slice(0, offset);\n        // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n        const firstCharCode = this.str.charCodeAt(offset - 1);\n        if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n            // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n            // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n            // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n            this.str = this.str.slice(0, offset - 1) + \"�\";\n            // replace right as well\n            right.str = \"�\" + right.str.slice(1);\n        }\n        return right;\n    }\n    /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.str += right.str;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 4;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */ const readContentString = (decoder)=>new ContentString(decoder.readString());\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */ const typeRefs = [\n    readYArray,\n    readYMap,\n    readYText,\n    readYXmlElement,\n    readYXmlFragment,\n    readYXmlHook,\n    readYXmlText\n];\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n/**\n * @private\n */ class ContentType {\n    /**\n   * @param {AbstractType<any>} type\n   */ constructor(type){\n        /**\n     * @type {AbstractType<any>}\n     */ this.type = type;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.type\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentType}\n   */ copy() {\n        return new ContentType(this.type._copy());\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentType}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {\n        this.type._integrate(transaction.doc, item);\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {\n        let item = this.type._start;\n        while(item !== null){\n            if (!item.deleted) {\n                item.delete(transaction);\n            } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n                // This will be gc'd later and we want to merge it if possible\n                // We try to merge all deleted items after each transaction,\n                // but we have no knowledge about that this needs to be merged\n                // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n                transaction._mergeStructs.push(item);\n            }\n            item = item.right;\n        }\n        this.type._map.forEach((item)=>{\n            if (!item.deleted) {\n                item.delete(transaction);\n            } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n                // same as above\n                transaction._mergeStructs.push(item);\n            }\n        });\n        transaction.changed.delete(this.type);\n    }\n    /**\n   * @param {StructStore} store\n   */ gc(store) {\n        let item = this.type._start;\n        while(item !== null){\n            item.gc(store, true);\n            item = item.right;\n        }\n        this.type._start = null;\n        this.type._map.forEach(/** @param {Item | null} item */ (item)=>{\n            while(item !== null){\n                item.gc(store, true);\n                item = item.left;\n            }\n        });\n        this.type._map = new Map();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        this.type._write(encoder);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 7;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */ const readContentType = (decoder)=>new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */ const followRedone = (store, id)=>{\n    /**\n   * @type {ID|null}\n   */ let nextID = id;\n    let diff = 0;\n    let item;\n    do {\n        if (diff > 0) {\n            nextID = createID(nextID.client, nextID.clock + diff);\n        }\n        item = getItem(store, nextID);\n        diff = nextID.clock - item.id.clock;\n        nextID = item.redone;\n    }while (nextID !== null && item instanceof Item);\n    return {\n        item,\n        diff\n    };\n};\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */ const keepItem = (item, keep)=>{\n    while(item !== null && item.keep !== keep){\n        item.keep = keep;\n        item = /** @type {AbstractType<any>} */ item.parent._item;\n    }\n};\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */ const splitItem = (transaction, leftItem, diff)=>{\n    // create rightItem\n    const { client, clock } = leftItem.id;\n    const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));\n    if (leftItem.deleted) {\n        rightItem.markDeleted();\n    }\n    if (leftItem.keep) {\n        rightItem.keep = true;\n    }\n    if (leftItem.redone !== null) {\n        rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n    }\n    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n    leftItem.right = rightItem;\n    // update right\n    if (rightItem.right !== null) {\n        rightItem.right.left = rightItem;\n    }\n    // right is more specific.\n    transaction._mergeStructs.push(rightItem);\n    // update parent._map\n    if (rightItem.parentSub !== null && rightItem.right === null) {\n        /** @type {AbstractType<any>} */ rightItem.parent._map.set(rightItem.parentSub, rightItem);\n    }\n    leftItem.length = diff;\n    return rightItem;\n};\n/**\n * @param {Array<StackItem>} stack\n * @param {ID} id\n */ const isDeletedByUndoStack = (stack, id)=>lib0_array__WEBPACK_IMPORTED_MODULE_2__.some(stack, /** @param {StackItem} s */ (s)=>isDeleted(s.deletions, id));\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n * @param {DeleteSet} itemsToDelete\n * @param {boolean} ignoreRemoteMapChanges\n * @param {import('../utils/UndoManager.js').UndoManager} um\n *\n * @return {Item|null}\n *\n * @private\n */ const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um)=>{\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ownClientID = doc.clientID;\n    const redone = item.redone;\n    if (redone !== null) {\n        return getItemCleanStart(transaction, redone);\n    }\n    let parentItem = /** @type {AbstractType<any>} */ item.parent._item;\n    /**\n   * @type {Item|null}\n   */ let left = null;\n    /**\n   * @type {Item|null}\n   */ let right;\n    // make sure that parent is redone\n    if (parentItem !== null && parentItem.deleted === true) {\n        // try to undo parent if it will be undone anyway\n        if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n            return null;\n        }\n        while(parentItem.redone !== null){\n            parentItem = getItemCleanStart(transaction, parentItem.redone);\n        }\n    }\n    const parentType = parentItem === null ? /** @type {AbstractType<any>} */ item.parent : /** @type {ContentType} */ parentItem.content.type;\n    if (item.parentSub === null) {\n        // Is an array item. Insert at the old position\n        left = item.left;\n        right = item;\n        // find next cloned_redo items\n        while(left !== null){\n            /**\n       * @type {Item|null}\n       */ let leftTrace = left;\n            // trace redone until parent matches\n            while(leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item !== parentItem){\n                leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n            }\n            if (leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item === parentItem) {\n                left = leftTrace;\n                break;\n            }\n            left = left.left;\n        }\n        while(right !== null){\n            /**\n       * @type {Item|null}\n       */ let rightTrace = right;\n            // trace redone until parent matches\n            while(rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item !== parentItem){\n                rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n            }\n            if (rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item === parentItem) {\n                right = rightTrace;\n                break;\n            }\n            right = right.right;\n        }\n    } else {\n        right = null;\n        if (item.right && !ignoreRemoteMapChanges) {\n            left = item;\n            // Iterate right while right is in itemsToDelete\n            // If it is intended to delete right while item is redone, we can expect that item should replace right.\n            while(left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))){\n                left = left.right;\n                // follow redone\n                while(left.redone)left = getItemCleanStart(transaction, left.redone);\n            }\n            if (left && left.right !== null) {\n                // It is not possible to redo this item because it conflicts with a\n                // change from another client\n                return null;\n            }\n        } else {\n            left = parentType._map.get(item.parentSub) || null;\n        }\n    }\n    const nextClock = getState(store, ownClientID);\n    const nextId = createID(ownClientID, nextClock);\n    const redoneItem = new Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());\n    item.redone = nextId;\n    keepItem(redoneItem, true);\n    redoneItem.integrate(transaction, 0);\n    return redoneItem;\n};\n/**\n * Abstract class that represents any content.\n */ class Item extends AbstractStruct {\n    /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */ constructor(id, left, origin, right, rightOrigin, parent, parentSub, content){\n        super(id, content.getLength());\n        /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */ this.origin = origin;\n        /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */ this.left = left;\n        /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */ this.right = right;\n        /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */ this.rightOrigin = rightOrigin;\n        /**\n     * @type {AbstractType<any>|ID|null}\n     */ this.parent = parent;\n        /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */ this.parentSub = parentSub;\n        /**\n     * If this type's effect is redone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */ this.redone = null;\n        /**\n     * @type {AbstractContent}\n     */ this.content = content;\n        /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */ this.info = this.content.isCountable() ? lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2 : 0;\n    }\n    /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */ set marker(isMarked) {\n        if ((this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0 !== isMarked) {\n            this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4;\n        }\n    }\n    get marker() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0;\n    }\n    /**\n   * If true, do not garbage collect this Item.\n   */ get keep() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1) > 0;\n    }\n    set keep(doKeep) {\n        if (this.keep !== doKeep) {\n            this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1;\n        }\n    }\n    get countable() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2) > 0;\n    }\n    /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */ get deleted() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3) > 0;\n    }\n    set deleted(doDelete) {\n        if (this.deleted !== doDelete) {\n            this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n        }\n    }\n    markDeleted() {\n        this.info |= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n    }\n    /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */ getMissing(transaction, store) {\n        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n            return this.origin.client;\n        }\n        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n            return this.rightOrigin.client;\n        }\n        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n            return this.parent.client;\n        }\n        // We have all missing ids, now find the items\n        if (this.origin) {\n            this.left = getItemCleanEnd(transaction, store, this.origin);\n            this.origin = this.left.lastId;\n        }\n        if (this.rightOrigin) {\n            this.right = getItemCleanStart(transaction, this.rightOrigin);\n            this.rightOrigin = this.right.id;\n        }\n        if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {\n            this.parent = null;\n        } else if (!this.parent) {\n            // only set parent if this shouldn't be garbage collected\n            if (this.left && this.left.constructor === Item) {\n                this.parent = this.left.parent;\n                this.parentSub = this.left.parentSub;\n            }\n            if (this.right && this.right.constructor === Item) {\n                this.parent = this.right.parent;\n                this.parentSub = this.right.parentSub;\n            }\n        } else if (this.parent.constructor === ID) {\n            const parentItem = getItem(store, this.parent);\n            if (parentItem.constructor === GC) {\n                this.parent = null;\n            } else {\n                this.parent = /** @type {ContentType} */ parentItem.content.type;\n            }\n        }\n        return null;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        if (offset > 0) {\n            this.id.clock += offset;\n            this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n            this.origin = this.left.lastId;\n            this.content = this.content.splice(offset);\n            this.length -= offset;\n        }\n        if (this.parent) {\n            if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {\n                /**\n         * @type {Item|null}\n         */ let left = this.left;\n                /**\n         * @type {Item|null}\n         */ let o;\n                // set o to the first conflicting item\n                if (left !== null) {\n                    o = left.right;\n                } else if (this.parentSub !== null) {\n                    o = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;\n                    while(o !== null && o.left !== null){\n                        o = o.left;\n                    }\n                } else {\n                    o = /** @type {AbstractType<any>} */ this.parent._start;\n                }\n                // TODO: use something like DeleteSet here (a tree implementation would be best)\n                // @todo use global set definitions\n                /**\n         * @type {Set<Item>}\n         */ const conflictingItems = new Set();\n                /**\n         * @type {Set<Item>}\n         */ const itemsBeforeOrigin = new Set();\n                // Let c in conflictingItems, b in itemsBeforeOrigin\n                // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n                // Note that conflictingItems is a subset of itemsBeforeOrigin\n                while(o !== null && o !== this.right){\n                    itemsBeforeOrigin.add(o);\n                    conflictingItems.add(o);\n                    if (compareIDs(this.origin, o.origin)) {\n                        // case 1\n                        if (o.id.client < this.id.client) {\n                            left = o;\n                            conflictingItems.clear();\n                        } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n                            break;\n                        } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n                    } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {\n                        // case 2\n                        if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n                            left = o;\n                            conflictingItems.clear();\n                        }\n                    } else {\n                        break;\n                    }\n                    o = o.right;\n                }\n                this.left = left;\n            }\n            // reconnect left/right + update parent map/start if necessary\n            if (this.left !== null) {\n                const right = this.left.right;\n                this.right = right;\n                this.left.right = this;\n            } else {\n                let r;\n                if (this.parentSub !== null) {\n                    r = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;\n                    while(r !== null && r.left !== null){\n                        r = r.left;\n                    }\n                } else {\n                    r = /** @type {AbstractType<any>} */ this.parent._start; /** @type {AbstractType<any>} */ \n                    this.parent._start = this;\n                }\n                this.right = r;\n            }\n            if (this.right !== null) {\n                this.right.left = this;\n            } else if (this.parentSub !== null) {\n                // set as current parent value if right === null and this is parentSub\n                /** @type {AbstractType<any>} */ this.parent._map.set(this.parentSub, this);\n                if (this.left !== null) {\n                    // this is the current attribute value of parent. delete right\n                    this.left.delete(transaction);\n                }\n            }\n            // adjust length of parent\n            if (this.parentSub === null && this.countable && !this.deleted) {\n                /** @type {AbstractType<any>} */ this.parent._length += this.length;\n            }\n            addStruct(transaction.doc.store, this);\n            this.content.integrate(transaction, this);\n            // add parent to transaction.changed\n            addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ this.parent, this.parentSub);\n            if (/** @type {AbstractType<any>} */ this.parent._item !== null && /** @type {AbstractType<any>} */ this.parent._item.deleted || this.parentSub !== null && this.right !== null) {\n                // delete if parent is deleted or if this is not the current attribute value of parent\n                this.delete(transaction);\n            }\n        } else {\n            // parent is not defined. Integrate GC struct instead\n            new GC(this.id, this.length).integrate(transaction, 0);\n        }\n    }\n    /**\n   * Returns the next non-deleted item\n   */ get next() {\n        let n = this.right;\n        while(n !== null && n.deleted){\n            n = n.right;\n        }\n        return n;\n    }\n    /**\n   * Returns the previous non-deleted item\n   */ get prev() {\n        let n = this.left;\n        while(n !== null && n.deleted){\n            n = n.left;\n        }\n        return n;\n    }\n    /**\n   * Computes the last content address of this Item.\n   */ get lastId() {\n        // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n        return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);\n    }\n    /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {\n            const searchMarker = /** @type {AbstractType<any>} */ this.parent._searchMarker;\n            if (searchMarker) {\n                searchMarker.forEach((marker)=>{\n                    if (marker.p === right) {\n                        // right is going to be \"forgotten\" so we need to update the marker\n                        marker.p = this;\n                        // adjust marker index\n                        if (!this.deleted && this.countable) {\n                            marker.index -= this.length;\n                        }\n                    }\n                });\n            }\n            if (right.keep) {\n                this.keep = true;\n            }\n            this.right = right.right;\n            if (this.right !== null) {\n                this.right.left = this;\n            }\n            this.length += right.length;\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */ delete(transaction) {\n        if (!this.deleted) {\n            const parent = /** @type {AbstractType<any>} */ this.parent;\n            // adjust the length of parent\n            if (this.countable && this.parentSub === null) {\n                parent._length -= this.length;\n            }\n            this.markDeleted();\n            addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n            addChangedTypeToTransaction(transaction, parent, this.parentSub);\n            this.content.delete(transaction);\n        }\n    }\n    /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */ gc(store, parentGCd) {\n        if (!this.deleted) {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        this.content.gc(store);\n        if (parentGCd) {\n            replaceStruct(store, this, new GC(this.id, this.length));\n        } else {\n            this.content = new ContentDeleted(this.length);\n        }\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */ write(encoder, offset) {\n        const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n        const rightOrigin = this.rightOrigin;\n        const parentSub = this.parentSub;\n        const info = this.content.getRef() & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 | (origin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) | // origin is defined\n        (rightOrigin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) | // right origin is defined\n        (parentSub === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6); // parentSub is non-null\n        encoder.writeInfo(info);\n        if (origin !== null) {\n            encoder.writeLeftID(origin);\n        }\n        if (rightOrigin !== null) {\n            encoder.writeRightID(rightOrigin);\n        }\n        if (origin === null && rightOrigin === null) {\n            const parent = /** @type {AbstractType<any>} */ this.parent;\n            if (parent._item !== undefined) {\n                const parentItem = parent._item;\n                if (parentItem === null) {\n                    // parent type on y._map\n                    // find the correct key\n                    const ykey = findRootTypeKey(parent);\n                    encoder.writeParentInfo(true); // write parentYKey\n                    encoder.writeString(ykey);\n                } else {\n                    encoder.writeParentInfo(false); // write parent id\n                    encoder.writeLeftID(parentItem.id);\n                }\n            } else if (parent.constructor === String) {\n                encoder.writeParentInfo(true); // write parentYKey\n                encoder.writeString(parent);\n            } else if (parent.constructor === ID) {\n                encoder.writeParentInfo(false); // write parent id\n                encoder.writeLeftID(parent);\n            } else {\n                lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n            }\n            if (parentSub !== null) {\n                encoder.writeString(parentSub);\n            }\n        }\n        this.content.write(encoder, offset);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */ const readItemContent = (decoder, info)=>contentRefs[info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5](decoder);\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */ const contentRefs = [\n    ()=>{\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    },\n    readContentDeleted,\n    readContentJSON,\n    readContentBinary,\n    readContentString,\n    readContentEmbed,\n    readContentFormat,\n    readContentType,\n    readContentAny,\n    readContentDoc,\n    ()=>{\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    } // 10 - Skip is not ItemContent\n];\nconst structSkipRefNumber = 10;\n/**\n * @private\n */ class Skip extends AbstractStruct {\n    get deleted() {\n        return true;\n    }\n    delete() {}\n    /**\n   * @param {Skip} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        if (this.constructor !== right.constructor) {\n            return false;\n        }\n        this.length += right.length;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        // skip structs cannot be integrated\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeInfo(structSkipRefNumber);\n        // write as VarUint because Skips can't make use of predictable length-encoding\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, this.length - offset);\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */ getMissing(transaction, store) {\n        return null;\n    }\n}\n/** eslint-env browser */ const glo = /** @type {any} */ typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : {};\nconst importIdentifier = \"__ $YJS$ __\";\nif (glo[importIdentifier] === true) {\n    /**\n   * Dear reader of this message. Please take this seriously.\n   *\n   * If you see this message, make sure that you only import one version of Yjs. In many cases,\n   * your package manager installs two versions of Yjs that are used by different packages within your project.\n   * Another reason for this message is that some parts of your project use the commonjs version of Yjs\n   * and others use the EcmaScript version of Yjs.\n   *\n   * This often leads to issues that are hard to debug. We often need to perform constructor checks,\n   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to\n   * do the constructor checks anymore - which might break the CRDT algorithm.\n   *\n   * https://github.com/yjs/yjs/issues/438\n   */ console.error(\"Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438\");\n}\nglo[importIdentifier] = true;\n //# sourceMappingURL=yjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveWpzL2Rpc3QveWpzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUNUO0FBQ0Y7QUFDRjtBQUNVO0FBQ0E7QUFDSjtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0g7QUFDSztBQUNSO0FBQ1E7QUFDTjtBQUNJO0FBQ0k7QUFDSjtBQUV0Qzs7Ozs7OztDQU9DLEdBQ0QsTUFBTW1CLDBCQUEwQm5CLHVEQUFVQTtJQUN4Qzs7O0dBR0MsR0FDRG9CLFlBQWFDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQzVCLEtBQUs7UUFDTCxJQUFJLENBQUNDLEdBQUcsR0FBR0Y7UUFDWCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDbkI7QUFDRjtBQUVBLE1BQU1FO0lBQ0o7OztHQUdDLEdBQ0RKLFlBQWFLLEtBQUssRUFBRUMsR0FBRyxDQUFFO1FBQ3ZCOztLQUVDLEdBQ0QsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2I7O0tBRUMsR0FDRCxJQUFJLENBQUNDLEdBQUcsR0FBR0E7SUFDYjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsTUFBTUM7SUFDSlAsYUFBZTtRQUNiOztLQUVDLEdBQ0QsSUFBSSxDQUFDUSxPQUFPLEdBQUcsSUFBSUM7SUFDckI7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUMsd0JBQXdCLENBQUNDLGFBQWFDLElBQUlyQixJQUM5Q3FCLEdBQUdKLE9BQU8sQ0FBQ0ssT0FBTyxDQUFDLENBQUNDLFNBQVNDO1FBQzNCLE1BQU1DLFVBQVUsMkJBQTJCLEdBQUlMLFlBQVlSLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDVCxPQUFPLENBQUNVLEdBQUcsQ0FBQ0g7UUFDakYsSUFBSyxJQUFJSSxJQUFJLEdBQUdB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V0FBVyxFQUFFNFIsTUFBTSxFQUFFO1FBQzlCLG9DQUFvQztRQUNwQ2xULHNEQUFvQjtJQUN0QjtJQUVBOzs7R0FHQyxHQUNEd1EsTUFBT2hNLE9BQU8sRUFBRTBPLE1BQU0sRUFBRTtRQUN0QjFPLFFBQVE0SixTQUFTLENBQUM0c0I7UUFDbEIsK0VBQStFO1FBQy9FcjdCLHVEQUFxQixDQUFDNkUsUUFBUUUsV0FBVyxFQUFFLElBQUksQ0FBQzNDLE1BQU0sR0FBR21SO0lBQzNEO0lBRUE7Ozs7R0FJQyxHQUNERSxXQUFZOVIsV0FBVyxFQUFFTSxLQUFLLEVBQUU7UUFDOUIsT0FBTztJQUNUO0FBQ0Y7QUFFQSx1QkFBdUIsR0FHdkIsTUFBTXE1QixNQUFNLGdCQUFnQixHQUFJLE9BQU9DLGVBQWUsY0FDbERBLGFBQ0EsTUFBa0IsR0FDaEJDLENBQU1BLEdBRU4sT0FBT0MsV0FBVyxjQUFjQSxTQUFTLENBQUM7QUFFaEQsTUFBTUMsbUJBQW1CO0FBRXpCLElBQUlKLEdBQUcsQ0FBQ0ksaUJBQWlCLEtBQUssTUFBTTtJQUNsQzs7Ozs7Ozs7Ozs7OztHQWFDLEdBQ0RqbEIsUUFBUXBXLEtBQUssQ0FBQztBQUNoQjtBQUNBaTdCLEdBQUcsQ0FBQ0ksaUJBQWlCLEdBQUc7QUFFMm9ELENBQ25xRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZS1qb3VybmFsLy4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanM/ODg0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJztcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknO1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnO1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJztcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnO1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZyc7XG5pbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20nO1xuaW1wb3J0ICogYXMgcHJvbWlzZSBmcm9tICdsaWIwL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJ2xpYjAvYnVmZmVyJztcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InO1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJ2xpYjAvYmluYXJ5JztcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbic7XG5pbXBvcnQgeyBjYWxsQWxsIH0gZnJvbSAnbGliMC9mdW5jdGlvbic7XG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnbGliMC9zZXQnO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICdsaWIwL2xvZ2dpbmcnO1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnO1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJ2xpYjAvc3RyaW5nJztcbmltcG9ydCAqIGFzIGl0ZXJhdG9yIGZyb20gJ2xpYjAvaXRlcmF0b3InO1xuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJ2xpYjAvb2JqZWN0JztcblxuLyoqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSB0aGF0IGFsbCBDb25uZWN0b3JzIHNob3VsZCBpbXBsZW1lbnQgdG8ga2VlcCB0aGVtIGludGVyY2hhbmdlYWJsZS5cbiAqXG4gKiBAbm90ZSBUaGlzIGludGVyZmFjZSBpcyBleHBlcmltZW50YWwgYW5kIGl0IGlzIG5vdCBhZHZpc2VkIHRvIGFjdHVhbGx5IGluaGVyaXQgdGhpcyBjbGFzcy5cbiAqICAgICAgIEl0IGp1c3Qgc2VydmVzIGFzIHR5cGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxhbnk+fVxuICovXG5jbGFzcyBBYnN0cmFjdENvbm5lY3RvciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHlkb2NcbiAgICogQHBhcmFtIHthbnl9IGF3YXJlbmVzc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHlkb2MsIGF3YXJlbmVzcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSB5ZG9jO1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzO1xuICB9XG59XG5cbmNsYXNzIERlbGV0ZUl0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbG9jaywgbGVuKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5vIGxvbmdlciBtYWludGFpbiBhIERlbGV0ZVN0b3JlLiBEZWxldGVTZXQgaXMgYSB0ZW1wb3Jhcnkgb2JqZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqIC0gV2hlbiBjcmVhdGVkIGluIGEgdHJhbnNhY3Rpb24sIGl0IG11c3Qgb25seSBiZSBhY2Nlc3NlZCBhZnRlciBzb3J0aW5nLCBhbmQgbWVyZ2luZ1xuICogICAtIFRoaXMgRGVsZXRlU2V0IGlzIHNlbmQgdG8gb3RoZXIgY2xpZW50c1xuICogLSBXZSBkbyBub3QgY3JlYXRlIGEgRGVsZXRlU2V0IHdoZW4gd2Ugc2VuZCBhIHN5bmMgbWVzc2FnZS4gVGhlIERlbGV0ZVNldCBtZXNzYWdlIGlzIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBTdHJ1Y3RTdG9yZVxuICogLSBXZSByZWFkIGEgRGVsZXRlU2V0IGFzIHBhcnQgb2YgYSBzeW5jL3VwZGF0ZSBtZXNzYWdlLiBJbiB0aGlzIGNhc2UgdGhlIERlbGV0ZVNldCBpcyBhbHJlYWR5IHNvcnRlZCBhbmQgbWVyZ2VkLlxuICovXG5jbGFzcyBEZWxldGVTZXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8RGVsZXRlSXRlbT4+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0cyB0aGF0IHRoZSBEZWxldGVTZXQgZ2Mncy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBkcywgZikgPT5cbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVzLCBjbGllbnRpZCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudGlkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWwgPSBkZWxldGVzW2ldO1xuICAgICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0cnVjdHMsIGRlbC5jbG9jaywgZGVsLmxlbiwgZik7XG4gICAgfVxuICB9KTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PERlbGV0ZUl0ZW0+fSBkaXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhEUyA9IChkaXMsIGNsb2NrKSA9PiB7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gZGlzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgY29uc3QgbWlkaW5kZXggPSBtYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gICAgY29uc3QgbWlkID0gZGlzW21pZGluZGV4XTtcbiAgICBjb25zdCBtaWRjbG9jayA9IG1pZC5jbG9jaztcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbikge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNEZWxldGVkID0gKGRzLCBpZCkgPT4ge1xuICBjb25zdCBkaXMgPSBkcy5jbGllbnRzLmdldChpZC5jbGllbnQpO1xuICByZXR1cm4gZGlzICE9PSB1bmRlZmluZWQgJiYgZmluZEluZGV4RFMoZGlzLCBpZC5jbG9jaykgIT09IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBzb3J0QW5kTWVyZ2VEZWxldGVTZXQgPSBkcyA9PiB7XG4gIGRzLmNsaWVudHMuZm9yRWFjaChkZWxzID0+IHtcbiAgICBkZWxzLnNvcnQoKGEsIGIpID0+IGEuY2xvY2sgLSBiLmNsb2NrKTtcbiAgICAvLyBtZXJnZSBpdGVtcyB3aXRob3V0IGZpbHRlcmluZyBvciBzcGxpY2luZyB0aGUgYXJyYXlcbiAgICAvLyBpIGlzIHRoZSBjdXJyZW50IHBvaW50ZXJcbiAgICAvLyBqIHJlZmVycyB0byB0aGUgY3VycmVudCBpbnNlcnQgcG9zaXRpb24gZm9yIHRoZSBwb2ludGVkIGl0ZW1cbiAgICAvLyB0cnkgdG8gbWVyZ2UgZGVsc1tpXSBpbnRvIGRlbHNbai0xXSBvciBzZXQgZGVsc1tqXT1kZWxzW2ldXG4gICAgbGV0IGksIGo7XG4gICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gZGVsc1tqIC0gMV07XG4gICAgICBjb25zdCByaWdodCA9IGRlbHNbaV07XG4gICAgICBpZiAobGVmdC5jbG9jayArIGxlZnQubGVuID49IHJpZ2h0LmNsb2NrKSB7XG4gICAgICAgIGxlZnQubGVuID0gbWF0aC5tYXgobGVmdC5sZW4sIHJpZ2h0LmNsb2NrICsgcmlnaHQubGVuIC0gbGVmdC5jbG9jayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaiA8IGkpIHtcbiAgICAgICAgICBkZWxzW2pdID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxzLmxlbmd0aCA9IGo7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PERlbGV0ZVNldD59IGRzc1xuICogQHJldHVybiB7RGVsZXRlU2V0fSBBIGZyZXNoIERlbGV0ZVNldFxuICovXG5jb25zdCBtZXJnZURlbGV0ZVNldHMgPSBkc3MgPT4ge1xuICBjb25zdCBtZXJnZWQgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGZvciAobGV0IGRzc0kgPSAwOyBkc3NJIDwgZHNzLmxlbmd0aDsgZHNzSSsrKSB7XG4gICAgZHNzW2Rzc0ldLmNsaWVudHMuZm9yRWFjaCgoZGVsc0xlZnQsIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKCFtZXJnZWQuY2xpZW50cy5oYXMoY2xpZW50KSkge1xuICAgICAgICAvLyBXcml0ZSBhbGwgbWlzc2luZyBrZXlzIGZyb20gY3VycmVudCBkcyBhbmQgYWxsIGZvbGxvd2luZy5cbiAgICAgICAgLy8gSWYgbWVyZ2VkIGFscmVhZHkgY29udGFpbnMgYGNsaWVudGAgY3VycmVudCBkcyBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLlxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVscyA9IGRlbHNMZWZ0LnNsaWNlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBkc3NJICsgMTsgaSA8IGRzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFycmF5LmFwcGVuZFRvKGRlbHMsIGRzc1tpXS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQuY2xpZW50cy5zZXQoY2xpZW50LCBkZWxzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQobWVyZ2VkKTtcbiAgcmV0dXJuIG1lcmdlZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYWRkVG9EZWxldGVTZXQgPSAoZHMsIGNsaWVudCwgY2xvY2ssIGxlbmd0aCkgPT4ge1xuICBtYXAuc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiAvKiogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fSAqLyAoW10pKS5wdXNoKG5ldyBEZWxldGVJdGVtKGNsb2NrLCBsZW5ndGgpKTtcbn07XG5cbmNvbnN0IGNyZWF0ZURlbGV0ZVNldCA9ICgpID0+IG5ldyBEZWxldGVTZXQoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzc1xuICogQHJldHVybiB7RGVsZXRlU2V0fSBNZXJnZWQgYW5kIHNvcnRlZCBEZWxldGVTZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSA9IHNzID0+IHtcbiAgY29uc3QgZHMgPSBjcmVhdGVEZWxldGVTZXQoKTtcbiAgc3MuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICovXG4gICAgY29uc3QgZHNpdGVtcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpXTtcbiAgICAgIGlmIChzdHJ1Y3QuZGVsZXRlZCkge1xuICAgICAgICBjb25zdCBjbG9jayA9IHN0cnVjdC5pZC5jbG9jaztcbiAgICAgICAgbGV0IGxlbiA9IHN0cnVjdC5sZW5ndGg7XG4gICAgICAgIGlmIChpICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgbmV4dCA9IHN0cnVjdHNbaSArIDFdOyBpICsgMSA8IHN0cnVjdHMubGVuZ3RoICYmIG5leHQuZGVsZXRlZDsgbmV4dCA9IHN0cnVjdHNbKytpICsgMV0pIHtcbiAgICAgICAgICAgIGxlbiArPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZHNpdGVtcy5wdXNoKG5ldyBEZWxldGVJdGVtKGNsb2NrLCBsZW4pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRzaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgZHMuY2xpZW50cy5zZXQoY2xpZW50LCBkc2l0ZW1zKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZHNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlRGVsZXRlU2V0ID0gKGVuY29kZXIsIGRzKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBkcy5jbGllbnRzLnNpemUpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBkZWxldGUgc2V0IGlzIHdyaXR0ZW4gaW4gYSBkZXRlcm1pbmlzdGljIG9yZGVyXG4gIGFycmF5LmZyb20oZHMuY2xpZW50cy5lbnRyaWVzKCkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKVxuICAgIC5mb3JFYWNoKChbY2xpZW50LCBkc2l0ZW1zXSkgPT4ge1xuICAgICAgZW5jb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KTtcbiAgICAgIGNvbnN0IGxlbiA9IGRzaXRlbXMubGVuZ3RoO1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkc2l0ZW1zW2ldO1xuICAgICAgICBlbmNvZGVyLndyaXRlRHNDbG9jayhpdGVtLmNsb2NrKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZURzTGVuKGl0ZW0ubGVuKTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkRGVsZXRlU2V0ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGRzID0gbmV3IERlbGV0ZVNldCgpO1xuICBjb25zdCBudW1DbGllbnRzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xpZW50czsgaSsrKSB7XG4gICAgZGVjb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgaWYgKG51bWJlck9mRGVsZXRlcyA+IDApIHtcbiAgICAgIGNvbnN0IGRzRmllbGQgPSBtYXAuc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiAvKiogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fSAqLyAoW10pKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgICAgZHNGaWVsZC5wdXNoKG5ldyBEZWxldGVJdGVtKGRlY29kZXIucmVhZERzQ2xvY2soKSwgZGVjb2Rlci5yZWFkRHNMZW4oKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZHNcbn07XG5cbi8qKlxuICogQHRvZG8gWURlY29kZXIgYWxzbyBjb250YWlucyByZWZlcmVuY2VzIHRvIFN0cmluZyBhbmQgb3RoZXIgRGVjb2RlcnMuIFdvdWxkIG1ha2Ugc2Vuc2UgdG8gZXhjaGFuZ2UgWURlY29kZXIudG9VaW50OEFycmF5IGZvciBZRGVjb2Rlci5Ec1RvVWludDhBcnJheSgpLi5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fG51bGx9IFJldHVybnMgYSB2MiB1cGRhdGUgY29udGFpbmluZyBhbGwgZGVsZXRlcyB0aGF0IGNvdWxkbid0IGJlIGFwcGxpZWQgeWV0OyBvciBudWxsIGlmIGFsbCBkZWxldGVzIHdlcmUgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkQW5kQXBwbHlEZWxldGVTZXQgPSAoZGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKSA9PiB7XG4gIGNvbnN0IHVuYXBwbGllZERTID0gbmV3IERlbGV0ZVNldCgpO1xuICBjb25zdCBudW1DbGllbnRzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xpZW50czsgaSsrKSB7XG4gICAgZGVjb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICBjb25zdCBjbG9jayA9IGRlY29kZXIucmVhZERzQ2xvY2soKTtcbiAgICAgIGNvbnN0IGNsb2NrRW5kID0gY2xvY2sgKyBkZWNvZGVyLnJlYWREc0xlbigpO1xuICAgICAgaWYgKGNsb2NrIDwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldCh1bmFwcGxpZWREUywgY2xpZW50LCBzdGF0ZSwgY2xvY2tFbmQgLSBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgY2FuIGlnbm9yZSB0aGUgY2FzZSBvZiBHQyBhbmQgRGVsZXRlIHN0cnVjdHMsIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIHNraXAgdGhlbVxuICAgICAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICAgICAgICAvLyBzcGxpdCB0aGUgZmlyc3QgaXRlbSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jaykge1xuICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgICAgICAgaW5kZXgrKzsgLy8gaW5jcmVhc2Ugd2Ugbm93IHdhbnQgdG8gdXNlIHRoZSBuZXh0IHN0cnVjdFxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbaW5kZXgrK107XG4gICAgICAgICAgaWYgKHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrRW5kKSB7XG4gICAgICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrRW5kIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RydWN0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUb0RlbGV0ZVNldCh1bmFwcGxpZWREUywgY2xpZW50LCBjbG9jaywgY2xvY2tFbmQgLSBjbG9jayk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh1bmFwcGxpZWREUy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZHMgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGRzLnJlc3RFbmNvZGVyLCAwKTsgLy8gZW5jb2RlIDAgc3RydWN0c1xuICAgIHdyaXRlRGVsZXRlU2V0KGRzLCB1bmFwcGxpZWREUyk7XG4gICAgcmV0dXJuIGRzLnRvVWludDhBcnJheSgpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzMVxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzMlxuICovXG5jb25zdCBlcXVhbERlbGV0ZVNldHMgPSAoZHMxLCBkczIpID0+IHtcbiAgaWYgKGRzMS5jbGllbnRzLnNpemUgIT09IGRzMi5jbGllbnRzLnNpemUpIHJldHVybiBmYWxzZVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRlbGV0ZUl0ZW1zMV0gb2YgZHMxLmNsaWVudHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZGVsZXRlSXRlbXMyID0gLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFscy5qcycpLkRlbGV0ZUl0ZW0+fSAqLyAoZHMyLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGlmIChkZWxldGVJdGVtczIgPT09IHVuZGVmaW5lZCB8fCBkZWxldGVJdGVtczEubGVuZ3RoICE9PSBkZWxldGVJdGVtczIubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZUl0ZW1zMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGkxID0gZGVsZXRlSXRlbXMxW2ldO1xuICAgICAgY29uc3QgZGkyID0gZGVsZXRlSXRlbXMyW2ldO1xuICAgICAgaWYgKGRpMS5jbG9jayAhPT0gZGkyLmNsb2NrIHx8IGRpMS5sZW4gIT09IGRpMi5sZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBtb2R1bGUgWVxuICovXG5cblxuY29uc3QgZ2VuZXJhdGVOZXdDbGllbnRJZCA9IHJhbmRvbS51aW50MzI7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRG9jT3B0c1xuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5nYz10cnVlXSBEaXNhYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiAoZGVmYXVsdDogZ2M9dHJ1ZSlcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gW0RvY09wdHMuZ2NGaWx0ZXJdIFdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhbiBJdGVtIGlzIGdhcmJhZ2UgY29sbGVjdGVkLiBSZXR1cm4gZmFsc2UgdG8ga2VlcCB0aGUgSXRlbS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRG9jT3B0cy5ndWlkXSBEZWZpbmUgYSBnbG9iYWxseSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBkb2N1bWVudFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSBbRG9jT3B0cy5jb2xsZWN0aW9uaWRdIEFzc29jaWF0ZSB0aGlzIGRvY3VtZW50IHdpdGggYSBjb2xsZWN0aW9uLiBUaGlzIG9ubHkgcGxheXMgYSByb2xlIGlmIHlvdXIgcHJvdmlkZXIgaGFzIGEgY29uY2VwdCBvZiBjb2xsZWN0aW9uLlxuICogQHByb3BlcnR5IHthbnl9IFtEb2NPcHRzLm1ldGFdIEFueSBraW5kIG9mIG1ldGEgaW5mb3JtYXRpb24geW91IHdhbnQgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkb2N1bWVudC4gSWYgdGhpcyBpcyBhIHN1YmRvY3VtZW50LCByZW1vdGUgcGVlcnMgd2lsbCBzdG9yZSB0aGUgbWV0YSBpbmZvcm1hdGlvbiBhcyB3ZWxsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5hdXRvTG9hZF0gSWYgYSBzdWJkb2N1bWVudCwgYXV0b21hdGljYWxseSBsb2FkIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIGxvYWQgdGhlIGRvY3VtZW50IGFzIHdlbGwgYXV0b21hdGljYWxseS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuc2hvdWxkTG9hZF0gV2hldGhlciB0aGUgZG9jdW1lbnQgc2hvdWxkIGJlIHN5bmNlZCBieSB0aGUgcHJvdmlkZXIgbm93LiBUaGlzIGlzIHRvZ2dsZWQgdG8gdHJ1ZSB3aGVuIHlvdSBjYWxsIHlkb2MubG9hZCgpXG4gKi9cblxuLyoqXG4gKiBBIFlqcyBpbnN0YW5jZSBoYW5kbGVzIHRoZSBzdGF0ZSBvZiBzaGFyZWQgZGF0YS5cbiAqIEBleHRlbmRzIE9ic2VydmFibGU8c3RyaW5nPlxuICovXG5jbGFzcyBEb2MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jT3B0c30gb3B0cyBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBndWlkID0gcmFuZG9tLnV1aWR2NCgpLCBjb2xsZWN0aW9uaWQgPSBudWxsLCBnYyA9IHRydWUsIGdjRmlsdGVyID0gKCkgPT4gdHJ1ZSwgbWV0YSA9IG51bGwsIGF1dG9Mb2FkID0gZmFsc2UsIHNob3VsZExvYWQgPSB0cnVlIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5nYyA9IGdjO1xuICAgIHRoaXMuZ2NGaWx0ZXIgPSBnY0ZpbHRlcjtcbiAgICB0aGlzLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpO1xuICAgIHRoaXMuZ3VpZCA9IGd1aWQ7XG4gICAgdGhpcy5jb2xsZWN0aW9uaWQgPSBjb2xsZWN0aW9uaWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4+fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcmUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBTdHJ1Y3RTdG9yZSgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbiB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3MgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBkb2N1bWVudCBpcyBhIHN1YmRvY3VtZW50IC0gYSBkb2N1bWVudCBpbnRlZ3JhdGVkIGludG8gYW5vdGhlciBkb2N1bWVudCAtIHRoZW4gX2l0ZW0gaXMgZGVmaW5lZC5cbiAgICAgKiBAdHlwZSB7SXRlbT99XG4gICAgICovXG4gICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgdGhpcy5zaG91bGRMb2FkID0gc2hvdWxkTG9hZDtcbiAgICB0aGlzLmF1dG9Mb2FkID0gYXV0b0xvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNldCB0byB0cnVlIHdoZW4gdGhlIHBlcnNpc3RlbmNlIHByb3ZpZGVyIGxvYWRlZCB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2Ugb3Igd2hlbiB0aGUgYHN5bmNgIGV2ZW50IGZpcmVzLlxuICAgICAqIE5vdGUgdGhhdCBub3QgYWxsIHByb3ZpZGVycyBpbXBsZW1lbnQgdGhpcyBmZWF0dXJlLiBQcm92aWRlciBhdXRob3JzIGFyZSBlbmNvdXJhZ2VkIHRvIGZpcmUgdGhlIGBsb2FkYCBldmVudCB3aGVuIHRoZSBkb2MgY29udGVudCBpcyBsb2FkZWQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBjb25uZWN0aW9uIHByb3ZpZGVyIGhhcyBzdWNjZXNzZnVsbHkgc3luY2VkIHdpdGggYSBiYWNrZW5kLlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHVzaW5nIHBlZXItdG8tcGVlciBwcm92aWRlcnMgdGhpcyBldmVudCBtYXkgbm90IHByb3ZpZGUgdmVyeSB1c2VmdWwuXG4gICAgICogQWxzbyBub3RlIHRoYXQgbm90IGFsbCBwcm92aWRlcnMgaW1wbGVtZW50IHRoaXMgZmVhdHVyZS4gUHJvdmlkZXIgYXV0aG9ycyBhcmUgZW5jb3VyYWdlZCB0byBmaXJlXG4gICAgICogdGhlIGBzeW5jYCBldmVudCB3aGVuIHRoZSBkb2MgaGFzIGJlZW4gc3luY2VkICh3aXRoIGB0cnVlYCBhcyBhIHBhcmFtZXRlcikgb3IgaWYgY29ubmVjdGlvbiBpc1xuICAgICAqIGxvc3QgKHdpdGggZmFsc2UgYXMgYSBwYXJhbWV0ZXIpLlxuICAgICAqL1xuICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gbG9hZGVkIGZyb20gYSBwcmVzaXN0ZW5jZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICB0aGlzLndoZW5Mb2FkZWQgPSBwcm9taXNlLmNyZWF0ZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcHJvdmlkZVN5bmNlZFByb21pc2UgPSAoKSA9PiBwcm9taXNlLmNyZWF0ZShyZXNvbHZlID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1N5bmNlZFxuICAgICAgICovXG4gICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoaXNTeW5jZWQpID0+IHtcbiAgICAgICAgaWYgKGlzU3luY2VkID09PSB1bmRlZmluZWQgfHwgaXNTeW5jZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm9mZignc3luYycsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignc3luYycsIGV2ZW50SGFuZGxlcik7XG4gICAgfSk7XG4gICAgdGhpcy5vbignc3luYycsIGlzU3luY2VkID0+IHtcbiAgICAgIGlmIChpc1N5bmNlZCA9PT0gZmFsc2UgJiYgdGhpcy5pc1N5bmNlZCkge1xuICAgICAgICB0aGlzLndoZW5TeW5jZWQgPSBwcm92aWRlU3luY2VkUHJvbWlzZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1N5bmNlZCA9IGlzU3luY2VkID09PSB1bmRlZmluZWQgfHwgaXNTeW5jZWQgPT09IHRydWU7XG4gICAgICBpZiAodGhpcy5pc1N5bmNlZCAmJiAhdGhpcy5pc0xvYWRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2xvYWQnLCBbXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIHN5bmNlZCB3aXRoIGEgYmFja2VuZC5cbiAgICAgKiBUaGlzIHByb21pc2UgaXMgcmVjcmVhdGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgbG9zdC5cbiAgICAgKiBOb3RlIHRoZSBkb2N1bWVudGF0aW9uIGFib3V0IHRoZSBgaXNTeW5jZWRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMud2hlblN5bmNlZCA9IHByb3ZpZGVTeW5jZWRQcm9taXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBwYXJlbnQgZG9jdW1lbnQgdGhhdCB5b3UgcmVxdWVzdCB0byBsb2FkIGRhdGEgaW50byB0aGlzIHN1YmRvY3VtZW50IChpZiBpdCBpcyBhIHN1YmRvY3VtZW50KS5cbiAgICpcbiAgICogYGxvYWQoKWAgbWlnaHQgYmUgdXNlZCBpbiB0aGUgZnV0dXJlIHRvIHJlcXVlc3QgYW55IHByb3ZpZGVyIHRvIGxvYWQgdGhlIG1vc3QgY3VycmVudCBkYXRhLlxuICAgKlxuICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgYGxvYWQoKWAgbXVsdGlwbGUgdGltZXMuXG4gICAqL1xuICBsb2FkICgpIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbTtcbiAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiAhdGhpcy5zaG91bGRMb2FkKSB7XG4gICAgICB0cmFuc2FjdCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0ucGFyZW50KS5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZC5hZGQodGhpcyk7XG4gICAgICB9LCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5zaG91bGRMb2FkID0gdHJ1ZTtcbiAgfVxuXG4gIGdldFN1YmRvY3MgKCkge1xuICAgIHJldHVybiB0aGlzLnN1YmRvY3NcbiAgfVxuXG4gIGdldFN1YmRvY0d1aWRzICgpIHtcbiAgICByZXR1cm4gbmV3IFNldChhcnJheS5mcm9tKHRoaXMuc3ViZG9jcykubWFwKGRvYyA9PiBkb2MuZ3VpZCkpXG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGF0IGhhcHBlbiBpbnNpZGUgb2YgYSB0cmFuc2FjdGlvbiBhcmUgYnVuZGxlZC4gVGhpcyBtZWFucyB0aGF0XG4gICAqIHRoZSBvYnNlcnZlciBmaXJlcyBfYWZ0ZXJfIHRoZSB0cmFuc2FjdGlvbiBpcyBmaW5pc2hlZCBhbmQgdGhhdCBhbGwgY2hhbmdlc1xuICAgKiB0aGF0IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgdHJhbnNhY3Rpb24gYXJlIHNlbnQgYXMgb25lIG1lc3NhZ2UgdG8gdGhlXG4gICAqIG90aGVyIHBlZXJzLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTpUfSBmIFRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7YW55fSBbb3JpZ2luXSBPcmlnaW4gb2Ygd2hvIHN0YXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLiBXaWxsIGJlIHN0b3JlZCBvbiB0cmFuc2FjdGlvbi5vcmlnaW5cbiAgICogQHJldHVybiBUXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRyYW5zYWN0IChmLCBvcmlnaW4gPSBudWxsKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0KHRoaXMsIGYsIG9yaWdpbilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBzaGFyZWQgZGF0YSB0eXBlLlxuICAgKlxuICAgKiBNdWx0aXBsZSBjYWxscyBvZiBgeS5nZXQobmFtZSwgVHlwZUNvbnN0cnVjdG9yKWAgeWllbGQgdGhlIHNhbWUgcmVzdWx0XG4gICAqIGFuZCBkbyBub3Qgb3ZlcndyaXRlIGVhY2ggb3RoZXIuIEkuZS5cbiAgICogYHkuZGVmaW5lKG5hbWUsIFkuQXJyYXkpID09PSB5LmRlZmluZShuYW1lLCBZLkFycmF5KWBcbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgdHlwZSBpcyBhbHNvIGF2YWlsYWJsZSBvbiBgeS5zaGFyZS5nZXQobmFtZSlgLlxuICAgKlxuICAgKiAqQmVzdCBQcmFjdGljZXM6KlxuICAgKiBEZWZpbmUgYWxsIHR5cGVzIHJpZ2h0IGFmdGVyIHRoZSBZanMgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgc3RvcmUgdGhlbSBpbiBhIHNlcGFyYXRlIG9iamVjdC5cbiAgICogQWxzbyB1c2UgdGhlIHR5cGVkIG1ldGhvZHMgYGdldFRleHQobmFtZSlgLCBgZ2V0QXJyYXkobmFtZSlgLCAuLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3R5cGVvZiBBYnN0cmFjdFR5cGU8YW55Pn0gVHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbnN0IHkgPSBuZXcgWSguLilcbiAgICogICBjb25zdCBhcHBTdGF0ZSA9IHtcbiAgICogICAgIGRvY3VtZW50OiB5LmdldFRleHQoJ2RvY3VtZW50JylcbiAgICogICAgIGNvbW1lbnRzOiB5LmdldEFycmF5KCdjb21tZW50cycpXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1R5cGV9IFR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHR5cGUgZGVmaW5pdGlvbi4gRS5nLiBZLlRleHQsIFkuQXJyYXksIFkuTWFwLCAuLi5cbiAgICogQHJldHVybiB7SW5zdGFuY2VUeXBlPFR5cGU+fSBUaGUgY3JlYXRlZCB0eXBlLiBDb25zdHJ1Y3RlZCB3aXRoIFR5cGVDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgKG5hbWUsIFR5cGVDb25zdHJ1Y3RvciA9IC8qKiBAdHlwZSB7YW55fSAqLyAoQWJzdHJhY3RUeXBlKSkge1xuICAgIGNvbnN0IHR5cGUgPSBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5zaGFyZSwgbmFtZSwgKCkgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKTtcbiAgICAgIHQuX2ludGVncmF0ZSh0aGlzLCBudWxsKTtcbiAgICAgIHJldHVybiB0XG4gICAgfSk7XG4gICAgY29uc3QgQ29uc3RyID0gdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZUNvbnN0cnVjdG9yICE9PSBBYnN0cmFjdFR5cGUgJiYgQ29uc3RyICE9PSBUeXBlQ29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChDb25zdHIgPT09IEFic3RyYWN0VHlwZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHQgPSBuZXcgVHlwZUNvbnN0cnVjdG9yKCk7XG4gICAgICAgIHQuX21hcCA9IHR5cGUuX21hcDtcbiAgICAgICAgdHlwZS5fbWFwLmZvckVhY2goLyoqIEBwYXJhbSB7SXRlbT99IG4gKi8gbiA9PiB7XG4gICAgICAgICAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLmxlZnQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG4ucGFyZW50ID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0Ll9zdGFydCA9IHR5cGUuX3N0YXJ0O1xuICAgICAgICBmb3IgKGxldCBuID0gdC5fc3RhcnQ7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgICAgICAgbi5wYXJlbnQgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHQuX2xlbmd0aCA9IHR5cGUuX2xlbmd0aDtcbiAgICAgICAgdGhpcy5zaGFyZS5zZXQobmFtZSwgdCk7XG4gICAgICAgIHQuX2ludGVncmF0ZSh0aGlzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SW5zdGFuY2VUeXBlPFR5cGU+fSAqLyAodClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSB3aXRoIHRoZSBuYW1lICR7bmFtZX0gaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIHdpdGggYSBkaWZmZXJlbnQgY29uc3RydWN0b3JgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtJbnN0YW5jZVR5cGU8VHlwZT59ICovICh0eXBlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBcnJheSAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7WUFycmF5PFQ+fSAqLyAodGhpcy5nZXQobmFtZSwgWUFycmF5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRUZXh0IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVRleHQpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZTWFwPFQ+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRNYXAgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiAvKiogQHR5cGUge1lNYXA8VD59ICovICh0aGlzLmdldChuYW1lLCBZTWFwKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRYbWxFbGVtZW50IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtZWG1sRWxlbWVudDx7W2tleTpzdHJpbmddOnN0cmluZ30+fSAqLyAodGhpcy5nZXQobmFtZSwgWVhtbEVsZW1lbnQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRYbWxGcmFnbWVudCAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlYbWxGcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZW50aXJlIGRvY3VtZW50IGludG8gYSBqcyBvYmplY3QsIHJlY3Vyc2l2ZWx5IHRyYXZlcnNpbmcgZWFjaCB5anMgdHlwZVxuICAgKiBEb2Vzbid0IGxvZyB0eXBlcyB0aGF0IGhhdmUgbm90IGJlZW4gZGVmaW5lZCAodXNpbmcgeWRvYy5nZXRUeXBlKC4uKSkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgYW5kIHJhdGhlciBjYWxsIHRvSlNPTiBkaXJlY3RseSBvbiB0aGUgc2hhcmVkIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkb2MgPSB7fTtcblxuICAgIHRoaXMuc2hhcmUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgZG9jW2tleV0gPSB2YWx1ZS50b0pTT04oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGBkZXN0cm95YCBldmVudCBhbmQgdW5yZWdpc3RlciBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBhcnJheS5mcm9tKHRoaXMuc3ViZG9jcykuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW07XG4gICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgICAgY29uc3QgY29udGVudCA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGl0ZW0uY29udGVudCk7XG4gICAgICBjb250ZW50LmRvYyA9IG5ldyBEb2MoeyBndWlkOiB0aGlzLmd1aWQsIC4uLmNvbnRlbnQub3B0cywgc2hvdWxkTG9hZDogZmFsc2UgfSk7XG4gICAgICBjb250ZW50LmRvYy5faXRlbSA9IGl0ZW07XG4gICAgICB0cmFuc2FjdCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudC5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gY29udGVudC5kb2M7XG4gICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZChkb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3llZCcsIFt0cnVlXSk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueSk6YW55fSBmXG4gICAqL1xuICBvbiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub24oZXZlbnROYW1lLCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgZik7XG4gIH1cbn1cblxuY2xhc3MgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyO1xuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRGVjb2RlclYxIGV4dGVuZHMgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVWludDgodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzS2V5XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5jb3B5VWludDhBcnJheShkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWdhY3kgaW1wbGVtZW50YXRpb24gdXNlcyBKU09OIHBhcnNlLiBXZSB1c2UgYW55LWRlY29kaW5nIGluIHYyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG59XG5cbmNsYXNzIERTRGVjb2RlclYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlcjtcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2Rlcik7XG4gICAgcmV0dXJuIHRoaXMuZHNDdXJyVmFsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICBjb25zdCBkaWZmID0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgKyAxO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRpZmY7XG4gICAgcmV0dXJuIGRpZmZcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVEZWNvZGVyVjIgZXh0ZW5kcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgc3VwZXIoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjYWNoZWQga2V5cy4gSWYgdGhlIGtleXNbaWRdIGRvZXMgbm90IGV4aXN0LCB3ZSByZWFkIGEgbmV3IGtleVxuICAgICAqIGZyb20gc3RyaW5nRW5jb2RlciBhbmQgcHVzaCBpdCB0byBrZXlzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlcik7IC8vIHJlYWQgZmVhdHVyZSBmbGFnIC0gY3VycmVudGx5IHVudXNlZFxuICAgIHRoaXMua2V5Q2xvY2tEZWNvZGVyID0gbmV3IGRlY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmNsaWVudERlY29kZXIgPSBuZXcgZGVjb2RpbmcuVWludE9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMubGVmdENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5yaWdodENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5pbmZvRGVjb2RlciA9IG5ldyBkZWNvZGluZy5SbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVWludDgpO1xuICAgIHRoaXMuc3RyaW5nRGVjb2RlciA9IG5ldyBkZWNvZGluZy5TdHJpbmdEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLnBhcmVudEluZm9EZWNvZGVyID0gbmV3IGRlY29kaW5nLlJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIGRlY29kaW5nLnJlYWRVaW50OCk7XG4gICAgdGhpcy50eXBlUmVmRGVjb2RlciA9IG5ldyBkZWNvZGluZy5VaW50T3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5sZW5EZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRMZWZ0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5sZWZ0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRSaWdodElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMucmlnaHRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIG5leHQgY2xpZW50IGlkLlxuICAgKiBVc2UgdGhpcyBpbiBmYXZvciBvZiByZWFkSUQgd2hlbmV2ZXIgcG9zc2libGUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZENsaWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuaW5mb0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRTdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ0RlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlYWRQYXJlbnRJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRJbmZvRGVjb2Rlci5yZWFkKCkgPT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlUmVmRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkTGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5EZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRBbnkgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIHJlYWRCdWYgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgY29uc3Qga2V5Q2xvY2sgPSB0aGlzLmtleUNsb2NrRGVjb2Rlci5yZWFkKCk7XG4gICAgaWYgKGtleUNsb2NrIDwgdGhpcy5rZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5c1trZXlDbG9ja11cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5zdHJpbmdEZWNvZGVyLnJlYWQoKTtcbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIERTRW5jb2RlclYxIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcilcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIC8vIG5vcFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbik7XG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRW5jb2RlclYxIGV4dGVuZHMgRFNFbmNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlTGVmdElEIChpZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlUmlnaHRJRCAoaWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB3cml0ZUNsaWVudCBhbmQgd3JpdGVDbG9jayBpbnN0ZWFkIG9mIHdyaXRlSUQgaWYgcG9zc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KHRoaXMucmVzdEVuY29kZXIsIGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpc1lLZXkgPyAxIDogMCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVUeXBlUmVmIChpbmZvKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBlbWJlZFxuICAgKi9cbiAgd3JpdGVKU09OIChlbWJlZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIEpTT04uc3RyaW5naWZ5KGVtYmVkKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIGtleSk7XG4gIH1cbn1cblxuY2xhc3MgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTsgLy8gZW5jb2RlcyBhbGwgdGhlIHJlc3QgLyBub24tb3B0aW1pemVkXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgY29uc3QgZGlmZiA9IGNsb2NrIC0gdGhpcy5kc0N1cnJWYWw7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSBjbG9jaztcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgZGlmZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICB9XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbiAtIDEpO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGxlbjtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVFbmNvZGVyVjIgZXh0ZW5kcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogUmVmZXJzIHRvIHRoZSBuZXh0IHVuaXFlIGtleS1pZGVudGlmaWVyIHRvIG1lIHVzZWQuXG4gICAgICogU2VlIHdyaXRlS2V5IG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5rZXlDbG9jayA9IDA7XG4gICAgdGhpcy5rZXlDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5pbmZvRW5jb2RlciA9IG5ldyBlbmNvZGluZy5SbGVFbmNvZGVyKGVuY29kaW5nLndyaXRlVWludDgpO1xuICAgIHRoaXMuc3RyaW5nRW5jb2RlciA9IG5ldyBlbmNvZGluZy5TdHJpbmdFbmNvZGVyKCk7XG4gICAgdGhpcy5wYXJlbnRJbmZvRW5jb2RlciA9IG5ldyBlbmNvZGluZy5SbGVFbmNvZGVyKGVuY29kaW5nLndyaXRlVWludDgpO1xuICAgIHRoaXMudHlwZVJlZkVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmxlbkVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKTtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMCk7IC8vIHRoaXMgaXMgYSBmZWF0dXJlIGZsYWcgdGhhdCB3ZSBtaWdodCB1c2UgaW4gdGhlIGZ1dHVyZVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmtleUNsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMuY2xpZW50RW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVmdENsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMucmlnaHRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5pbmZvRW5jb2RlcikpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnN0cmluZ0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5wYXJlbnRJbmZvRW5jb2RlcikpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnR5cGVSZWZFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5FbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICAvLyBAbm90ZSBUaGUgcmVzdCBlbmNvZGVyIGlzIGFwcGVuZGVkISAobm90ZSB0aGUgbWlzc2luZyB2YXIpXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OEFycmF5KGVuY29kZXIsIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKSk7XG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZUxlZnRJRCAoaWQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoaWQuY2xpZW50KTtcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZVJpZ2h0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudCk7XG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2Rlci53cml0ZShpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKi9cbiAgd3JpdGVDbGllbnQgKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShjbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlSW5mbyAoaW5mbykge1xuICAgIHRoaXMuaW5mb0VuY29kZXIud3JpdGUoaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICovXG4gIHdyaXRlU3RyaW5nIChzKSB7XG4gICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIud3JpdGUoaXNZS2V5ID8gMSA6IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlVHlwZVJlZiAoaW5mbykge1xuICAgIHRoaXMudHlwZVJlZkVuY29kZXIud3JpdGUoaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVMZW4gKGxlbikge1xuICAgIHRoaXMubGVuRW5jb2Rlci53cml0ZShsZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhbnlcbiAgICovXG4gIHdyaXRlQW55IChhbnkpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqL1xuICB3cml0ZUJ1ZiAoYnVmKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgKlxuICAgKiBJbml0aWFsIHdlIGluY29kZWQgb2JqZWN0cyB1c2luZyBKU09OLiBOb3cgd2UgdXNlIHRoZSBtdWNoIGZhc3RlciBsaWIwL2FueS1lbmNvZGVyLiBUaGlzIG1ldGhvZCBtYWlubHkgZXhpc3RzIGZvciBsZWdhY3kgcHVycG9zZXMgZm9yIHRoZSB2MSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZW1iZWRcbiAgICovXG4gIHdyaXRlSlNPTiAoZW1iZWQpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBlbWJlZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvcGVydHkga2V5cyBhcmUgb2Z0ZW4gcmV1c2VkLiBGb3IgZXhhbXBsZSwgaW4geS1wcm9zZW1pcnJvciB0aGUga2V5IGBib2xkYCBtaWdodFxuICAgKiBvY2N1ciB2ZXJ5IG9mdGVuLiBGb3IgYSAzZCBhcHBsaWNhdGlvbiwgdGhlIGtleSBgcG9zaXRpb25gIG1pZ2h0IG9jY3VyIHZlcnkgb2Z0ZW4uXG4gICAqXG4gICAqIFdlIGNhY2hlIHRoZXNlIGtleXMgaW4gYSBNYXAgYW5kIHJlZmVyIHRvIHRoZW0gdmlhIGEgdW5pcXVlIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGNvbnN0IGNsb2NrID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgaWYgKGNsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHRvZG8gdW5jb21tZW50IHRvIGludHJvZHVjZSB0aGlzIGZlYXR1cmUgZmluYWxseVxuICAgICAgICpcbiAgICAgICAqIEJhY2tncm91bmQuIFRoZSBDb250ZW50Rm9ybWF0IG9iamVjdCB3YXMgYWx3YXlzIGVuY29kZWQgdXNpbmcgd3JpdGVLZXksIGJ1dCB0aGUgZGVjb2RlciB1c2VkIHRvIHVzZSByZWFkU3RyaW5nLlxuICAgICAgICogRnVydGhlcm1vcmUsIEkgZm9yZ290IHRvIHNldCB0aGUga2V5Y2xvY2suIFNvIGV2ZXJ5dGhpbmcgd2FzIHdvcmtpbmcgZmluZS5cbiAgICAgICAqXG4gICAgICAgKiBIb3dldmVyLCB0aGlzIGZlYXR1cmUgaGVyZSBpcyBiYXNpY2FsbHkgdXNlbGVzcyBhcyBpdCBpcyBub3QgYmVpbmcgdXNlZCAoaXQgYWN0dWFsbHkgb25seSBjb25zdW1lcyBleHRyYSBtZW1vcnkpLlxuICAgICAgICpcbiAgICAgICAqIEkgZG9uJ3Qga25vdyB5ZXQgaG93IHRvIHJlaW50cm9kdWNlIHRoaXMgZmVhdHVyZS4uXG4gICAgICAgKlxuICAgICAgICogT2xkZXIgY2xpZW50cyB3b24ndCBiZSBhYmxlIHRvIHJlYWQgdXBkYXRlcyB3aGVuIHdlIHJlaW50cm9kdWNlIHRoaXMgZmVhdHVyZS4gU28gdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSB1c2luZyBhIGZsYWcuXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICAvLyB0aGlzLmtleU1hcC5zZXQoa2V5LCB0aGlzLmtleUNsb2NrKVxuICAgICAgdGhpcy5rZXlDbG9ja0VuY29kZXIud3JpdGUodGhpcy5rZXlDbG9jaysrKTtcbiAgICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZShjbG9jayk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG4vKlxuICogV2UgdXNlIHRoZSBmaXJzdCBmaXZlIGJpdHMgaW4gdGhlIGluZm8gZmxhZyBmb3IgZGV0ZXJtaW5pbmcgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdC5cbiAqXG4gKiAwOiBHQ1xuICogMTogSXRlbSB3aXRoIERlbGV0ZWQgY29udGVudFxuICogMjogSXRlbSB3aXRoIEpTT04gY29udGVudFxuICogMzogSXRlbSB3aXRoIEJpbmFyeSBjb250ZW50XG4gKiA0OiBJdGVtIHdpdGggU3RyaW5nIGNvbnRlbnRcbiAqIDU6IEl0ZW0gd2l0aCBFbWJlZCBjb250ZW50IChmb3IgcmljaHRleHQgY29udGVudClcbiAqIDY6IEl0ZW0gd2l0aCBGb3JtYXQgY29udGVudCAoYSBmb3JtYXR0aW5nIG1hcmtlciBmb3IgcmljaHRleHQgY29udGVudClcbiAqIDc6IEl0ZW0gd2l0aCBUeXBlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0FycmF5PEdDfEl0ZW0+fSBzdHJ1Y3RzIEFsbCBzdHJ1Y3RzIGJ5IGBjbGllbnRgXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgd3JpdGUgc3RydWN0cyBzdGFydGluZyB3aXRoIGBJRChjbGllbnQsY2xvY2spYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHMgPSAoZW5jb2Rlciwgc3RydWN0cywgY2xpZW50LCBjbG9jaykgPT4ge1xuICAvLyB3cml0ZSBmaXJzdCBpZFxuICBjbG9jayA9IG1hdGgubWF4KGNsb2NrLCBzdHJ1Y3RzWzBdLmlkLmNsb2NrKTsgLy8gbWFrZSBzdXJlIHRoZSBmaXJzdCBpZCBleGlzdHNcbiAgY29uc3Qgc3RhcnROZXdTdHJ1Y3RzID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spO1xuICAvLyB3cml0ZSAjIGVuY29kZWQgc3RydWN0c1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3RydWN0cy5sZW5ndGggLSBzdGFydE5ld1N0cnVjdHMpO1xuICBlbmNvZGVyLndyaXRlQ2xpZW50KGNsaWVudCk7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIGNvbnN0IGZpcnN0U3RydWN0ID0gc3RydWN0c1tzdGFydE5ld1N0cnVjdHNdO1xuICAvLyB3cml0ZSBmaXJzdCBzdHJ1Y3Qgd2l0aCBhbiBvZmZzZXRcbiAgZmlyc3RTdHJ1Y3Qud3JpdGUoZW5jb2RlciwgY2xvY2sgLSBmaXJzdFN0cnVjdC5pZC5jbG9jayk7XG4gIGZvciAobGV0IGkgPSBzdGFydE5ld1N0cnVjdHMgKyAxOyBpIDwgc3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIHN0cnVjdHNbaV0ud3JpdGUoZW5jb2RlciwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gX3NtXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZUNsaWVudHNTdHJ1Y3RzID0gKGVuY29kZXIsIHN0b3JlLCBfc20pID0+IHtcbiAgLy8gd2UgZmlsdGVyIGFsbCB2YWxpZCBfc20gZW50cmllcyBpbnRvIHNtXG4gIGNvbnN0IHNtID0gbmV3IE1hcCgpO1xuICBfc20uZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIC8vIG9ubHkgd3JpdGUgaWYgbmV3IHN0cnVjdHMgYXJlIGF2YWlsYWJsZVxuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSA+IGNsb2NrKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCBjbG9jayk7XG4gICAgfVxuICB9KTtcbiAgZ2V0U3RhdGVWZWN0b3Ioc3RvcmUpLmZvckVhY2goKF9jbG9jaywgY2xpZW50KSA9PiB7XG4gICAgaWYgKCFfc20uaGFzKGNsaWVudCkpIHtcbiAgICAgIHNtLnNldChjbGllbnQsIDApO1xuICAgIH1cbiAgfSk7XG4gIC8vIHdyaXRlICMgc3RhdGVzIHRoYXQgd2VyZSB1cGRhdGVkXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzbS5zaXplKTtcbiAgLy8gV3JpdGUgaXRlbXMgd2l0aCBoaWdoZXIgY2xpZW50IGlkcyBmaXJzdFxuICAvLyBUaGlzIGhlYXZpbHkgaW1wcm92ZXMgdGhlIGNvbmZsaWN0IGFsZ29yaXRobS5cbiAgYXJyYXkuZnJvbShzbS5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKS5mb3JFYWNoKChbY2xpZW50LCBjbG9ja10pID0+IHtcbiAgICB3cml0ZVN0cnVjdHMoZW5jb2RlciwgLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpLCBjbGllbnQsIGNsb2NrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZENsaWVudHNTdHJ1Y3RSZWZzID0gKGRlY29kZXIsIGRvYykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICAgKi9cbiAgY29uc3QgY2xpZW50UmVmcyA9IG1hcC5jcmVhdGUoKTtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IHJlZnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZTdHJ1Y3RzKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKTtcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAvLyBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY2xpZW50UmVmcy5zZXQoY2xpZW50LCB7IGk6IDAsIHJlZnMgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIHN3aXRjaCAoYmluYXJ5LkJJVFM1ICYgaW5mbykge1xuICAgICAgICBjYXNlIDA6IHsgLy8gR0NcbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHsgLy8gU2tpcCBTdHJ1Y3QgKG5vdGhpbmcgdG8gYXBwbHkpXG4gICAgICAgICAgLy8gQHRvZG8gd2UgY291bGQgcmVkdWNlIHRoZSBhbW91bnQgb2YgY2hlY2tzIGJ5IGFkZGluZyBTa2lwIHN0cnVjdCB0byBjbGllbnRSZWZzIHNvIHdlIGtub3cgdGhhdCBzb21ldGhpbmcgaXMgbWlzc2luZy5cbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogeyAvLyBJdGVtIHdpdGggY29udGVudFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAgICogQmVsb3cgYSBub24tb3B0aW1pemVkIHZlcnNpb24gaXMgc2hvd24gdGhhdCBpbXBsZW1lbnRzIHRoZSBiYXNpYyBhbGdvcml0aG0gd2l0aFxuICAgICAgICAgICAqIGEgZmV3IGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwO1xuICAgICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICAvKiBBIG5vbi1vcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobTpcblxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbFxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICBjb25zdCBoYXNQYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvID8gZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpIDogZmFsc2VcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvICYmIGhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGxcblxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgb3JpZ2luLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICByaWdodE9yaWdpbiwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgIWhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IChwYXJlbnRZS2V5ICE9PSBudWxsID8gZG9jLmdldChwYXJlbnRZS2V5KSA6IG51bGwpLCAvLyBwYXJlbnRcbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgICAqL1xuICAgICAgICAgIHJlZnNbaV0gPSBzdHJ1Y3Q7XG4gICAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgfVxuICByZXR1cm4gY2xpZW50UmVmc1xufTtcblxuLyoqXG4gKiBSZXN1bWUgY29tcHV0aW5nIHN0cnVjdHMgZ2VuZXJhdGVkIGJ5IHN0cnVjdCByZWFkZXJzLlxuICpcbiAqIFdoaWxlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbywgd2UgaW50ZWdyYXRlIHN0cnVjdHMgaW4gdGhpcyBvcmRlclxuICogMS4gdG9wIGVsZW1lbnQgb24gc3RhY2ssIGlmIHN0YWNrIGlzIG5vdCBlbXB0eVxuICogMi4gbmV4dCBlbGVtZW50IGZyb20gY3VycmVudCBzdHJ1Y3QgcmVhZGVyIChpZiBlbXB0eSwgdXNlIG5leHQgc3RydWN0IHJlYWRlcilcbiAqXG4gKiBJZiBzdHJ1Y3QgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHN0cnVjdCAocmVmLm1pc3NpbmcpLCB3ZSBwdXQgbmV4dCByZWFkZXIgb2ZcbiAqIGByZWYuaWQuY2xpZW50YCBvbiB0b3Agb2Ygc3RhY2suXG4gKlxuICogQXQgc29tZSBwb2ludCB3ZSBmaW5kIGEgc3RydWN0IHRoYXQgaGFzIG5vIGNhdXNhbCBkZXBlbmRlbmNpZXMsXG4gKiB0aGVuIHdlIHN0YXJ0IGVtcHR5aW5nIHRoZSBzdGFjay5cbiAqXG4gKiBJdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSBjaXJjbGVzOiBpLmUuIHN0cnVjdDEgKGZyb20gY2xpZW50MSkgZGVwZW5kcyBvbiBzdHJ1Y3QyIChmcm9tIGNsaWVudDIpXG4gKiBkZXBlbmRzIG9uIHN0cnVjdDMgKGZyb20gY2xpZW50MSkuIFRoZXJlZm9yZSB0aGUgbWF4IHN0YWNrIHNpemUgaXMgZXFhdWwgdG8gYHN0cnVjdFJlYWRlcnMubGVuZ3RoYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCBpbiBhIHdheSBzbyB0aGF0IHdlIGNhbiByZXN1bWUgY29tcHV0YXRpb24gaWYgdGhpcyB1cGRhdGVcbiAqIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiAoR0MgfCBJdGVtKVtdIH0+fSBjbGllbnRzU3RydWN0UmVmc1xuICogQHJldHVybiB7IG51bGwgfCB7IHVwZGF0ZTogVWludDhBcnJheSwgbWlzc2luZzogTWFwPG51bWJlcixudW1iZXI+IH0gfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW50ZWdyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGNsaWVudHNTdHJ1Y3RSZWZzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbSB8IEdDPn1cbiAgICovXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIC8vIHNvcnQgdGhlbSBzbyB0aGF0IHdlIHRha2UgdGhlIGhpZ2hlciBpZCBmaXJzdCwgaW4gY2FzZSBvZiBjb25mbGljdHMgdGhlIGxvd2VyIGlkIHdpbGwgcHJvYmFibHkgbm90IGNvbmZsaWN0IHdpdGggdGhlIGlkIGZyb20gdGhlIGhpZ2hlciB1c2VyLlxuICBsZXQgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBhcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBnZXROZXh0U3RydWN0VGFyZ2V0ID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGxldCBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSk7XG4gICAgd2hpbGUgKG5leHRTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoID09PSBuZXh0U3RydWN0c1RhcmdldC5pKSB7XG4gICAgICBjbGllbnRzU3RydWN0UmVmc0lkcy5wb3AoKTtcbiAgICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RydWN0c1RhcmdldFxuICB9O1xuICBsZXQgY3VyU3RydWN0c1RhcmdldCA9IGdldE5leHRTdHJ1Y3RUYXJnZXQoKTtcbiAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJ1Y3RTdG9yZX1cbiAgICovXG4gIGNvbnN0IHJlc3RTdHJ1Y3RzID0gbmV3IFN0cnVjdFN0b3JlKCk7XG4gIGNvbnN0IG1pc3NpbmdTViA9IG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICBjb25zdCB1cGRhdGVNaXNzaW5nU3YgPSAoY2xpZW50LCBjbG9jaykgPT4ge1xuICAgIGNvbnN0IG1jbG9jayA9IG1pc3NpbmdTVi5nZXQoY2xpZW50KTtcbiAgICBpZiAobWNsb2NrID09IG51bGwgfHwgbWNsb2NrID4gY2xvY2spIHtcbiAgICAgIG1pc3NpbmdTVi5zZXQoY2xpZW50LCBjbG9jayk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHR5cGUge0dDfEl0ZW19XG4gICAqL1xuICBsZXQgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHthbnl9ICovIChjdXJTdHJ1Y3RzVGFyZ2V0KS5yZWZzWy8qKiBAdHlwZSB7YW55fSAqLyAoY3VyU3RydWN0c1RhcmdldCkuaSsrXTtcbiAgLy8gY2FjaGluZyB0aGUgc3RhdGUgYmVjYXVzZSBpdCBpcyB1c2VkIHZlcnkgb2Z0ZW5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgTWFwKCk7XG5cbiAgY29uc3QgYWRkU3RhY2tUb1Jlc3RTUyA9ICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RhY2spIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IGl0ZW0uaWQuY2xpZW50O1xuICAgICAgY29uc3QgdW5hcHBsaWNhYmxlSXRlbXMgPSBjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50KTtcbiAgICAgIGlmICh1bmFwcGxpY2FibGVJdGVtcykge1xuICAgICAgICAvLyBkZWNyZW1lbnQgYmVjYXVzZSB3ZSB3ZXJlbid0IGFibGUgdG8gYXBwbHkgcHJldmlvdXMgb3BlcmF0aW9uXG4gICAgICAgIHVuYXBwbGljYWJsZUl0ZW1zLmktLTtcbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCB1bmFwcGxpY2FibGVJdGVtcy5yZWZzLnNsaWNlKHVuYXBwbGljYWJsZUl0ZW1zLmkpKTtcbiAgICAgICAgY2xpZW50c1N0cnVjdFJlZnMuZGVsZXRlKGNsaWVudCk7XG4gICAgICAgIHVuYXBwbGljYWJsZUl0ZW1zLmkgPSAwO1xuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5yZWZzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpdGVtIHdhcyB0aGUgbGFzdCBpdGVtIG9uIGNsaWVudHNTdHJ1Y3RSZWZzIGFuZCB0aGUgZmllbGQgd2FzIGFscmVhZHkgY2xlYXJlZC4gQWRkIGl0ZW0gdG8gcmVzdFN0cnVjdHMgYW5kIGNvbnRpbnVlXG4gICAgICAgIHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2V0KGNsaWVudCwgW2l0ZW1dKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBjbGllbnQgZnJvbSBjbGllbnRzU3RydWN0UmVmc0lkcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gYXBwbHlpbmcgdGhlIHNhbWUgdXBkYXRlIGFnYWluXG4gICAgICBjbGllbnRzU3RydWN0UmVmc0lkcyA9IGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmZpbHRlcihjID0+IGMgIT09IGNsaWVudCk7XG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBzdHJ1Y3QgcmVhZGVycyB1bnRpbCB3ZSBhcmUgZG9uZVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChzdGFja0hlYWQuY29uc3RydWN0b3IgIT09IFNraXApIHtcbiAgICAgIGNvbnN0IGxvY2FsQ2xvY2sgPSBtYXAuc2V0SWZVbmRlZmluZWQoc3RhdGUsIHN0YWNrSGVhZC5pZC5jbGllbnQsICgpID0+IGdldFN0YXRlKHN0b3JlLCBzdGFja0hlYWQuaWQuY2xpZW50KSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBsb2NhbENsb2NrIC0gc3RhY2tIZWFkLmlkLmNsb2NrO1xuICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgLy8gdXBkYXRlIGZyb20gdGhlIHNhbWUgY2xpZW50IGlzIG1pc3NpbmdcbiAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgICB1cGRhdGVNaXNzaW5nU3Yoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrIC0gMSk7XG4gICAgICAgIC8vIGhpZCBhIGRlYWQgd2FsbCwgYWRkIGFsbCBpdGVtcyBmcm9tIHN0YWNrIHRvIHJlc3RTU1xuICAgICAgICBhZGRTdGFja1RvUmVzdFNTKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gc3RhY2tIZWFkLmdldE1pc3NpbmcodHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICAgICAgaWYgKG1pc3NpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrSGVhZCk7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBzdHJ1Y3QgcmVhZGVyIHRoYXQgaGFzIHRoZSBtaXNzaW5nIHN0cnVjdFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHt7IHJlZnM6IEFycmF5PEdDfEl0ZW0+LCBpOiBudW1iZXIgfX1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBzdHJ1Y3RSZWZzID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZykpIHx8IHsgcmVmczogW10sIGk6IDAgfTtcbiAgICAgICAgICBpZiAoc3RydWN0UmVmcy5yZWZzLmxlbmd0aCA9PT0gc3RydWN0UmVmcy5pKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBtZXNzYWdlIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUgbWVzc2FnZSB0aGF0IGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgICB1cGRhdGVNaXNzaW5nU3YoLyoqIEB0eXBlIHtudW1iZXJ9ICovIChtaXNzaW5nKSwgZ2V0U3RhdGUoc3RvcmUsIG1pc3NpbmcpKTtcbiAgICAgICAgICAgIGFkZFN0YWNrVG9SZXN0U1MoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhY2tIZWFkID0gc3RydWN0UmVmcy5yZWZzW3N0cnVjdFJlZnMuaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PT0gMCB8fCBvZmZzZXQgPCBzdGFja0hlYWQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gYWxsIGZpbmUsIGFwcGx5IHRoZSBzdGFja2hlYWRcbiAgICAgICAgICBzdGFja0hlYWQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCBvZmZzZXQpO1xuICAgICAgICAgIHN0YXRlLnNldChzdGFja0hlYWQuaWQuY2xpZW50LCBzdGFja0hlYWQuaWQuY2xvY2sgKyBzdGFja0hlYWQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpdGVyYXRlIHRvIG5leHQgc3RhY2tIZWFkXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKHN0YWNrLnBvcCgpKTtcbiAgICB9IGVsc2UgaWYgKGN1clN0cnVjdHNUYXJnZXQgIT09IG51bGwgJiYgY3VyU3RydWN0c1RhcmdldC5pIDwgY3VyU3RydWN0c1RhcmdldC5yZWZzLmxlbmd0aCkge1xuICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoY3VyU3RydWN0c1RhcmdldC5yZWZzW2N1clN0cnVjdHNUYXJnZXQuaSsrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1clN0cnVjdHNUYXJnZXQgPSBnZXROZXh0U3RydWN0VGFyZ2V0KCk7XG4gICAgICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAvLyB3ZSBhcmUgZG9uZSFcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVzdFN0cnVjdHMuY2xpZW50cy5zaXplID4gMCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCByZXN0U3RydWN0cywgbmV3IE1hcCgpKTtcbiAgICAvLyB3cml0ZSBlbXB0eSBkZWxldGVzZXRcbiAgICAvLyB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBuZXcgRGVsZXRlU2V0KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApOyAvLyA9PiBubyBuZWVkIGZvciBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLCBqdXN0IHdyaXRlIDAgZGVsZXRlc1xuICAgIHJldHVybiB7IG1pc3Npbmc6IG1pc3NpbmdTViwgdXBkYXRlOiBlbmNvZGVyLnRvVWludDhBcnJheSgpIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbiA9IChlbmNvZGVyLCB0cmFuc2FjdGlvbikgPT4gd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCB0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlKTtcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhbiBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IFtzdHJ1Y3REZWNvZGVyXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkVXBkYXRlVjIgPSAoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIHN0cnVjdERlY29kZXIgPSBuZXcgVXBkYXRlRGVjb2RlclYyKGRlY29kZXIpKSA9PlxuICB0cmFuc2FjdCh5ZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgLy8gZm9yY2UgdGhhdCB0cmFuc2FjdGlvbi5sb2NhbCBpcyBzZXQgdG8gbm9uLWxvY2FsXG4gICAgdHJhbnNhY3Rpb24ubG9jYWwgPSBmYWxzZTtcbiAgICBsZXQgcmV0cnkgPSBmYWxzZTtcbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgLy8gbGV0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCBzcyA9IHJlYWRDbGllbnRzU3RydWN0UmVmcyhzdHJ1Y3REZWNvZGVyLCBkb2MpO1xuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlYWQgc3RydWN0czogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIG1lcmdlOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3QgcmVzdFN0cnVjdHMgPSBpbnRlZ3JhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdG9yZSwgc3MpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBzdG9yZS5wZW5kaW5nU3RydWN0cztcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIGFwcGx5IHNvbWV0aGluZ1xuICAgICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2YgcGVuZGluZy5taXNzaW5nKSB7XG4gICAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgICAgcmV0cnkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN0U3RydWN0cykge1xuICAgICAgICAvLyBtZXJnZSByZXN0U3RydWN0cyBpbnRvIHN0b3JlLnBlbmRpbmdcbiAgICAgICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2YgcmVzdFN0cnVjdHMubWlzc2luZykge1xuICAgICAgICAgIGNvbnN0IG1jbG9jayA9IHBlbmRpbmcubWlzc2luZy5nZXQoY2xpZW50KTtcbiAgICAgICAgICBpZiAobWNsb2NrID09IG51bGwgfHwgbWNsb2NrID4gY2xvY2spIHtcbiAgICAgICAgICAgIHBlbmRpbmcubWlzc2luZy5zZXQoY2xpZW50LCBjbG9jayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmcudXBkYXRlID0gbWVyZ2VVcGRhdGVzVjIoW3BlbmRpbmcudXBkYXRlLCByZXN0U3RydWN0cy51cGRhdGVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmUucGVuZGluZ1N0cnVjdHMgPSByZXN0U3RydWN0cztcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gaW50ZWdyYXRlOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3QgZHNSZXN0ID0gcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHN0cnVjdERlY29kZXIsIHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gICAgaWYgKHN0b3JlLnBlbmRpbmdEcykge1xuICAgICAgLy8gQHRvZG8gd2UgY291bGQgbWFrZSBhIGxvd2VyLWJvdW5kIHN0YXRlLXZlY3RvciBjaGVjayBhcyB3ZSBkbyBhYm92ZVxuICAgICAgY29uc3QgcGVuZGluZ0RTVXBkYXRlID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHN0b3JlLnBlbmRpbmdEcykpO1xuICAgICAgZGVjb2RpbmcucmVhZFZhclVpbnQocGVuZGluZ0RTVXBkYXRlLnJlc3REZWNvZGVyKTsgLy8gcmVhZCAwIHN0cnVjdHMsIGJlY2F1c2Ugd2Ugb25seSBlbmNvZGUgZGVsZXRlcyBpbiBwZW5kaW5nZHN1cGRhdGVcbiAgICAgIGNvbnN0IGRzUmVzdDIgPSByZWFkQW5kQXBwbHlEZWxldGVTZXQocGVuZGluZ0RTVXBkYXRlLCB0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICAgICAgaWYgKGRzUmVzdCAmJiBkc1Jlc3QyKSB7XG4gICAgICAgIC8vIGNhc2UgMTogZHMxICE9IG51bGwgJiYgZHMyICE9IG51bGxcbiAgICAgICAgc3RvcmUucGVuZGluZ0RzID0gbWVyZ2VVcGRhdGVzVjIoW2RzUmVzdCwgZHNSZXN0Ml0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FzZSAyOiBkczEgIT0gbnVsbFxuICAgICAgICAvLyBjYXNlIDM6IGRzMiAhPSBudWxsXG4gICAgICAgIC8vIGNhc2UgNDogZHMxID09IG51bGwgJiYgZHMyID09IG51bGxcbiAgICAgICAgc3RvcmUucGVuZGluZ0RzID0gZHNSZXN0IHx8IGRzUmVzdDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVpdGhlciBkc1Jlc3QgPT0gbnVsbCAmJiBwZW5kaW5nRHMgPT0gbnVsbCBPUiBkc1Jlc3QgIT0gbnVsbFxuICAgICAgc3RvcmUucGVuZGluZ0RzID0gZHNSZXN0O1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBjbGVhbnVwOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZXN1bWUgZGVsZXRlIHJlYWRlcnM6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBpZiAocmV0cnkpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IC8qKiBAdHlwZSB7e3VwZGF0ZTogVWludDhBcnJheX19ICovIChzdG9yZS5wZW5kaW5nU3RydWN0cykudXBkYXRlO1xuICAgICAgc3RvcmUucGVuZGluZ1N0cnVjdHMgPSBudWxsO1xuICAgICAgYXBwbHlVcGRhdGVWMih0cmFuc2FjdGlvbi5kb2MsIHVwZGF0ZSk7XG4gICAgfVxuICB9LCB0cmFuc2FjdGlvbk9yaWdpbiwgZmFsc2UpO1xuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgYXBwbHlVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRVcGRhdGUgPSAoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHJlYWRVcGRhdGVWMihkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgbmV3IFVwZGF0ZURlY29kZXJWMShkZWNvZGVyKSk7XG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYXBwbHlVcGRhdGVWMiA9ICh5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpO1xuICByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBZRGVjb2RlcihkZWNvZGVyKSk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlIGNyZWF0ZWQgYnksIGZvciBleGFtcGxlLCBgeS5vbigndXBkYXRlJywgdXBkYXRlID0+IC4uKWAgb3IgYHVwZGF0ZSA9IGVuY29kZVN0YXRlQXNVcGRhdGUoKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGByZWFkVXBkYXRlYCBidXQgYWNjZXB0cyBhbiBVaW50OEFycmF5IGluc3RlYWQgb2YgYSBEZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFwcGx5VXBkYXRlID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4pID0+IGFwcGx5VXBkYXRlVjIoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlLiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZVZlY3RvcmApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IFt0YXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0YXRlQXNVcGRhdGUgPSAoZW5jb2RlciwgZG9jLCB0YXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBNYXAoKSkgPT4ge1xuICB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIGRvYy5zdG9yZSwgdGFyZ2V0U3RhdGVWZWN0b3IpO1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUoZG9jLnN0b3JlKSk7XG59O1xuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgYXBwbGllZCBvbiB0aGUgcmVtb3RlIGRvY3VtZW50LiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZWApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBVc2UgYHdyaXRlU3RhdGVBc1VwZGF0ZWAgaW5zdGVhZCBpZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBsaWIwL2VuY29kaW5nLmpzI0VuY29kZXJcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGVWMiA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBVaW50OEFycmF5KFswXSksIGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCkpID0+IHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVWZWN0b3IgPSBkZWNvZGVTdGF0ZVZlY3RvcihlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpO1xuICB3cml0ZVN0YXRlQXNVcGRhdGUoZW5jb2RlciwgZG9jLCB0YXJnZXRTdGF0ZVZlY3Rvcik7XG4gIGNvbnN0IHVwZGF0ZXMgPSBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV07XG4gIC8vIGFsc28gYWRkIHRoZSBwZW5kaW5nIHVwZGF0ZXMgKGlmIHRoZXJlIGFyZSBhbnkpXG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgdXBkYXRlcy5wdXNoKGRvYy5zdG9yZS5wZW5kaW5nRHMpO1xuICB9XG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMpIHtcbiAgICB1cGRhdGVzLnB1c2goZGlmZlVwZGF0ZVYyKGRvYy5zdG9yZS5wZW5kaW5nU3RydWN0cy51cGRhdGUsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvcikpO1xuICB9XG4gIGlmICh1cGRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoZW5jb2Rlci5jb25zdHJ1Y3RvciA9PT0gVXBkYXRlRW5jb2RlclYxKSB7XG4gICAgICByZXR1cm4gbWVyZ2VVcGRhdGVzKHVwZGF0ZXMubWFwKCh1cGRhdGUsIGkpID0+IGkgPT09IDAgPyB1cGRhdGUgOiBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxKHVwZGF0ZSkpKVxuICAgIH0gZWxzZSBpZiAoZW5jb2Rlci5jb25zdHJ1Y3RvciA9PT0gVXBkYXRlRW5jb2RlclYyKSB7XG4gICAgICByZXR1cm4gbWVyZ2VVcGRhdGVzVjIodXBkYXRlcylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXNbMF1cbn07XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVBc1VwZGF0ZSA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvcikgPT4gZW5jb2RlU3RhdGVBc1VwZGF0ZVYyKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yLCBuZXcgVXBkYXRlRW5jb2RlclYxKCkpO1xuXG4vKipcbiAqIFJlYWQgc3RhdGUgdmVjdG9yIGZyb20gRGVjb2RlciBhbmQgcmV0dXJuIGFzIE1hcFxuICpcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRTdGF0ZVZlY3RvciA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBzcyA9IG5ldyBNYXAoKTtcbiAgY29uc3Qgc3NMZW5ndGggPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBzcy5zZXQoY2xpZW50LCBjbG9jayk7XG4gIH1cbiAgcmV0dXJuIHNzXG59O1xuXG4vKipcbiAqIFJlYWQgZGVjb2RlZFN0YXRlIGFuZCByZXR1cm4gU3RhdGUgYXMgTWFwLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGVjb2RlZFN0YXRlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGRlY29kZVN0YXRlVmVjdG9yVjIgPSBkZWNvZGVkU3RhdGUgPT4gcmVhZFN0YXRlVmVjdG9yKG5ldyBEU0RlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRlY29kZWRTdGF0ZSkpKVxuXG4vKipcbiAqIFJlYWQgZGVjb2RlZFN0YXRlIGFuZCByZXR1cm4gU3RhdGUgYXMgTWFwLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGVjb2RlZFN0YXRlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZGVjb2RlU3RhdGVWZWN0b3IgPSBkZWNvZGVkU3RhdGUgPT4gcmVhZFN0YXRlVmVjdG9yKG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRlY29kZWRTdGF0ZSkpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RhdGVWZWN0b3IgPSAoZW5jb2Rlciwgc3YpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN2LnNpemUpO1xuICBhcnJheS5mcm9tKHN2LmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlswXSAtIGFbMF0pLmZvckVhY2goKFtjbGllbnQsIGNsb2NrXSkgPT4ge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpOyAvLyBAdG9kbyB1c2UgYSBzcGVjaWFsIGNsaWVudCBkZWNvZGVyIHRoYXQgaXMgYmFzZWQgb24gbWFwcGluZ1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIH0pO1xuICByZXR1cm4gZW5jb2RlclxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yID0gKGVuY29kZXIsIGRvYykgPT4gd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yVjIgPSAoZG9jLCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKTtcbiAgfVxuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3IgPSBkb2MgPT4gZW5jb2RlU3RhdGVWZWN0b3JWMihkb2MsIG5ldyBEU0VuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBHZW5lcmFsIGV2ZW50IGhhbmRsZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsIEFSRzFcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKEFSRzAsIEFSRzEpOnZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMubCA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHJldHVybnMge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlRXZlbnRIYW5kbGVyID0gKCkgPT4gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlblxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNjYWxsRXZlbnRMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIgPSAoZXZlbnRIYW5kbGVyLCBmKSA9PlxuICBldmVudEhhbmRsZXIubC5wdXNoKGYpO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IHdhcyBhZGRlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT4ge1xuICBjb25zdCBsID0gZXZlbnRIYW5kbGVyLmw7XG4gIGNvbnN0IGxlbiA9IGwubGVuZ3RoO1xuICBldmVudEhhbmRsZXIubCA9IGwuZmlsdGVyKGcgPT4gZiAhPT0gZyk7XG4gIGlmIChsZW4gPT09IGV2ZW50SGFuZGxlci5sLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t5anNdIFRyaWVkIHRvIHJlbW92ZSBldmVudCBoYW5kbGVyIHRoYXQgZG9lc25cXCd0IGV4aXN0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYWxsIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdmlhXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtBUkcwfSBhcmcwXG4gKiBAcGFyYW0ge0FSRzF9IGFyZzFcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSAoZXZlbnRIYW5kbGVyLCBhcmcwLCBhcmcxKSA9PlxuICBmLmNhbGxBbGwoZXZlbnRIYW5kbGVyLmwsIFthcmcwLCBhcmcxXSk7XG5cbmNsYXNzIElEIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnQgY2xpZW50IGlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB1bmlxdWUgcGVyIGNsaWVudCBpZCwgY29udGludW91cyBudW1iZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbGllbnQsIGNsb2NrKSB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IGlkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAvKipcbiAgICAgKiB1bmlxdWUgcGVyIGNsaWVudCBpZCwgY29udGludW91cyBudW1iZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9jaztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SUQgfCBudWxsfSBhXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY29tcGFyZUlEcyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5jbGllbnQgPT09IGIuY2xpZW50ICYmIGEuY2xvY2sgPT09IGIuY2xvY2spO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlSUQgPSAoY2xpZW50LCBjbG9jaykgPT4gbmV3IElEKGNsaWVudCwgY2xvY2spO1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtJRH0gaWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlSUQgPSAoZW5jb2RlciwgaWQpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGlkLmNsaWVudCk7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbG9jayk7XG59O1xuXG4vKipcbiAqIFJlYWQgSUQuXG4gKiAqIElmIGZpcnN0IHZhclVpbnQgcmVhZCBpcyAweEZGRkZGRiBhIFJvb3RJRCBpcyByZXR1cm5lZC5cbiAqICogT3RoZXJ3aXNlIGFuIElEIGlzIHJldHVybmVkXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtJRH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRJRCA9IGRlY29kZXIgPT5cbiAgY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKTtcblxuLyoqXG4gKiBUaGUgdG9wIHR5cGVzIGFyZSBtYXBwZWQgZnJvbSB5LnNoYXJlLmdldChrZXluYW1lKSA9PiB0eXBlLlxuICogYHR5cGVgIGRvZXMgbm90IHN0b3JlIGFueSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGtleW5hbWVgLlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgY29ycmVjdCBga2V5bmFtZWAgZm9yIGB0eXBlYCBhbmQgdGhyb3dzIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kUm9vdFR5cGVLZXkgPSB0eXBlID0+IHtcbiAgLy8gQHRzLWlnbm9yZSBfeSBtdXN0IGJlIGRlZmluZWQsIG90aGVyd2lzZSB1bmV4cGVjdGVkIGNhc2VcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHlwZS5kb2Muc2hhcmUuZW50cmllcygpKSB7XG4gICAgaWYgKHZhbHVlID09PSB0eXBlKSB7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBjaGlsZFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQucGFyZW50KS5faXRlbTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8qKlxuICogQ29udmVuaWVudCBoZWxwZXIgdG8gbG9nIHR5cGUgaW5mb3JtYXRpb24uXG4gKlxuICogRG8gbm90IHVzZSBpbiBwcm9kdWN0aXZlIHN5c3RlbXMgYXMgdGhlIG91dHB1dCBjYW4gYmUgaW1tZW5zZSFcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKi9cbmNvbnN0IGxvZ1R5cGUgPSB0eXBlID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuKSB7XG4gICAgcmVzLnB1c2gobik7XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuOiAnLCByZXMpO1xuICBjb25zb2xlLmxvZygnQ2hpbGRyZW4gY29udGVudDogJywgcmVzLmZpbHRlcihtID0+ICFtLmRlbGV0ZWQpLm1hcChtID0+IG0uY29udGVudCkpO1xufTtcblxuY2xhc3MgUGVybWFuZW50VXNlckRhdGEge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gW3N0b3JlVHlwZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MsIHN0b3JlVHlwZSA9IGRvYy5nZXRNYXAoJ3VzZXJzJykpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxEZWxldGVTZXQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnl1c2VycyA9IHN0b3JlVHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50aWQgdG8gdXNlckRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRzcyA9IGRzcztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBjb25zdCBpbml0VXNlciA9ICh1c2VyLCB1c2VyRGVzY3JpcHRpb24pID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1lBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZHMgPSB1c2VyLmdldCgnZHMnKTtcbiAgICAgIGNvbnN0IGlkcyA9IHVzZXIuZ2V0KCdpZHMnKTtcbiAgICAgIGNvbnN0IGFkZENsaWVudElkID0gLyoqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZCAqLyBjbGllbnRpZCA9PiB0aGlzLmNsaWVudHMuc2V0KGNsaWVudGlkLCB1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuYWRkZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goZW5jb2RlZERzID0+IHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkRHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhbdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbikgfHwgY3JlYXRlRGVsZXRlU2V0KCksIHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kc3Muc2V0KHVzZXJEZXNjcmlwdGlvbiwgbWVyZ2VEZWxldGVTZXRzKGRzLm1hcChlbmNvZGVkRHMgPT4gcmVhZERlbGV0ZVNldChuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihlbmNvZGVkRHMpKSkpKSk7XG4gICAgICBpZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PlxuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goYWRkQ2xpZW50SWQpKVxuICAgICAgKTtcbiAgICAgIGlkcy5mb3JFYWNoKGFkZENsaWVudElkKTtcbiAgICB9O1xuICAgIC8vIG9ic2VydmUgdXNlcnNcbiAgICBzdG9yZVR5cGUub2JzZXJ2ZShldmVudCA9PiB7XG4gICAgICBldmVudC5rZXlzQ2hhbmdlZC5mb3JFYWNoKHVzZXJEZXNjcmlwdGlvbiA9PlxuICAgICAgICBpbml0VXNlcihzdG9yZVR5cGUuZ2V0KHVzZXJEZXNjcmlwdGlvbiksIHVzZXJEZXNjcmlwdGlvbilcbiAgICAgICk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGludGlhbCBkYXRhXG4gICAgc3RvcmVUeXBlLmZvckVhY2goaW5pdFVzZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRGVsZXRlU2V0KTpib29sZWFufSBbY29uZi5maWx0ZXJdXG4gICAqL1xuICBzZXRVc2VyTWFwcGluZyAoZG9jLCBjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uLCB7IGZpbHRlciA9ICgpID0+IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgdXNlcnMgPSB0aGlzLnl1c2VycztcbiAgICBsZXQgdXNlciA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdXNlciA9IG5ldyBZTWFwKCk7XG4gICAgICB1c2VyLnNldCgnaWRzJywgbmV3IFlBcnJheSgpKTtcbiAgICAgIHVzZXIuc2V0KCdkcycsIG5ldyBZQXJyYXkoKSk7XG4gICAgICB1c2Vycy5zZXQodXNlckRlc2NyaXB0aW9uLCB1c2VyKTtcbiAgICB9XG4gICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSk7XG4gICAgdXNlcnMub2JzZXJ2ZShfZXZlbnQgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJPdmVyd3JpdGUgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHVzZXJPdmVyd3JpdGUgIT09IHVzZXIpIHtcbiAgICAgICAgICAvLyB1c2VyIHdhcyBvdmVyd3JpdHRlbiwgcG9ydCBhbGwgZGF0YSBvdmVyIHRvIHRoZSBuZXh0IHVzZXIgb2JqZWN0XG4gICAgICAgICAgLy8gQHRvZG8gRXhwZXJpbWVudCB3aXRoIFkuU2V0cyBoZXJlXG4gICAgICAgICAgdXNlciA9IHVzZXJPdmVyd3JpdGU7XG4gICAgICAgICAgLy8gQHRvZG8gaXRlcmF0ZSBvdmVyIG9sZCB0eXBlXG4gICAgICAgICAgdGhpcy5jbGllbnRzLmZvckVhY2goKF91c2VyRGVzY3JpcHRpb24sIGNsaWVudGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAodXNlckRlc2NyaXB0aW9uID09PSBfdXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKTtcbiAgICAgICAgICBjb25zdCBkcyA9IHRoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgICAgIGlmIChkcykge1xuICAgICAgICAgICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICAgICAgICAgICAgdXNlci5nZXQoJ2RzJykucHVzaChbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gICAgZG9jLm9uKCdhZnRlclRyYW5zYWN0aW9uJywgLyoqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uICovIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB5ZHMgPSB1c2VyLmdldCgnZHMnKTtcbiAgICAgICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXQ7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5sb2NhbCAmJiBkcy5jbGllbnRzLnNpemUgPiAwICYmIGZpbHRlcih0cmFuc2FjdGlvbiwgZHMpKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMSgpO1xuICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgICAgICAgICB5ZHMucHVzaChbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWRcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZ2V0VXNlckJ5Q2xpZW50SWQgKGNsaWVudGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50cy5nZXQoY2xpZW50aWQpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgZ2V0VXNlckJ5RGVsZXRlZElkIChpZCkge1xuICAgIGZvciAoY29uc3QgW3VzZXJEZXNjcmlwdGlvbiwgZHNdIG9mIHRoaXMuZHNzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGlzRGVsZXRlZChkcywgaWQpKSB7XG4gICAgICAgIHJldHVybiB1c2VyRGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEEgcmVsYXRpdmUgcG9zaXRpb24gaXMgYmFzZWQgb24gdGhlIFlqcyBtb2RlbCBhbmQgaXMgbm90IGFmZmVjdGVkIGJ5IGRvY3VtZW50IGNoYW5nZXMuXG4gKiBFLmcuIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGJlZm9yZSBhIGNlcnRhaW4gY2hhcmFjdGVyLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGlzIGNoYXJhY3Rlci5cbiAqIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgYSB0eXBlLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGUgZW5kIG9mIHRoZSB0eXBlLlxuICpcbiAqIEEgbnVtZXJpYyBwb3NpdGlvbiBpcyBvZnRlbiB1bnN1aXRlZCBmb3IgdXNlciBzZWxlY3Rpb25zLCBiZWNhdXNlIGl0IGRvZXMgbm90IGNoYW5nZSB3aGVuIGNvbnRlbnQgaXMgaW5zZXJ0ZWRcbiAqIGJlZm9yZSBvciBhZnRlci5cbiAqXG4gKiBgYGBJbnNlcnQoMCwgJ3gnKSgnYXxiYycpID0gJ3hhfGJjJ2BgYCBXaGVyZSB8IGlzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiBPbmUgb2YgdGhlIHByb3BlcnRpZXMgbXVzdCBiZSBkZWZpbmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGlzIGF0IHBvc2l0aW9uIDEwXG4gKiAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUluZGV4KHlUZXh0LCAxMClcbiAqICAgLy8gbW9kaWZ5IHlUZXh0XG4gKiAgIHlUZXh0Lmluc2VydCgwLCAnYWJjJylcbiAqICAgeVRleHQuZGVsZXRlKDMsIDEwKVxuICogICAvLyBDb21wdXRlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAqICAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbih5LCByZWxhdGl2ZVBvc2l0aW9uKVxuICogICBhYnNvbHV0ZVBvc2l0aW9uLnR5cGUgPT09IHlUZXh0IC8vID0+IHRydWVcbiAqICAgY29uc29sZS5sb2coJ2N1cnNvciBsb2NhdGlvbiBpcyAnICsgYWJzb2x1dGVQb3NpdGlvbi5pbmRleCkgLy8gPT4gY3Vyc29yIGxvY2F0aW9uIGlzIDNcbiAqXG4gKi9cbmNsYXNzIFJlbGF0aXZlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJRHxudWxsfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRuYW1lXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXNzb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCB0bmFtZSwgaXRlbSwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50bmFtZSA9IHRuYW1lO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAvKipcbiAgICAgKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gYSBzcGVjaWZpYyBjaGFyYWN0ZXIuIEJ5IGRlZmF1bHRcbiAgICAgKiBhc3NvYyA+PSAwLCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byB0aGUgY2hhcmFjdGVyXG4gICAgICogYWZ0ZXIgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqIEkuZS4gcG9zaXRpb24gMSBpbiAnYWInIGlzIGFzc29jaWF0ZWQgdG8gY2hhcmFjdGVyICdiJy5cbiAgICAgKlxuICAgICAqIElmIGFzc29jIDwgMCwgdGhlbiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byB0aGUgY2FoYXJhY3RlclxuICAgICAqIGJlZm9yZSB0aGUgbWVhbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7YW55fVxuICovXG5jb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9KU09OID0gcnBvcyA9PiB7XG4gIGNvbnN0IGpzb24gPSB7fTtcbiAgaWYgKHJwb3MudHlwZSkge1xuICAgIGpzb24udHlwZSA9IHJwb3MudHlwZTtcbiAgfVxuICBpZiAocnBvcy50bmFtZSkge1xuICAgIGpzb24udG5hbWUgPSBycG9zLnRuYW1lO1xuICB9XG4gIGlmIChycG9zLml0ZW0pIHtcbiAgICBqc29uLml0ZW0gPSBycG9zLml0ZW07XG4gIH1cbiAgaWYgKHJwb3MuYXNzb2MgIT0gbnVsbCkge1xuICAgIGpzb24uYXNzb2MgPSBycG9zLmFzc29jO1xuICB9XG4gIHJldHVybiBqc29uXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBqc29uXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04gPSBqc29uID0+IG5ldyBSZWxhdGl2ZVBvc2l0aW9uKGpzb24udHlwZSA9PSBudWxsID8gbnVsbCA6IGNyZWF0ZUlEKGpzb24udHlwZS5jbGllbnQsIGpzb24udHlwZS5jbG9jayksIGpzb24udG5hbWUgfHwgbnVsbCwganNvbi5pdGVtID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi5pdGVtLmNsaWVudCwganNvbi5pdGVtLmNsb2NrKSwganNvbi5hc3NvYyA9PSBudWxsID8gMCA6IGpzb24uYXNzb2MpO1xuXG5jbGFzcyBBYnNvbHV0ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbiA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiBuZXcgQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgYXNzb2MpO1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtLCBhc3NvYykgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbDtcbiAgbGV0IHRuYW1lID0gbnVsbDtcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IGZpbmRSb290VHlwZUtleSh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlaWQgPSBjcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jayk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGVpZCwgdG5hbWUsIGl0ZW0sIGFzc29jKVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWxhdGl2ZVBvc2l0aW9uIGJhc2VkIG9uIGEgYWJzb2x1dGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZSBUaGUgYmFzZSB0eXBlIChlLmcuIFlUZXh0IG9yIFlBcnJheSkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4ID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IHtcbiAgbGV0IHQgPSB0eXBlLl9zdGFydDtcbiAgaWYgKGFzc29jIDwgMCkge1xuICAgIC8vIGFzc29jaWF0ZWQgdG8gdGhlIGxlZnQgY2hhcmFjdGVyIG9yIHRoZSBiZWdpbm5pbmcgb2YgYSB0eXBlLCBpbmNyZW1lbnQgaW5kZXggaWYgcG9zc2libGUuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxuICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgIGlmICghdC5kZWxldGVkICYmIHQuY291bnRhYmxlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgY3JlYXRlSUQodC5pZC5jbGllbnQsIHQuaWQuY2xvY2sgKyBpbmRleCksIGFzc29jKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gdC5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0LnJpZ2h0ID09PSBudWxsICYmIGFzc29jIDwgMCkge1xuICAgICAgLy8gbGVmdC1hc3NvY2lhdGVkIHBvc2l0aW9uLCByZXR1cm4gbGFzdCBhdmFpbGFibGUgaWRcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHQubGFzdElkLCBhc3NvYylcbiAgICB9XG4gICAgdCA9IHQucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlUmVsYXRpdmVQb3NpdGlvbiA9IChlbmNvZGVyLCBycG9zKSA9PiB7XG4gIGNvbnN0IHsgdHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jIH0gPSBycG9zO1xuICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAwKTtcbiAgICB3cml0ZUlEKGVuY29kZXIsIGl0ZW0pO1xuICB9IGVsc2UgaWYgKHRuYW1lICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyLCAxKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0bmFtZSk7XG4gIH0gZWxzZSBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyLCAyKTtcbiAgICB3cml0ZUlEKGVuY29kZXIsIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgfVxuICBlbmNvZGluZy53cml0ZVZhckludChlbmNvZGVyLCBhc3NvYyk7XG4gIHJldHVybiBlbmNvZGVyXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHJwb3MgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICB3cml0ZVJlbGF0aXZlUG9zaXRpb24oZW5jb2RlciwgcnBvcyk7XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn07XG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkUmVsYXRpdmVQb3NpdGlvbiA9IGRlY29kZXIgPT4ge1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0bmFtZSA9IG51bGw7XG4gIGxldCBpdGVtSUQgPSBudWxsO1xuICBzd2l0Y2ggKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgLy8gY2FzZSAxOiBmb3VuZCBwb3NpdGlvbiBzb21ld2hlcmUgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICBpdGVtSUQgPSByZWFkSUQoZGVjb2Rlcik7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIC8vIGNhc2UgMjogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBzdG9yZWQgaW4geS5zaGFyZVxuICAgICAgdG5hbWUgPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6IHtcbiAgICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgICB0eXBlID0gcmVhZElEKGRlY29kZXIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBhc3NvYyA9IGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgPyBkZWNvZGluZy5yZWFkVmFySW50KGRlY29kZXIpIDogMDtcbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHRuYW1lLCBpdGVtSUQsIGFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKi9cbmNvbnN0IGRlY29kZVJlbGF0aXZlUG9zaXRpb24gPSB1aW50OEFycmF5ID0+IHJlYWRSZWxhdGl2ZVBvc2l0aW9uKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodWludDhBcnJheSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7QWJzb2x1dGVQb3NpdGlvbnxudWxsfVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24gPSAocnBvcywgZG9jKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCByaWdodElEID0gcnBvcy5pdGVtO1xuICBjb25zdCB0eXBlSUQgPSBycG9zLnR5cGU7XG4gIGNvbnN0IHRuYW1lID0gcnBvcy50bmFtZTtcbiAgY29uc3QgYXNzb2MgPSBycG9zLmFzc29jO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCBpbmRleCA9IDA7XG4gIGlmIChyaWdodElEICE9PSBudWxsKSB7XG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCByaWdodElELmNsaWVudCkgPD0gcmlnaHRJRC5jbG9jaykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgcmVzID0gZm9sbG93UmVkb25lKHN0b3JlLCByaWdodElEKTtcbiAgICBjb25zdCByaWdodCA9IHJlcy5pdGVtO1xuICAgIGlmICghKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KTtcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICBpbmRleCA9IChyaWdodC5kZWxldGVkIHx8ICFyaWdodC5jb3VudGFibGUpID8gMCA6IChyZXMuZGlmZiArIChhc3NvYyA+PSAwID8gMCA6IDEpKTsgLy8gYWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9uIGxlZnQgYXNzb2NpYXRpb24gaWYgbmVjZXNzYXJ5XG4gICAgICBsZXQgbiA9IHJpZ2h0LmxlZnQ7XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgICAgIGluZGV4ICs9IG4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLmxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IGRvYy5nZXQodG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZUlEICE9PSBudWxsKSB7XG4gICAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHR5cGVJRC5jbGllbnQpIDw9IHR5cGVJRC5jbG9jaykge1xuICAgICAgICAvLyB0eXBlIGRvZXMgbm90IGV4aXN0IHlldFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgeyBpdGVtIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHR5cGVJRCk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGl0ZW0uY29udGVudC50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RydWN0IGlzIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKGFzc29jID49IDApIHtcbiAgICAgIGluZGV4ID0gdHlwZS5fbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBycG9zLmFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYVxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChcbiAgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEudG5hbWUgPT09IGIudG5hbWUgJiYgY29tcGFyZUlEcyhhLml0ZW0sIGIuaXRlbSkgJiYgY29tcGFyZUlEcyhhLnR5cGUsIGIudHlwZSkgJiYgYS5hc3NvYyA9PT0gYi5hc3NvY1xuKTtcblxuY2xhc3MgU25hcHNob3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gICAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdiBzdGF0ZSBtYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkcywgc3YpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RGVsZXRlU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZHMgPSBkcztcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBNYXBcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuc3YgPSBzdjtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAxXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxTbmFwc2hvdHMgPSAoc25hcDEsIHNuYXAyKSA9PiB7XG4gIGNvbnN0IGRzMSA9IHNuYXAxLmRzLmNsaWVudHM7XG4gIGNvbnN0IGRzMiA9IHNuYXAyLmRzLmNsaWVudHM7XG4gIGNvbnN0IHN2MSA9IHNuYXAxLnN2O1xuICBjb25zdCBzdjIgPSBzbmFwMi5zdjtcbiAgaWYgKHN2MS5zaXplICE9PSBzdjIuc2l6ZSB8fCBkczEuc2l6ZSAhPT0gZHMyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdjEuZW50cmllcygpKSB7XG4gICAgaWYgKHN2Mi5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRzaXRlbXMxXSBvZiBkczEuZW50cmllcygpKSB7XG4gICAgY29uc3QgZHNpdGVtczIgPSBkczIuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgaWYgKGRzaXRlbXMxLmxlbmd0aCAhPT0gZHNpdGVtczIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkc2l0ZW1zMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZHNpdGVtMSA9IGRzaXRlbXMxW2ldO1xuICAgICAgY29uc3QgZHNpdGVtMiA9IGRzaXRlbXMyW2ldO1xuICAgICAgaWYgKGRzaXRlbTEuY2xvY2sgIT09IGRzaXRlbTIuY2xvY2sgfHwgZHNpdGVtMS5sZW4gIT09IGRzaXRlbTIubGVuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVNuYXBzaG90VjIgPSAoc25hcHNob3QsIGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjIoKSkgPT4ge1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBzbmFwc2hvdC5kcyk7XG4gIHdyaXRlU3RhdGVWZWN0b3IoZW5jb2Rlciwgc25hcHNob3Quc3YpO1xuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU25hcHNob3QgPSBzbmFwc2hvdCA9PiBlbmNvZGVTbmFwc2hvdFYyKHNuYXBzaG90LCBuZXcgRFNFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gW2RlY29kZXJdXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3QgZGVjb2RlU25hcHNob3RWMiA9IChidWYsIGRlY29kZXIgPSBuZXcgRFNEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpKSkgPT4ge1xuICByZXR1cm4gbmV3IFNuYXBzaG90KHJlYWREZWxldGVTZXQoZGVjb2RlciksIHJlYWRTdGF0ZVZlY3RvcihkZWNvZGVyKSlcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBkZWNvZGVTbmFwc2hvdCA9IGJ1ZiA9PiBkZWNvZGVTbmFwc2hvdFYyKGJ1ZiwgbmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHNtXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3QgY3JlYXRlU25hcHNob3QgPSAoZHMsIHNtKSA9PiBuZXcgU25hcHNob3QoZHMsIHNtKTtcblxuY29uc3QgZW1wdHlTbmFwc2hvdCA9IGNyZWF0ZVNuYXBzaG90KGNyZWF0ZURlbGV0ZVNldCgpLCBuZXcgTWFwKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBzbmFwc2hvdCA9IGRvYyA9PiBjcmVhdGVTbmFwc2hvdChjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUoZG9jLnN0b3JlKSwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSk7XG5cbi8qKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1NuYXBzaG90fHVuZGVmaW5lZH0gc25hcHNob3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNWaXNpYmxlID0gKGl0ZW0sIHNuYXBzaG90KSA9PiBzbmFwc2hvdCA9PT0gdW5kZWZpbmVkXG4gID8gIWl0ZW0uZGVsZXRlZFxuICA6IHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgKHNuYXBzaG90LnN2LmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkgPiBpdGVtLmlkLmNsb2NrICYmICFpc0RlbGV0ZWQoc25hcHNob3QuZHMsIGl0ZW0uaWQpO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICovXG5jb25zdCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBtZXRhID0gbWFwLnNldElmVW5kZWZpbmVkKHRyYW5zYWN0aW9uLm1ldGEsIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMsIHNldC5jcmVhdGUpO1xuICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLmRvYy5zdG9yZTtcbiAgLy8gY2hlY2sgaWYgd2UgYWxyZWFkeSBzcGxpdCBmb3IgdGhpcyBzbmFwc2hvdFxuICBpZiAoIW1ldGEuaGFzKHNuYXBzaG90KSkge1xuICAgIHNuYXBzaG90LnN2LmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdC5kcywgX2l0ZW0gPT4ge30pO1xuICAgIG1ldGEuYWRkKHNuYXBzaG90KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoeyBnYzogZmFsc2UgfSlcbiAqICB5ZG9jLmdldFRleHQoKS5pbnNlcnQoMCwgJ3dvcmxkIScpXG4gKiAgY29uc3Qgc25hcHNob3QgPSBZLnNuYXBzaG90KHlkb2MpXG4gKiAgeWRvYy5nZXRUZXh0KCkuaW5zZXJ0KDAsICdoZWxsbyAnKVxuICogIGNvbnN0IHJlc3RvcmVkID0gWS5jcmVhdGVEb2NGcm9tU25hcHNob3QoeWRvYywgc25hcHNob3QpXG4gKiAgYXNzZXJ0KHJlc3RvcmVkLmdldFRleHQoKS50b1N0cmluZygpID09PSAnd29ybGQhJylcbiAqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tU25hcHNob3QgPSAob3JpZ2luRG9jLCBzbmFwc2hvdCwgbmV3RG9jID0gbmV3IERvYygpKSA9PiB7XG4gIGlmIChvcmlnaW5Eb2MuZ2MpIHtcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyeSB0byByZXN0b3JlIGEgR0MtZWQgZG9jdW1lbnQsIGJlY2F1c2Ugc29tZSBvZiB0aGUgcmVzdG9yZWQgaXRlbXMgbWlnaHQgaGF2ZSB0aGVpciBjb250ZW50IGRlbGV0ZWRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhcmJhZ2UtY29sbGVjdGlvbiBtdXN0IGJlIGRpc2FibGVkIGluIGBvcmlnaW5Eb2NgIScpXG4gIH1cbiAgY29uc3QgeyBzdiwgZHMgfSA9IHNuYXBzaG90O1xuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gIG9yaWdpbkRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHN2LmZvckVhY2goY2xvY2sgPT4ge1xuICAgICAgaWYgKGNsb2NrID4gMCkge1xuICAgICAgICBzaXplKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNpemUpO1xuICAgIC8vIHNwbGl0dGluZyB0aGUgc3RydWN0cyBiZWZvcmUgd3JpdGluZyB0aGVtIHRvIHRoZSBlbmNvZGVyXG4gICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2Ygc3YpIHtcbiAgICAgIGlmIChjbG9jayA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUob3JpZ2luRG9jLnN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgICBjb25zdCBsYXN0U3RydWN0SW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayAtIDEpO1xuICAgICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsYXN0U3RydWN0SW5kZXggKyAxKTtcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgICAgIC8vIGZpcnN0IGNsb2NrIHdyaXR0ZW4gaXMgMFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdFN0cnVjdEluZGV4OyBpKyspIHtcbiAgICAgICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICB9KTtcblxuICBhcHBseVVwZGF0ZVYyKG5ld0RvYywgZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgJ3NuYXBzaG90Jyk7XG4gIHJldHVybiBuZXdEb2Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBbWURlY29kZXJdXG4gKi9cbmNvbnN0IHNuYXBzaG90Q29udGFpbnNVcGRhdGVWMiA9IChzbmFwc2hvdCwgdXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpO1xuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIGlmICgoc25hcHNob3Quc3YuZ2V0KGN1cnIuaWQuY2xpZW50KSB8fCAwKSA8IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGNvbnN0IG1lcmdlZERTID0gbWVyZ2VEZWxldGVTZXRzKFtzbmFwc2hvdC5kcywgcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKV0pO1xuICByZXR1cm4gZXF1YWxEZWxldGVTZXRzKHNuYXBzaG90LmRzLCBtZXJnZWREUylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmNvbnN0IHNuYXBzaG90Q29udGFpbnNVcGRhdGUgPSAoc25hcHNob3QsIHVwZGF0ZSkgPT4gc25hcHNob3RDb250YWluc1VwZGF0ZVYyKHNuYXBzaG90LCB1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbmNsYXNzIFN0cnVjdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PEdDfEl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCB7IG1pc3Npbmc6IE1hcDxudW1iZXIsIG51bWJlcj4sIHVwZGF0ZTogVWludDhBcnJheSB9fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1N0cnVjdHMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgVWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdEcyA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YXRlcyBhcyBhIE1hcDxjbGllbnQsY2xvY2s+LlxuICogTm90ZSB0aGF0IGNsb2NrIHJlZmVycyB0byB0aGUgbmV4dCBleHBlY3RlZCBjbG9jayBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRTdGF0ZVZlY3RvciA9IHN0b3JlID0+IHtcbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIHN0b3JlLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdO1xuICAgIHNtLnNldChjbGllbnQsIHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpO1xuICB9KTtcbiAgcmV0dXJuIHNtXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFN0YXRlID0gKHN0b3JlLCBjbGllbnQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCk7XG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gIHJldHVybiBsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGhcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCkgPT4ge1xuICBsZXQgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpO1xuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RydWN0cyA9IFtdO1xuICAgIHN0b3JlLmNsaWVudHMuc2V0KHN0cnVjdC5pZC5jbGllbnQsIHN0cnVjdHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aCAhPT0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG4gIHN0cnVjdHMucHVzaChzdHJ1Y3QpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheVxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhTUyA9IChzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IHN0cnVjdHMubGVuZ3RoIC0gMTtcbiAgbGV0IG1pZCA9IHN0cnVjdHNbcmlnaHRdO1xuICBsZXQgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2s7XG4gIGlmIChtaWRjbG9jayA9PT0gY2xvY2spIHtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuICAvLyBAdG9kbyBkb2VzIGl0IGV2ZW4gbWFrZSBzZW5zZSB0byBwaXZvdCB0aGUgc2VhcmNoP1xuICAvLyBJZiBhIGdvb2Qgc3BsaXQgbWlzc2VzLCBpdCBtaWdodCBhY3R1YWxseSBpbmNyZWFzZSB0aGUgdGltZSB0byBmaW5kIHRoZSBjb3JyZWN0IGl0ZW0uXG4gIC8vIEN1cnJlbnRseSwgdGhlIG9ubHkgYWR2YW50YWdlIGlzIHRoYXQgc2VhcmNoIHdpdGggcGl2b3RpbmcgbWlnaHQgZmluZCB0aGUgaXRlbSBvbiB0aGUgZmlyc3QgdHJ5LlxuICBsZXQgbWlkaW5kZXggPSBtYXRoLmZsb29yKChjbG9jayAvIChtaWRjbG9jayArIG1pZC5sZW5ndGggLSAxKSkgKiByaWdodCk7IC8vIHBpdm90aW5nIHRoZSBzZWFyY2hcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBtaWQgPSBzdHJ1Y3RzW21pZGluZGV4XTtcbiAgICBtaWRjbG9jayA9IG1pZC5pZC5jbG9jaztcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxO1xuICAgIH1cbiAgICBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICAvLyBBbHdheXMgY2hlY2sgc3RhdGUgYmVmb3JlIGxvb2tpbmcgZm9yIGEgc3RydWN0IGluIFN0cnVjdFN0b3JlXG4gIC8vIFRoZXJlZm9yZSB0aGUgY2FzZSBvZiBub3QgZmluZGluZyBhIHN0cnVjdCBpcyB1bmV4cGVjdGVkXG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0dDfEl0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtID0gLyoqIEB0eXBlIHtmdW5jdGlvbihTdHJ1Y3RTdG9yZSxJRCk6SXRlbX0gKi8gKGZpbmQpO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqL1xuY29uc3QgZmluZEluZGV4Q2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2spID0+IHtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2sgJiYgc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgcmV0dXJuIGluZGV4ICsgMVxuICB9XG4gIHJldHVybiBpbmRleFxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW1DbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBpZCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpKTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtQ2xlYW5FbmQgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoaWQuY2xvY2sgIT09IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGggLSAxICYmIHN0cnVjdC5jb25zdHJ1Y3RvciAhPT0gR0MpIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpZC5jbG9jayAtIHN0cnVjdC5pZC5jbG9jayArIDEpKTtcbiAgfVxuICByZXR1cm4gc3RydWN0XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYGl0ZW1gIHdpdGggYG5ld2l0ZW1gIGluIHN0b3JlXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7R0N8SXRlbX0gbmV3U3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZXBsYWNlU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QsIG5ld1N0cnVjdCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpKTtcbiAgc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBzdHJ1Y3QuaWQuY2xvY2spXSA9IG5ld1N0cnVjdDtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2Ygc3RydWN0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tTdGFydCBJbmNsdXNpdmUgc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpdGVyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCwgbGVuLCBmKSA9PiB7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrU3RhcnQgKyBsZW47XG4gIGxldCBpbmRleCA9IGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQpO1xuICBsZXQgc3RydWN0O1xuICBkbyB7XG4gICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja0VuZCk7XG4gICAgfVxuICAgIGYoc3RydWN0KTtcbiAgfSB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3RzW2luZGV4XS5pZC5jbG9jayA8IGNsb2NrRW5kKVxufTtcblxuLyoqXG4gKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICogdG8gYnVuZGxlIGNoYW5nZXMgb24gdGhlIFlqcyBtb2RlbCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0b1xuICogbWluaW1pemUgdGhlIG51bWJlciBvbiBtZXNzYWdlcyBzZW50IGFuZCB0aGUgbnVtYmVyIG9mIG9ic2VydmVyIGNhbGxzLlxuICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gKiBwb3NzaWJsZS4gSGVyZSBpcyBhbiBleGFtcGxlIHRvIGlsbHVzdHJhdGUgdGhlIGFkdmFudGFnZXMgb2YgYnVuZGxpbmc6XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1hcCA9IHkuZGVmaW5lKCdtYXAnLCBZTWFwKVxuICogLy8gTG9nIGNvbnRlbnQgd2hlbiBjaGFuZ2UgaXMgdHJpZ2dlcmVkXG4gKiBtYXAub2JzZXJ2ZSgoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdjaGFuZ2UgdHJpZ2dlcmVkJylcbiAqIH0pXG4gKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAqIG1hcC5zZXQoJ2EnLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogbWFwLnNldCgnYicsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gKiB5LnRyYW5zYWN0KCgpID0+IHtcbiAqICAgbWFwLnNldCgnYScsIDEpXG4gKiAgIG1hcC5zZXQoJ2InLCAxKVxuICogfSkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBvcmlnaW4sIGxvY2FsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFlqcyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgc2V0IG9mIGRlbGV0ZWQgaXRlbXMgYnkgaWRzXG4gICAgICogQHR5cGUge0RlbGV0ZVNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVNldCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSk7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBBbGwgdHlwZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IG1vZGlmaWVkIChwcm9wZXJ0eSBhZGRlZCBvciBjaGlsZFxuICAgICAqIGluc2VydGVkL2RlbGV0ZWQpLiBOZXcgdHlwZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIFNldC5cbiAgICAgKiBNYXBzIGZyb20gdHlwZSB0byBwYXJlbnRTdWJzIChgaXRlbS5wYXJlbnRTdWIgPSBudWxsYCBmb3IgWUFycmF5KVxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixTZXQ8U3RyaW5nfG51bGw+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWQgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBldmVudHMgZm9yIHRoZSB0eXBlcyB0aGF0IG9ic2VydmUgYWxzbyBjaGlsZCBlbGVtZW50cy5cbiAgICAgKiBJdCBpcyBtYWlubHkgdXNlZCBieSBgb2JzZXJ2ZURlZXBgLlxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixBcnJheTxZRXZlbnQ8YW55Pj4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFBhcmVudFR5cGVzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59XG4gICAgICovXG4gICAgdGhpcy5fbWVyZ2VTdHJ1Y3RzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgbWV0YSBpbmZvcm1hdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAdHlwZSB7TWFwPGFueSxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgY2hhbmdlIG9yaWdpbmF0ZXMgZnJvbSB0aGlzIGRvYy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0FkZGVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NSZW1vdmVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NMb2FkZWQgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fbmVlZEZvcm1hdHRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgZGF0YSB3YXMgd3JpdHRlbi5cbiAqL1xuY29uc3Qgd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB7XG4gIGlmICh0cmFuc2FjdGlvbi5kZWxldGVTZXQuY2xpZW50cy5zaXplID09PSAwICYmICFtYXAuYW55KHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUsIChjbG9jaywgY2xpZW50KSA9PiB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSAhPT0gY2xvY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIElmIGB0eXBlLnBhcmVudGAgd2FzIGFkZGVkIGluIGN1cnJlbnQgdHJhbnNhY3Rpb24sIGB0eXBlYCB0ZWNobmljYWxseVxuICogZGlkIG5vdCBjaGFuZ2UsIGl0IHdhcyBqdXN0IGFkZGVkIGFuZCB3ZSBzaG91bGQgbm90IGZpcmUgZXZlbnRzIGZvciBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+Pn0gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gcGFyZW50U3ViXG4gKi9cbmNvbnN0IGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbiwgdHlwZSwgcGFyZW50U3ViKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSB0eXBlLl9pdGVtO1xuICBpZiAoaXRlbSA9PT0gbnVsbCB8fCAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApICYmICFpdGVtLmRlbGV0ZWQpKSB7XG4gICAgbWFwLnNldElmVW5kZWZpbmVkKHRyYW5zYWN0aW9uLmNoYW5nZWQsIHR5cGUsIHNldC5jcmVhdGUpLmFkZChwYXJlbnRTdWIpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICMgb2YgbWVyZ2VkIHN0cnVjdHNcbiAqL1xuY29uc3QgdHJ5VG9NZXJnZVdpdGhMZWZ0cyA9IChzdHJ1Y3RzLCBwb3MpID0+IHtcbiAgbGV0IHJpZ2h0ID0gc3RydWN0c1twb3NdO1xuICBsZXQgbGVmdCA9IHN0cnVjdHNbcG9zIC0gMV07XG4gIGxldCBpID0gcG9zO1xuICBmb3IgKDsgaSA+IDA7IHJpZ2h0ID0gbGVmdCwgbGVmdCA9IHN0cnVjdHNbLS1pIC0gMV0pIHtcbiAgICBpZiAobGVmdC5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmIGxlZnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAobGVmdC5tZXJnZVdpdGgocmlnaHQpKSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEl0ZW0gJiYgcmlnaHQucGFyZW50U3ViICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuZ2V0KHJpZ2h0LnBhcmVudFN1YikgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5zZXQocmlnaHQucGFyZW50U3ViLCAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBjb25zdCBtZXJnZWQgPSBwb3MgLSBpO1xuICBpZiAobWVyZ2VkKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBtZXJnZWQgc3RydWN0cyBmcm9tIHRoZSBhcnJheVxuICAgIHN0cnVjdHMuc3BsaWNlKHBvcyArIDEgLSBtZXJnZWQsIG1lcmdlZCk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgZm9yIChjb25zdCBbY2xpZW50LCBkZWxldGVJdGVtc10gb2YgZHMuY2xpZW50cy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXTtcbiAgICAgIGNvbnN0IGVuZERlbGV0ZUl0ZW1DbG9jayA9IGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbjtcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2spLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBlbmREZWxldGVJdGVtQ2xvY2s7XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbKytzaV1cbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgaWYgKGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiA8PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmIHN0cnVjdC5kZWxldGVkICYmICFzdHJ1Y3Qua2VlcCAmJiBnY0ZpbHRlcihzdHJ1Y3QpKSB7XG4gICAgICAgICAgc3RydWN0LmdjKHN0b3JlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICovXG5jb25zdCB0cnlNZXJnZURlbGV0ZVNldCA9IChkcywgc3RvcmUpID0+IHtcbiAgLy8gdHJ5IHRvIG1lcmdlIGRlbGV0ZWQgLyBnYydkIGl0ZW1zXG4gIC8vIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdCBmb3IgYmV0dGVyIGVmZmljaWVjeSBhbmQgc28gd2UgZG9uJ3QgbWlzcyBhbnkgbWVyZ2UgdGFyZ2V0c1xuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZUl0ZW1zLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXTtcbiAgICAgIC8vIHN0YXJ0IHdpdGggbWVyZ2luZyB0aGUgaXRlbSBuZXh0IHRvIHRoZSBsYXN0IGRlbGV0ZWQgaXRlbVxuICAgICAgY29uc3QgbW9zdFJpZ2h0SW5kZXhUb0NoZWNrID0gbWF0aC5taW4oc3RydWN0cy5sZW5ndGggLSAxLCAxICsgZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIC0gMSkpO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gbW9zdFJpZ2h0SW5kZXhUb0NoZWNrLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPiAwICYmIHN0cnVjdC5pZC5jbG9jayA+PSBkZWxldGVJdGVtLmNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXVxuICAgICAgKSB7XG4gICAgICAgIHNpIC09IDEgKyB0cnlUb01lcmdlV2l0aExlZnRzKHN0cnVjdHMsIHNpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBnY0ZpbHRlcik7XG4gIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb24+fSB0cmFuc2FjdGlvbkNsZWFudXBzXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5jb25zdCBjbGVhbnVwVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkpID0+IHtcbiAgaWYgKGkgPCB0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25DbGVhbnVwc1tpXTtcbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXQ7XG4gICAgY29uc3QgbWVyZ2VTdHJ1Y3RzID0gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cztcbiAgICB0cnkge1xuICAgICAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KGRzKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcih0cmFuc2FjdGlvbi5kb2Muc3RvcmUpO1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCBbdHJhbnNhY3Rpb24sIGRvY10pO1xuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogRWFjaCBjYWxsYmFjayBpcyBjYWxsZWQgZXZlbiBpZiB0aGUgb3RoZXIgb25lcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZzID0gW107XG4gICAgICAvLyBvYnNlcnZlIGV2ZW50cyBvbiBjaGFuZ2VkIHR5cGVzXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YnMsIGl0ZW10eXBlKSA9PlxuICAgICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbXR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIWl0ZW10eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGl0ZW10eXBlLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHN1YnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gZGVlcCBvYnNlcnZlIGV2ZW50c1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRzLCB0eXBlKSA9PiB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB0aGluayBhYm91dCB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgdXNlciB0cmFuc2Zvcm1zIHRoZVxuICAgICAgICAgIC8vIFkuRG9jIGluIHRoZSBldmVudC5cbiAgICAgICAgICBpZiAodHlwZS5fZEVILmwubGVuZ3RoID4gMCAmJiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSkge1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT5cbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuX2l0ZW0gPT09IG51bGwgfHwgIWV2ZW50LnRhcmdldC5faXRlbS5kZWxldGVkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBldmVudHNcbiAgICAgICAgICAgICAgLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0eXBlO1xuICAgICAgICAgICAgICAgIC8vIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgZXZlbnQuX3BhdGggPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNvcnQgZXZlbnRzIGJ5IHBhdGggbGVuZ3RoIHNvIHRoYXQgdG9wLWxldmVsIGV2ZW50cyBhcmUgZmlyZWQgZmlyc3QuXG4gICAgICAgICAgICBldmVudHNcbiAgICAgICAgICAgICAgLnNvcnQoKGV2ZW50MSwgZXZlbnQyKSA9PiBldmVudDEucGF0aC5sZW5ndGggLSBldmVudDIucGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZXZlbnRzLmxlbmd0aFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBrbm93IGl0IGhhcyBhdCBsZWFzdCBvbmUgZWxlbWVudFxuICAgICAgICAgICAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyh0eXBlLl9kRUgsIGV2ZW50cywgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGZzLnB1c2goKCkgPT4gZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb24nLCBbdHJhbnNhY3Rpb24sIGRvY10pKTtcbiAgICAgIGNhbGxBbGwoZnMsIFtdKTtcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5fbmVlZEZvcm1hdHRpbmdDbGVhbnVwKSB7XG4gICAgICAgIGNsZWFudXBZVGV4dEFmdGVyVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXBsYWNlIGRlbGV0ZWQgaXRlbXMgd2l0aCBJdGVtRGVsZXRlZCAvIEdDLlxuICAgICAgLy8gVGhpcyBpcyB3aGVyZSBjb250ZW50IGlzIGFjdHVhbGx5IHJlbW92ZSBmcm9tIHRoZSBZanMgRG9jLlxuICAgICAgaWYgKGRvYy5nYykge1xuICAgICAgICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGRvYy5nY0ZpbHRlcik7XG4gICAgICB9XG4gICAgICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpO1xuXG4gICAgICAvLyBvbiBhbGwgYWZmZWN0ZWQgc3RvcmUuY2xpZW50cyBwcm9wcywgdHJ5IHRvIG1lcmdlXG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3QgYmVmb3JlQ2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYmVmb3JlQ2xvY2sgIT09IGNsb2NrKSB7XG4gICAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICAgICAgICAvLyB3ZSBpdGVyYXRlIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbnRyaWVzXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGFuZ2VQb3MgPSBtYXRoLm1heChmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBiZWZvcmVDbG9jayksIDEpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdHJ1Y3RzLmxlbmd0aCAtIDE7IGkgPj0gZmlyc3RDaGFuZ2VQb3M7KSB7XG4gICAgICAgICAgICBpIC09IDEgKyB0cnlUb01lcmdlV2l0aExlZnRzKHN0cnVjdHMsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0cnkgdG8gbWVyZ2UgbWVyZ2VTdHJ1Y3RzXG4gICAgICAvLyBAdG9kbzogaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB0cmFuc2Zvcm0gbWVyZ2VTdHJ1Y3RzIHRvIGEgRFMsIHNvcnQgaXQsIGFuZCBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICAgIC8vICAgICAgICBidXQgYXQgdGhlIG1vbWVudCBEUyBkb2VzIG5vdCBoYW5kbGUgZHVwbGljYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IG1lcmdlU3RydWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IG1lcmdlU3RydWN0c1tpXS5pZDtcbiAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICAgICAgY29uc3QgcmVwbGFjZWRTdHJ1Y3RQb3MgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gICAgICAgIGlmIChyZXBsYWNlZFN0cnVjdFBvcyArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0cnlUb01lcmdlV2l0aExlZnRzKHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zICsgMSkgPiAxKSB7XG4gICAgICAgICAgICBjb250aW51ZSAvLyBubyBuZWVkIHRvIHBlcmZvcm0gbmV4dCBjaGVjaywgYm90aCBhcmUgYWxyZWFkeSBtZXJnZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zID4gMCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkgIT09IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChkb2MuY2xpZW50SUQpKSB7XG4gICAgICAgIGxvZ2dpbmcucHJpbnQobG9nZ2luZy5PUkFOR0UsIGxvZ2dpbmcuQk9MRCwgJ1t5anNdICcsIGxvZ2dpbmcuVU5CT0xELCBsb2dnaW5nLlJFRCwgJ0NoYW5nZWQgdGhlIGNsaWVudC1pZCBiZWNhdXNlIGFub3RoZXIgY2xpZW50IHNlZW1zIHRvIGJlIHVzaW5nIGl0LicpO1xuICAgICAgICBkb2MuY2xpZW50SUQgPSBnZW5lcmF0ZU5ld0NsaWVudElkKCk7XG4gICAgICB9XG4gICAgICAvLyBAdG9kbyBNZXJnZSBhbGwgdGhlIHRyYW5zYWN0aW9ucyBpbnRvIG9uZSBhbmQgcHJvdmlkZSBzZW5kIHRoZSBkYXRhIGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlXG4gICAgICBkb2MuZW1pdCgnYWZ0ZXJUcmFuc2FjdGlvbkNsZWFudXAnLCBbdHJhbnNhY3Rpb24sIGRvY10pO1xuICAgICAgaWYgKGRvYy5fb2JzZXJ2ZXJzLmhhcygndXBkYXRlJykpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjEoKTtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgZG9jLmVtaXQoJ3VwZGF0ZScsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRvYy5fb2JzZXJ2ZXJzLmhhcygndXBkYXRlVjInKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICAgICAgICBjb25zdCBoYXNDb250ZW50ID0gd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlVjInLCBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgdHJhbnNhY3Rpb24ub3JpZ2luLCBkb2MsIHRyYW5zYWN0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc3ViZG9jc0FkZGVkLCBzdWJkb2NzTG9hZGVkLCBzdWJkb2NzUmVtb3ZlZCB9ID0gdHJhbnNhY3Rpb247XG4gICAgICBpZiAoc3ViZG9jc0FkZGVkLnNpemUgPiAwIHx8IHN1YmRvY3NSZW1vdmVkLnNpemUgPiAwIHx8IHN1YmRvY3NMb2FkZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgc3ViZG9jc0FkZGVkLmZvckVhY2goc3ViZG9jID0+IHtcbiAgICAgICAgICBzdWJkb2MuY2xpZW50SUQgPSBkb2MuY2xpZW50SUQ7XG4gICAgICAgICAgaWYgKHN1YmRvYy5jb2xsZWN0aW9uaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3ViZG9jLmNvbGxlY3Rpb25pZCA9IGRvYy5jb2xsZWN0aW9uaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvYy5zdWJkb2NzLmFkZChzdWJkb2MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuZGVsZXRlKHN1YmRvYykpO1xuICAgICAgICBkb2MuZW1pdCgnc3ViZG9jcycsIFt7IGxvYWRlZDogc3ViZG9jc0xvYWRlZCwgYWRkZWQ6IHN1YmRvY3NBZGRlZCwgcmVtb3ZlZDogc3ViZG9jc1JlbW92ZWQgfSwgZG9jLCB0cmFuc2FjdGlvbl0pO1xuICAgICAgICBzdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoIDw9IGkgKyAxKSB7XG4gICAgICAgIGRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdO1xuICAgICAgICBkb2MuZW1pdCgnYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCBbZG9jLCB0cmFuc2FjdGlvbkNsZWFudXBzXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBgeS50cmFuc2FjdCgoKT0+ey4ufSlgXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOlR9IGZcbiAqIEBwYXJhbSB7YW55fSBbb3JpZ2luPXRydWVdXG4gKiBAcmV0dXJuIHtUfVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0cmFuc2FjdCA9IChkb2MsIGYsIG9yaWdpbiA9IG51bGwsIGxvY2FsID0gdHJ1ZSkgPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbkNsZWFudXBzID0gZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzO1xuICBsZXQgaW5pdGlhbENhbGwgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgaWYgKGRvYy5fdHJhbnNhY3Rpb24gPT09IG51bGwpIHtcbiAgICBpbml0aWFsQ2FsbCA9IHRydWU7XG4gICAgZG9jLl90cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihkb2MsIG9yaWdpbiwgbG9jYWwpO1xuICAgIHRyYW5zYWN0aW9uQ2xlYW51cHMucHVzaChkb2MuX3RyYW5zYWN0aW9uKTtcbiAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRvYy5lbWl0KCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCBbZG9jXSk7XG4gICAgfVxuICAgIGRvYy5lbWl0KCdiZWZvcmVUcmFuc2FjdGlvbicsIFtkb2MuX3RyYW5zYWN0aW9uLCBkb2NdKTtcbiAgfVxuICB0cnkge1xuICAgIHJlc3VsdCA9IGYoZG9jLl90cmFuc2FjdGlvbik7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGluaXRpYWxDYWxsKSB7XG4gICAgICBjb25zdCBmaW5pc2hDbGVhbnVwID0gZG9jLl90cmFuc2FjdGlvbiA9PT0gdHJhbnNhY3Rpb25DbGVhbnVwc1swXTtcbiAgICAgIGRvYy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgaWYgKGZpbmlzaENsZWFudXApIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRyYW5zYWN0aW9uIGVuZGVkLCBub3cgcHJvY2VzcyBvYnNlcnZlciBjYWxscy5cbiAgICAgICAgLy8gT2JzZXJ2ZXIgY2FsbCBtYXkgY3JlYXRlIG5ldyB0cmFuc2FjdGlvbnMgZm9yIHdoaWNoIHdlIG5lZWQgdG8gY2FsbCB0aGUgb2JzZXJ2ZXJzIGFuZCBkbyBjbGVhbnVwLlxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG5lc3QgdGhlc2UgY2FsbHMsIHNvIHdlIGV4ZWN1dGUgdGhlc2UgY2FsbHMgb25lIGFmdGVyXG4gICAgICAgIC8vIGFub3RoZXIuXG4gICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCBhbGwgY2xlYW51cHMgYXJlIGNhbGxlZCwgZXZlbiBpZiB0aGVcbiAgICAgICAgLy8gb2JzZXJ2ZXMgdGhyb3cgZXJyb3JzLlxuICAgICAgICAvLyBUaGlzIGZpbGUgaXMgZnVsbCBvZiBoYWNreSB0cnkge30gZmluYWxseSB7fSBibG9ja3MgdG8gZW5zdXJlIHRoYXQgYW5cbiAgICAgICAgLy8gZXZlbnQgY2FuIHRocm93IGVycm9ycyBhbmQgYWxzbyB0aGF0IHRoZSBjbGVhbnVwIGlzIGNhbGxlZC5cbiAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuY2xhc3MgU3RhY2tJdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkZWxldGlvbnNcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGluc2VydGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWxldGlvbnMsIGluc2VydGlvbnMpIHtcbiAgICB0aGlzLmluc2VydGlvbnMgPSBpbnNlcnRpb25zO1xuICAgIHRoaXMuZGVsZXRpb25zID0gZGVsZXRpb25zO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIHNhdmUgYW5kIHJlc3RvcmUgbWV0YWRhdGEgbGlrZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKCk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJcbiAqIEBwYXJhbSB7VW5kb01hbmFnZXJ9IHVtXG4gKiBAcGFyYW0ge1N0YWNrSXRlbX0gc3RhY2tJdGVtXG4gKi9cbmNvbnN0IGNsZWFyVW5kb01hbmFnZXJTdGFja0l0ZW0gPSAodHIsIHVtLCBzdGFja0l0ZW0pID0+IHtcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBpdGVtID0+IHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdW0uc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICBrZWVwSXRlbShpdGVtLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW5kb01hbmFnZXJcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge1N0YWNrSXRlbT99XG4gKi9cbmNvbnN0IHBvcFN0YWNrSXRlbSA9ICh1bmRvTWFuYWdlciwgc3RhY2ssIGV2ZW50VHlwZSkgPT4ge1xuICAvKipcbiAgICogV2hldGhlciBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAdHlwZSB7U3RhY2tJdGVtP31cbiAgICovXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICAvKipcbiAgICogS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgdHJhbnNhY3Rpb24gc28gd2UgY2FuIGZpcmUgdGhlIGV2ZW50IHdpdGggdGhlIGNoYW5nZWRQYXJlbnRUeXBlc1xuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IF90ciA9IG51bGw7XG4gIGNvbnN0IGRvYyA9IHVuZG9NYW5hZ2VyLmRvYztcbiAgY29uc3Qgc2NvcGUgPSB1bmRvTWFuYWdlci5zY29wZTtcbiAgdHJhbnNhY3QoZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgICAgIGNvbnN0IHN0YWNrSXRlbSA9IC8qKiBAdHlwZSB7U3RhY2tJdGVtfSAqLyAoc3RhY2sucG9wKCkpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBpdGVtc1RvUmVkbyA9IG5ldyBTZXQoKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBpdGVtc1RvRGVsZXRlID0gW107XG4gICAgICBsZXQgcGVyZm9ybWVkQ2hhbmdlID0gZmFsc2U7XG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgICAgICAgIGlmIChzdHJ1Y3QucmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgeyBpdGVtLCBkaWZmIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHN0cnVjdC5pZCk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgICAgaXRlbSA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChpdGVtLmlkLmNsaWVudCwgaXRlbS5pZC5jbG9jayArIGRpZmYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cnVjdCA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQgJiYgc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RydWN0KSkpKSB7XG4gICAgICAgICAgICBpdGVtc1RvRGVsZXRlLnB1c2goc3RydWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJlxuICAgICAgICAgIHNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIHN0cnVjdCkpICYmXG4gICAgICAgICAgLy8gTmV2ZXIgcmVkbyBzdHJ1Y3RzIGluIHN0YWNrSXRlbS5pbnNlcnRpb25zIGJlY2F1c2UgdGhleSB3ZXJlIGNyZWF0ZWQgYW5kIGRlbGV0ZWQgaW4gdGhlIHNhbWUgY2FwdHVyZSBpbnRlcnZhbC5cbiAgICAgICAgICAhaXNEZWxldGVkKHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QuaWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGl0ZW1zVG9SZWRvLmFkZChzdHJ1Y3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZW1zVG9SZWRvLmZvckVhY2goc3RydWN0ID0+IHtcbiAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gcmVkb0l0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgaXRlbXNUb1JlZG8sIHN0YWNrSXRlbS5pbnNlcnRpb25zLCB1bmRvTWFuYWdlci5pZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bmRvTWFuYWdlcikgIT09IG51bGwgfHwgcGVyZm9ybWVkQ2hhbmdlO1xuICAgICAgfSk7XG4gICAgICAvLyBXZSB3YW50IHRvIGRlbGV0ZSBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgY2hpbGRyZW4gYXJlIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAvLyBwYXJlbnRzLCBzbyB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYXZhaWxhYmxlIHdoZW4gaXRlbXMgYXJlIGZpbHRlcmVkLlxuICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zVG9EZWxldGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zVG9EZWxldGVbaV07XG4gICAgICAgIGlmICh1bmRvTWFuYWdlci5kZWxldGVGaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcGVyZm9ybWVkQ2hhbmdlID8gc3RhY2tJdGVtIDogbnVsbDtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKChzdWJQcm9wcywgdHlwZSkgPT4ge1xuICAgICAgLy8gZGVzdHJveSBzZWFyY2ggbWFya2VyIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN1YlByb3BzLmhhcyhudWxsKSAmJiB0eXBlLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgICAgdHlwZS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RyID0gdHJhbnNhY3Rpb247XG4gIH0sIHVuZG9NYW5hZ2VyKTtcbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gX3RyLmNoYW5nZWRQYXJlbnRUeXBlcztcbiAgICB1bmRvTWFuYWdlci5lbWl0KCdzdGFjay1pdGVtLXBvcHBlZCcsIFt7IHN0YWNrSXRlbTogcmVzdWx0LCB0eXBlOiBldmVudFR5cGUsIGNoYW5nZWRQYXJlbnRUeXBlcyB9LCB1bmRvTWFuYWdlcl0pO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5kb01hbmFnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5jYXB0dXJlVGltZW91dD01MDBdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmNhcHR1cmVUcmFuc2FjdGlvbl0gRG8gbm90IGNhcHR1cmUgY2hhbmdlcyBvZiBhIFRyYW5zYWN0aW9uIGlmIHJlc3VsdCBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5kZWxldGVGaWx0ZXI9KCk9PnRydWVdIFNvbWV0aW1lc1xuICogaXQgaXMgbmVjZXNzYXJ5IHRvIGZpbHRlciB3aGF0IGFuIFVuZG8vUmVkbyBvcGVyYXRpb24gY2FuIGRlbGV0ZS4gSWYgdGhpc1xuICogZmlsdGVyIHJldHVybnMgZmFsc2UsIHRoZSB0eXBlL2l0ZW0gd29uJ3QgYmUgZGVsZXRlZCBldmVuIGl0IGlzIGluIHRoZVxuICogdW5kby9yZWRvIHNjb3BlLlxuICogQHByb3BlcnR5IHtTZXQ8YW55Pn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy50cmFja2VkT3JpZ2lucz1uZXcgU2V0KFtudWxsXSldXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzXSBFeHBlcmltZW50YWwuIEJ5IGRlZmF1bHQsIHRoZSBVbmRvTWFuYWdlciB3aWxsIG5ldmVyIG92ZXJ3cml0ZSByZW1vdGUgY2hhbmdlcy4gRW5hYmxlIHRoaXMgcHJvcGVydHkgdG8gZW5hYmxlIG92ZXJ3cml0aW5nIHJlbW90ZSBjaGFuZ2VzIG9uIGtleS12YWx1ZSBjaGFuZ2VzIChZLk1hcCwgcHJvcGVydGllcyBvbiBZLlhtbCwgZXRjLi4pLlxuICogQHByb3BlcnR5IHtEb2N9IFtkb2NdIFRoZSBkb2N1bWVudCB0aGF0IHRoaXMgVW5kb01hbmFnZXIgb3BlcmF0ZXMgb24uIE9ubHkgbmVlZGVkIGlmIHR5cGVTY29wZSBpcyBlbXB0eS5cbiAqL1xuXG4vKipcbiAqIEZpcmVzICdzdGFjay1pdGVtLWFkZGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgYWRkZWQgdG8gZWl0aGVyIHRoZSB1bmRvLSBvclxuICogdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgc3RvcmUgYWRkaXRpb25hbCBzdGFjayBpbmZvcm1hdGlvbiB2aWEgdGhlXG4gKiBtZXRhZGF0YSBwcm9wZXJ0eSBvbiBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgIChpdCBpcyBhIGBNYXBgIG9mIG1ldGFkYXRhIHByb3BlcnRpZXMpLlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tcG9wcGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgcG9wcGVkIGZyb20gZWl0aGVyIHRoZVxuICogdW5kby0gb3IgdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgcmVzdG9yZSB0aGUgc2F2ZWQgc3RhY2sgaW5mb3JtYXRpb24gZnJvbSBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPCdzdGFjay1pdGVtLWFkZGVkJ3wnc3RhY2staXRlbS1wb3BwZWQnfCdzdGFjay1jbGVhcmVkJ3wnc3RhY2staXRlbS11cGRhdGVkJz59XG4gKi9cbmNsYXNzIFVuZG9NYW5hZ2VyIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fEFycmF5PEFic3RyYWN0VHlwZTxhbnk+Pn0gdHlwZVNjb3BlIEFjY2VwdHMgZWl0aGVyIGEgc2luZ2xlIHR5cGUsIG9yIGFuIGFycmF5IG9mIHR5cGVzXG4gICAqIEBwYXJhbSB7VW5kb01hbmFnZXJPcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZVNjb3BlLCB7XG4gICAgY2FwdHVyZVRpbWVvdXQgPSA1MDAsXG4gICAgY2FwdHVyZVRyYW5zYWN0aW9uID0gX3RyID0+IHRydWUsXG4gICAgZGVsZXRlRmlsdGVyID0gKCkgPT4gdHJ1ZSxcbiAgICB0cmFja2VkT3JpZ2lucyA9IG5ldyBTZXQoW251bGxdKSxcbiAgICBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzID0gZmFsc2UsXG4gICAgZG9jID0gLyoqIEB0eXBlIHtEb2N9ICovIChhcnJheS5pc0FycmF5KHR5cGVTY29wZSkgPyB0eXBlU2NvcGVbMF0uZG9jIDogdHlwZVNjb3BlLmRvYylcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc2NvcGUgPSBbXTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmFkZFRvU2NvcGUodHlwZVNjb3BlKTtcbiAgICB0aGlzLmRlbGV0ZUZpbHRlciA9IGRlbGV0ZUZpbHRlcjtcbiAgICB0cmFja2VkT3JpZ2lucy5hZGQodGhpcyk7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucyA9IHRyYWNrZWRPcmlnaW5zO1xuICAgIHRoaXMuY2FwdHVyZVRyYW5zYWN0aW9uID0gY2FwdHVyZVRyYW5zYWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMudW5kb1N0YWNrID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59XG4gICAgICovXG4gICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHVuZG9pbmcgKGNhbGxpbmcgVW5kb01hbmFnZXIudW5kbylcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudW5kb2luZyA9IGZhbHNlO1xuICAgIHRoaXMucmVkb2luZyA9IGZhbHNlO1xuICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgdGhpcy5pZ25vcmVSZW1vdGVNYXBDaGFuZ2VzID0gaWdub3JlUmVtb3RlTWFwQ2hhbmdlcztcbiAgICB0aGlzLmNhcHR1cmVUaW1lb3V0ID0gY2FwdHVyZVRpbWVvdXQ7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyID0gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLy8gT25seSB0cmFjayBjZXJ0YWluIHRyYW5zYWN0aW9uc1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5jYXB0dXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHx8XG4gICAgICAgICF0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuaGFzKHR5cGUpKSB8fFxuICAgICAgICAoIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbikgJiYgKCF0cmFuc2FjdGlvbi5vcmlnaW4gfHwgIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbi5jb25zdHJ1Y3RvcikpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgdW5kb2luZyA9IHRoaXMudW5kb2luZztcbiAgICAgIGNvbnN0IHJlZG9pbmcgPSB0aGlzLnJlZG9pbmc7XG4gICAgICBjb25zdCBzdGFjayA9IHVuZG9pbmcgPyB0aGlzLnJlZG9TdGFjayA6IHRoaXMudW5kb1N0YWNrO1xuICAgICAgaWYgKHVuZG9pbmcpIHtcbiAgICAgICAgdGhpcy5zdG9wQ2FwdHVyaW5nKCk7IC8vIG5leHQgdW5kbyBzaG91bGQgbm90IGJlIGFwcGVuZGVkIHRvIGxhc3Qgc3RhY2sgaXRlbVxuICAgICAgfSBlbHNlIGlmICghcmVkb2luZykge1xuICAgICAgICAvLyBuZWl0aGVyIHVuZG9pbmcgbm9yIHJlZG9pbmc6IGRlbGV0ZSByZWRvU3RhY2tcbiAgICAgICAgdGhpcy5jbGVhcihmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnNlcnRpb25zID0gbmV3IERlbGV0ZVNldCgpO1xuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5mb3JFYWNoKChlbmRDbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBjb25zdCBsZW4gPSBlbmRDbG9jayAtIHN0YXJ0Q2xvY2s7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgYWRkVG9EZWxldGVTZXQoaW5zZXJ0aW9ucywgY2xpZW50LCBzdGFydENsb2NrLCBsZW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKTtcbiAgICAgIGxldCBkaWRBZGQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmxhc3RDaGFuZ2UgPiAwICYmIG5vdyAtIHRoaXMubGFzdENoYW5nZSA8IHRoaXMuY2FwdHVyZVRpbWVvdXQgJiYgc3RhY2subGVuZ3RoID4gMCAmJiAhdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICAvLyBhcHBlbmQgY2hhbmdlIHRvIGxhc3Qgc3RhY2sgb3BcbiAgICAgICAgY29uc3QgbGFzdE9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGxhc3RPcC5kZWxldGlvbnMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5kZWxldGlvbnMsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldF0pO1xuICAgICAgICBsYXN0T3AuaW5zZXJ0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmluc2VydGlvbnMsIGluc2VydGlvbnNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBzdGFjayBvcFxuICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0l0ZW0odHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpbnNlcnRpb25zKSk7XG4gICAgICAgIGRpZEFkZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gbm93O1xuICAgICAgfVxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgZGVsZXRlZCBzdHJ1Y3RzIGFyZSBub3QgZ2MnZFxuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIC8qKiBAcGFyYW0ge0l0ZW18R0N9IGl0ZW0gKi8gaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIGl0ZW0pKSkge1xuICAgICAgICAgIGtlZXBJdGVtKGl0ZW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNoYW5nZUV2ZW50ID0gW3sgc3RhY2tJdGVtOiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgb3JpZ2luOiB0cmFuc2FjdGlvbi5vcmlnaW4sIHR5cGU6IHVuZG9pbmcgPyAncmVkbycgOiAndW5kbycsIGNoYW5nZWRQYXJlbnRUeXBlczogdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzIH0sIHRoaXNdO1xuICAgICAgaWYgKGRpZEFkZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWl0ZW0tYWRkZWQnLCBjaGFuZ2VFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWl0ZW0tdXBkYXRlZCcsIGNoYW5nZUV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZG9jLm9uKCdhZnRlclRyYW5zYWN0aW9uJywgdGhpcy5hZnRlclRyYW5zYWN0aW9uSGFuZGxlcik7XG4gICAgdGhpcy5kb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEFic3RyYWN0VHlwZTxhbnk+PiB8IEFic3RyYWN0VHlwZTxhbnk+fSB5dHlwZXNcbiAgICovXG4gIGFkZFRvU2NvcGUgKHl0eXBlcykge1xuICAgIHl0eXBlcyA9IGFycmF5LmlzQXJyYXkoeXR5cGVzKSA/IHl0eXBlcyA6IFt5dHlwZXNdO1xuICAgIHl0eXBlcy5mb3JFYWNoKHl0eXBlID0+IHtcbiAgICAgIGlmICh0aGlzLnNjb3BlLmV2ZXJ5KHl0ID0+IHl0ICE9PSB5dHlwZSkpIHtcbiAgICAgICAgaWYgKHl0eXBlLmRvYyAhPT0gdGhpcy5kb2MpIGxvZ2dpbmcud2FybignW3lqcyM1MDldIE5vdCBzYW1lIFkuRG9jJyk7IC8vIHVzZSBNdWx0aURvY1VuZG9NYW5hZ2VyIGluc3RlYWQuIGFsc28gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy81MDlcbiAgICAgICAgdGhpcy5zY29wZS5wdXNoKHl0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICBhZGRUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmFkZChvcmlnaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICovXG4gIHJlbW92ZVRyYWNrZWRPcmlnaW4gKG9yaWdpbikge1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMuZGVsZXRlKG9yaWdpbik7XG4gIH1cblxuICBjbGVhciAoY2xlYXJVbmRvU3RhY2sgPSB0cnVlLCBjbGVhclJlZG9TdGFjayA9IHRydWUpIHtcbiAgICBpZiAoKGNsZWFyVW5kb1N0YWNrICYmIHRoaXMuY2FuVW5kbygpKSB8fCAoY2xlYXJSZWRvU3RhY2sgJiYgdGhpcy5jYW5SZWRvKCkpKSB7XG4gICAgICB0aGlzLmRvYy50cmFuc2FjdCh0ciA9PiB7XG4gICAgICAgIGlmIChjbGVhclVuZG9TdGFjaykge1xuICAgICAgICAgIHRoaXMudW5kb1N0YWNrLmZvckVhY2goaXRlbSA9PiBjbGVhclVuZG9NYW5hZ2VyU3RhY2tJdGVtKHRyLCB0aGlzLCBpdGVtKSk7XG4gICAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xlYXJSZWRvU3RhY2spIHtcbiAgICAgICAgICB0aGlzLnJlZG9TdGFjay5mb3JFYWNoKGl0ZW0gPT4gY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSh0ciwgdGhpcywgaXRlbSkpO1xuICAgICAgICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdzdGFjay1jbGVhcmVkJywgW3sgdW5kb1N0YWNrQ2xlYXJlZDogY2xlYXJVbmRvU3RhY2ssIHJlZG9TdGFja0NsZWFyZWQ6IGNsZWFyUmVkb1N0YWNrIH1dKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvTWFuYWdlciBtZXJnZXMgVW5kby1TdGFja0l0ZW0gaWYgdGhleSBhcmUgY3JlYXRlZCB3aXRoaW4gdGltZS1nYXBcbiAgICogc21hbGxlciB0aGFuIGBvcHRpb25zLmNhcHR1cmVUaW1lb3V0YC4gQ2FsbCBgdW0uc3RvcENhcHR1cmluZygpYCBzbyB0aGF0IHRoZSBuZXh0XG4gICAqIFN0YWNrSXRlbSB3b24ndCBiZSBtZXJnZWQuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgICAvLyB3aXRob3V0IHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMSwgJ2InKVxuICAgKiAgICAgdW0udW5kbygpXG4gICAqICAgICB5dGV4dC50b1N0cmluZygpIC8vID0+ICcnIChub3RlIHRoYXQgJ2FiJyB3YXMgcmVtb3ZlZClcbiAgICogICAgIC8vIHdpdGggc3RvcENhcHR1cmluZ1xuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdhJylcbiAgICogICAgIHVtLnN0b3BDYXB0dXJpbmcoKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnYScgKG5vdGUgdGhhdCBvbmx5ICdiJyB3YXMgcmVtb3ZlZClcbiAgICpcbiAgICovXG4gIHN0b3BDYXB0dXJpbmcgKCkge1xuICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVW5kbyBsYXN0IGNoYW5nZXMgb24gdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RhY2tJdGVtP30gUmV0dXJucyBTdGFja0l0ZW0gaWYgYSBjaGFuZ2Ugd2FzIGFwcGxpZWRcbiAgICovXG4gIHVuZG8gKCkge1xuICAgIHRoaXMudW5kb2luZyA9IHRydWU7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gcG9wU3RhY2tJdGVtKHRoaXMsIHRoaXMudW5kb1N0YWNrLCAndW5kbycpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZG8gbGFzdCB1bmRvIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7U3RhY2tJdGVtP30gUmV0dXJucyBTdGFja0l0ZW0gaWYgYSBjaGFuZ2Ugd2FzIGFwcGxpZWRcbiAgICovXG4gIHJlZG8gKCkge1xuICAgIHRoaXMucmVkb2luZyA9IHRydWU7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gcG9wU3RhY2tJdGVtKHRoaXMsIHRoaXMucmVkb1N0YWNrLCAncmVkbycpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnJlZG9pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyoqXG4gICAqIEFyZSB1bmRvIHN0ZXBzIGF2YWlsYWJsZT9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHVuZG8gaXMgcG9zc2libGVcbiAgICovXG4gIGNhblVuZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnVuZG9TdGFjay5sZW5ndGggPiAwXG4gIH1cblxuICAvKipcbiAgICogQXJlIHJlZG8gc3RlcHMgYXZhaWxhYmxlP1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVkbyBpcyBwb3NzaWJsZVxuICAgKi9cbiAgY2FuUmVkbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMuZGVsZXRlKHRoaXMpO1xuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJUcmFuc2FjdGlvbicsIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKi9cbmZ1bmN0aW9uICogbGF6eVN0cnVjdFJlYWRlckdlbmVyYXRvciAoZGVjb2Rlcikge1xuICBjb25zdCBudW1PZlN0YXRlVXBkYXRlcyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mU3RhdGVVcGRhdGVzOyBpKyspIHtcbiAgICBjb25zdCBudW1iZXJPZlN0cnVjdHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKTtcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU3RydWN0czsgaSsrKSB7XG4gICAgICBjb25zdCBpbmZvID0gZGVjb2Rlci5yZWFkSW5mbygpO1xuICAgICAgLy8gQHRvZG8gdXNlIHN3aXRjaCBpbnN0ZWFkIG9mIGlmc1xuICAgICAgaWYgKGluZm8gPT09IDEwKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgICAgICB5aWVsZCBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKTtcbiAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgfSBlbHNlIGlmICgoYmluYXJ5LkJJVFM1ICYgaW5mbykgIT09IDApIHtcbiAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwO1xuICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IEl0ZW0oXG4gICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgbnVsbCwgLy8gbGVmdFxuICAgICAgICAgIChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbCwgLy8gb3JpZ2luXG4gICAgICAgICAgbnVsbCwgLy8gcmlnaHRcbiAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAvLyBAdHMtaWdub3JlIEZvcmNlIHdyaXRpbmcgYSBzdHJpbmcgaGVyZS5cbiAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gPyAoZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBkZWNvZGVyLnJlYWRMZWZ0SUQoKSkgOiBudWxsLCAvLyBwYXJlbnRcbiAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBiaW5hcnkuQklUNikgPT09IGJpbmFyeS5CSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICk7XG4gICAgICAgIHlpZWxkIHN0cnVjdDtcbiAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICAgICAgICB5aWVsZCBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgTGF6eVN0cnVjdFJlYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlclNraXBzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2RlciwgZmlsdGVyU2tpcHMpIHtcbiAgICB0aGlzLmdlbiA9IGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBJdGVtIHwgU2tpcCB8IEdDfVxuICAgICAqL1xuICAgIHRoaXMuY3VyciA9IG51bGw7XG4gICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJTa2lwcyA9IGZpbHRlclNraXBzO1xuICAgIHRoaXMubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZW0gfCBHQyB8IFNraXAgfG51bGx9XG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvLyBpZ25vcmUgXCJTa2lwXCIgc3RydWN0c1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY3VyciA9IHRoaXMuZ2VuLm5leHQoKS52YWx1ZSB8fCBudWxsO1xuICAgIH0gd2hpbGUgKHRoaXMuZmlsdGVyU2tpcHMgJiYgdGhpcy5jdXJyICE9PSBudWxsICYmIHRoaXMuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcClcbiAgICByZXR1cm4gdGhpcy5jdXJyXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICpcbiAqL1xuY29uc3QgbG9nVXBkYXRlID0gdXBkYXRlID0+IGxvZ1VwZGF0ZVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gW1lEZWNvZGVyXVxuICpcbiAqL1xuY29uc3QgbG9nVXBkYXRlVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW107XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSk7XG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpO1xuICB9XG4gIGxvZ2dpbmcucHJpbnQoJ1N0cnVjdHM6ICcsIHN0cnVjdHMpO1xuICBjb25zdCBkcyA9IHJlYWREZWxldGVTZXQodXBkYXRlRGVjb2Rlcik7XG4gIGxvZ2dpbmcucHJpbnQoJ0RlbGV0ZVNldDogJywgZHMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICpcbiAqL1xuY29uc3QgZGVjb2RlVXBkYXRlID0gKHVwZGF0ZSkgPT4gZGVjb2RlVXBkYXRlVjIodXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBbWURlY29kZXJdXG4gKlxuICovXG5jb25zdCBkZWNvZGVVcGRhdGVWMiA9ICh1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSBbXTtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpO1xuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKTtcbiAgZm9yIChsZXQgY3VyciA9IGxhenlEZWNvZGVyLmN1cnI7IGN1cnIgIT09IG51bGw7IGN1cnIgPSBsYXp5RGVjb2Rlci5uZXh0KCkpIHtcbiAgICBzdHJ1Y3RzLnB1c2goY3Vycik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdHJ1Y3RzLFxuICAgIGRzOiByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXG4gIH1cbn07XG5cbmNsYXNzIExhenlTdHJ1Y3RXcml0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbmNvZGVyKSB7XG4gICAgdGhpcy5jdXJyQ2xpZW50ID0gMDtcbiAgICB0aGlzLnN0YXJ0Q2xvY2sgPSAwO1xuICAgIHRoaXMud3JpdHRlbiA9IDA7XG4gICAgdGhpcy5lbmNvZGVyID0gZW5jb2RlcjtcbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIHdyaXRlIG9wZXJhdGlvbnMgbGF6aWx5LCBidXQgYWxzbyB3ZSBuZWVkIHRvIGtub3cgYmVmb3JlaGFuZCBob3cgbWFueSBvcGVyYXRpb25zIHdlIHdhbnQgdG8gd3JpdGUgZm9yIGVhY2ggY2xpZW50LlxuICAgICAqXG4gICAgICogVGhpcyBraW5kIG9mIG1ldGEtaW5mb3JtYXRpb24gKCNjbGllbnRzLCAjc3RydWN0cy1wZXItY2xpZW50LXdyaXR0ZW4pIGlzIHdyaXR0ZW4gdG8gdGhlIHJlc3RFbmNvZGVyLlxuICAgICAqXG4gICAgICogV2UgZnJhZ21lbnQgdGhlIHJlc3RFbmNvZGVyIGFuZCBzdG9yZSBhIHNsaWNlIG9mIGl0IHBlci1jbGllbnQgdW50aWwgd2Uga25vdyBob3cgbWFueSBjbGllbnRzIHRoZXJlIGFyZS5cbiAgICAgKiBXaGVuIHdlIGZsdXNoICh0b1VpbnQ4QXJyYXkpIHdlIHdyaXRlIHRoZSByZXN0RW5jb2RlciB1c2luZyB0aGUgZnJhZ21lbnRzIGFuZCB0aGUgbWV0YS1pbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTx7IHdyaXR0ZW46IG51bWJlciwgcmVzdEVuY29kZXI6IFVpbnQ4QXJyYXkgfT59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRTdHJ1Y3RzID0gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFVpbnQ4QXJyYXk+fSB1cGRhdGVzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBtZXJnZVVwZGF0ZXMgPSB1cGRhdGVzID0+IG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgRFNFbmNvZGVyVjEgfCB0eXBlb2YgRFNFbmNvZGVyVjJ9IFlFbmNvZGVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIgPSAodXBkYXRlLCBZRW5jb2RlciA9IERTRW5jb2RlclYyLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSwgZmFsc2UpO1xuICBsZXQgY3VyciA9IHVwZGF0ZURlY29kZXIuY3VycjtcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgbGV0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICBsZXQgc3RvcENvdW50aW5nID0gY3Vyci5pZC5jbG9jayAhPT0gMDsgLy8gbXVzdCBzdGFydCBhdCAwXG4gICAgbGV0IGN1cnJDbG9jayA9IHN0b3BDb3VudGluZyA/IDAgOiBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGg7XG4gICAgZm9yICg7IGN1cnIgIT09IG51bGw7IGN1cnIgPSB1cGRhdGVEZWNvZGVyLm5leHQoKSkge1xuICAgICAgaWYgKGN1cnJDbGllbnQgIT09IGN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgIGlmIChjdXJyQ2xvY2sgIT09IDApIHtcbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gV2UgZm91bmQgYSBuZXcgY2xpZW50XG4gICAgICAgICAgLy8gd3JpdGUgd2hhdCB3ZSBoYXZlIHRvIHRoZSBlbmNvZGVyXG4gICAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbGllbnQpO1xuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICAgICAgY3VyckNsb2NrID0gMDtcbiAgICAgICAgc3RvcENvdW50aW5nID0gY3Vyci5pZC5jbG9jayAhPT0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGlnbm9yZSBza2lwc1xuICAgICAgaWYgKGN1cnIuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgc3RvcENvdW50aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RvcENvdW50aW5nKSB7XG4gICAgICAgIGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JpdGUgd2hhdCB3ZSBoYXZlXG4gICAgaWYgKGN1cnJDbG9jayAhPT0gMCkge1xuICAgICAgc2l6ZSsrO1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbGllbnQpO1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbG9jayk7XG4gICAgfVxuICAgIC8vIHByZXBlbmQgdGhlIHNpemUgb2YgdGhlIHN0YXRlIHZlY3RvclxuICAgIGNvbnN0IGVuYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jLCBzaXplKTtcbiAgICBlbmNvZGluZy53cml0ZUJpbmFyeUVuY29kZXIoZW5jLCBlbmNvZGVyLnJlc3RFbmNvZGVyKTtcbiAgICBlbmNvZGVyLnJlc3RFbmNvZGVyID0gZW5jO1xuICAgIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG4gIH0gZWxzZSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZSA9IHVwZGF0ZSA9PiBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMih1cGRhdGUsIERTRW5jb2RlclYxLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuY29uc3QgcGFyc2VVcGRhdGVNZXRhVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICBjb25zdCBmcm9tID0gbmV3IE1hcCgpO1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICBjb25zdCB0byA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCBmYWxzZSk7XG4gIGxldCBjdXJyID0gdXBkYXRlRGVjb2Rlci5jdXJyO1xuICBpZiAoY3VyciAhPT0gbnVsbCkge1xuICAgIGxldCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgbGV0IGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2s7XG4gICAgLy8gd3JpdGUgdGhlIGJlZ2lubmluZyB0byBgZnJvbWBcbiAgICBmcm9tLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spO1xuICAgIGZvciAoOyBjdXJyICE9PSBudWxsOyBjdXJyID0gdXBkYXRlRGVjb2Rlci5uZXh0KCkpIHtcbiAgICAgIGlmIChjdXJyQ2xpZW50ICE9PSBjdXJyLmlkLmNsaWVudCkge1xuICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgICAgIHRvLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spO1xuICAgICAgICAvLyB3cml0ZSB0aGUgYmVnaW5uaW5nIHRvIGBmcm9tYFxuICAgICAgICBmcm9tLnNldChjdXJyLmlkLmNsaWVudCwgY3Vyci5pZC5jbG9jayk7XG4gICAgICAgIC8vIHVwZGF0ZSBjdXJyQ2xpZW50XG4gICAgICAgIGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICAgIH1cbiAgICAgIGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgdG8uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jayk7XG4gIH1cbiAgcmV0dXJuIHsgZnJvbSwgdG8gfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuY29uc3QgcGFyc2VVcGRhdGVNZXRhID0gdXBkYXRlID0+IHBhcnNlVXBkYXRlTWV0YVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBzbGljZSBhbnkga2luZCBvZiBzdHJ1Y3QgYW5kIHJldHJpZXZlIHRoZSByaWdodCBwYXJ0LlxuICogSXQgZG9lcyBub3QgaGFuZGxlIHNpZGUtZWZmZWN0cywgc28gaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSB0aGUgbGF6eS1lbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7SXRlbSB8IEdDIHwgU2tpcH0gbGVmdFxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW0gfCBHQ31cbiAqL1xuY29uc3Qgc2xpY2VTdHJ1Y3QgPSAobGVmdCwgZGlmZikgPT4ge1xuICBpZiAobGVmdC5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWQ7XG4gICAgcmV0dXJuIG5ldyBHQyhjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksIGxlZnQubGVuZ3RoIC0gZGlmZilcbiAgfSBlbHNlIGlmIChsZWZ0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0LmlkO1xuICAgIHJldHVybiBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksIGxlZnQubGVuZ3RoIC0gZGlmZilcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZWZ0SXRlbSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKGxlZnQpO1xuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdEl0ZW0uaWQ7XG4gICAgcmV0dXJuIG5ldyBJdGVtKFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLFxuICAgICAgbnVsbCxcbiAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmIC0gMSksXG4gICAgICBudWxsLFxuICAgICAgbGVmdEl0ZW0ucmlnaHRPcmlnaW4sXG4gICAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgICBsZWZ0SXRlbS5wYXJlbnRTdWIsXG4gICAgICBsZWZ0SXRlbS5jb250ZW50LnNwbGljZShkaWZmKVxuICAgIClcbiAgfVxufTtcblxuLyoqXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b3JrcyBzaW1pbGFybHkgdG8gYHJlYWRVcGRhdGVWMmAuXG4gKlxuICogQHBhcmFtIHtBcnJheTxVaW50OEFycmF5Pn0gdXBkYXRlc1xuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYxIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMn0gW1lFbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgbWVyZ2VVcGRhdGVzVjIgPSAodXBkYXRlcywgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIsIFlFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYyKSA9PiB7XG4gIGlmICh1cGRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB1cGRhdGVzWzBdXG4gIH1cbiAgY29uc3QgdXBkYXRlRGVjb2RlcnMgPSB1cGRhdGVzLm1hcCh1cGRhdGUgPT4gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSkpO1xuICBsZXQgbGF6eVN0cnVjdERlY29kZXJzID0gdXBkYXRlRGVjb2RlcnMubWFwKGRlY29kZXIgPT4gbmV3IExhenlTdHJ1Y3RSZWFkZXIoZGVjb2RlciwgdHJ1ZSkpO1xuXG4gIC8qKlxuICAgKiBAdG9kbyB3ZSBkb24ndCBuZWVkIG9mZnNldCBiZWNhdXNlIHdlIGFsd2F5cyBzbGljZSBiZWZvcmVcbiAgICogQHR5cGUge251bGwgfCB7IHN0cnVjdDogSXRlbSB8IEdDIHwgU2tpcCwgb2Zmc2V0OiBudW1iZXIgfX1cbiAgICovXG4gIGxldCBjdXJyV3JpdGUgPSBudWxsO1xuXG4gIGNvbnN0IHVwZGF0ZUVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgLy8gd3JpdGUgc3RydWN0cyBsYXppbHlcbiAgY29uc3QgbGF6eVN0cnVjdEVuY29kZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcih1cGRhdGVFbmNvZGVyKTtcblxuICAvLyBOb3RlOiBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBsYXp5U3RydWN0RGVjb2RlcnMgYXJlIGZ1bGx5IGNvbnN1bWVkXG4gIC8vIE5vdGU6IFNob3VsZCBtZXJnZSBkb2N1bWVudCB1cGRhdGVzIHdoZW5ldmVyIHBvc3NpYmxlIC0gZXZlbiBmcm9tIGRpZmZlcmVudCB1cGRhdGVzXG4gIC8vIE5vdGU6IFNob3VsZCBoYW5kbGUgdGhhdCBzb21lIG9wZXJhdGlvbnMgY2Fubm90IGJlIGFwcGxpZWQgeWV0ICgpXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBXcml0ZSBoaWdoZXIgY2xpZW50cyBmaXJzdCDih5Igc29ydCBieSBjbGllbnRJRCAmIGNsb2NrIGFuZCByZW1vdmUgZGVjb2RlcnMgd2l0aG91dCBjb250ZW50XG4gICAgbGF6eVN0cnVjdERlY29kZXJzID0gbGF6eVN0cnVjdERlY29kZXJzLmZpbHRlcihkZWMgPT4gZGVjLmN1cnIgIT09IG51bGwpO1xuICAgIGxhenlTdHJ1Y3REZWNvZGVycy5zb3J0KFxuICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihhbnksYW55KTpudW1iZXJ9ICovIChkZWMxLCBkZWMyKSA9PiB7XG4gICAgICAgIGlmIChkZWMxLmN1cnIuaWQuY2xpZW50ID09PSBkZWMyLmN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgICAgY29uc3QgY2xvY2tEaWZmID0gZGVjMS5jdXJyLmlkLmNsb2NrIC0gZGVjMi5jdXJyLmlkLmNsb2NrO1xuICAgICAgICAgIGlmIChjbG9ja0RpZmYgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIHJlbW92ZSByZWZlcmVuY2VzIHRvIHNraXAgc2luY2UgdGhlIHN0cnVjdERlY29kZXJzIG11c3QgZmlsdGVyIFNraXBzLlxuICAgICAgICAgICAgcmV0dXJuIGRlYzEuY3Vyci5jb25zdHJ1Y3RvciA9PT0gZGVjMi5jdXJyLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICA6IGRlYzEuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCA/IDEgOiAtMSAvLyB3ZSBhcmUgZmlsdGVyaW5nIHNraXBzIGFueXdheS5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNsb2NrRGlmZlxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVjMi5jdXJyLmlkLmNsaWVudCAtIGRlYzEuY3Vyci5pZC5jbGllbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGxhenlTdHJ1Y3REZWNvZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNvbnN0IGN1cnJEZWNvZGVyID0gbGF6eVN0cnVjdERlY29kZXJzWzBdO1xuICAgIC8vIHdyaXRlIGZyb20gY3VyckRlY29kZXIgdW50aWwgdGhlIG5leHQgb3BlcmF0aW9uIGlzIGZyb20gYW5vdGhlciBjbGllbnQgb3IgaWYgZmlsbGVyLXN0cnVjdFxuICAgIC8vIHRoZW4gd2UgbmVlZCB0byByZW9yZGVyIHRoZSBkZWNvZGVycyBhbmQgZmluZCB0aGUgbmV4dCBvcGVyYXRpb24gdG8gd3JpdGVcbiAgICBjb25zdCBmaXJzdENsaWVudCA9IC8qKiBAdHlwZSB7SXRlbSB8IEdDfSAqLyAoY3VyckRlY29kZXIuY3VycikuaWQuY2xpZW50O1xuXG4gICAgaWYgKGN1cnJXcml0ZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IGN1cnIgPSAvKiogQHR5cGUge0l0ZW0gfCBHQyB8IG51bGx9ICovIChjdXJyRGVjb2Rlci5jdXJyKTtcbiAgICAgIGxldCBpdGVyYXRlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBpdGVyYXRlIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHRoYXQgd2UgaGF2ZW4ndCB3cml0dGVuIGFscmVhZHlcbiAgICAgIC8vIHJlbWVtYmVyOiBmaXJzdCB0aGUgaGlnaCBjbGllbnQtaWRzIGFyZSB3cml0dGVuXG4gICAgICB3aGlsZSAoY3VyciAhPT0gbnVsbCAmJiBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPD0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIGN1cnIuaWQuY2xpZW50ID49IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIGN1cnIgPSBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgICAgIGl0ZXJhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgY3VyciA9PT0gbnVsbCB8fCAvLyBjdXJyZW50IGRlY29kZXIgaXMgZW1wdHlcbiAgICAgICAgY3Vyci5pZC5jbGllbnQgIT09IGZpcnN0Q2xpZW50IHx8IC8vIGNoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYW5vdGhlciBkZWNvZGVyIHRoYXQgaGFzIGhhcyB1cGRhdGVzIGZyb20gYGZpcnN0Q2xpZW50YFxuICAgICAgICAoaXRlcmF0ZWQgJiYgY3Vyci5pZC5jbG9jayA+IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCkgLy8gdGhlIGFib3ZlIHdoaWxlIGxvb3Agd2FzIHVzZWQgYW5kIHdlIGFyZSBwb3RlbnRpYWxseSBtaXNzaW5nIHVwZGF0ZXNcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDbGllbnQgIT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IGN1cnIsIG9mZnNldDogMCB9O1xuICAgICAgICBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIDwgY3Vyci5pZC5jbG9jaykge1xuICAgICAgICAgIC8vIEB0b2RvIHdyaXRlIGN1cnJTdHJ1Y3QgJiBzZXQgY3VyclN0cnVjdCA9IFNraXAoY2xvY2sgPSBjdXJyU3RydWN0LmlkLmNsb2NrICsgY3VyclN0cnVjdC5sZW5ndGgsIGxlbmd0aCA9IGN1cnIuaWQuY2xvY2sgLSBzZWxmLmNsb2NrKVxuICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAvLyBleHRlbmQgZXhpc3Rpbmcgc2tpcFxuICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gY3Vyci5pZC5jbG9jayAtIGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgLSBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge1NraXB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBTa2lwKGNyZWF0ZUlEKGZpcnN0Q2xpZW50LCBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGgpLCBkaWZmKTtcbiAgICAgICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0LCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGlmIChjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPj0gY3Vyci5pZC5jbG9jaykge1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggLSBjdXJyLmlkLmNsb2NrO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgICAgICAgLy8gcHJlZmVyIHRvIHNsaWNlIFNraXAgYmVjYXVzZSB0aGUgb3RoZXIgc3RydWN0IG1pZ2h0IGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyciA9IHNsaWNlU3RydWN0KGN1cnIsIGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWN1cnJXcml0ZS5zdHJ1Y3QubWVyZ2VXaXRoKC8qKiBAdHlwZSB7YW55fSAqLyAoY3VycikpKSB7XG4gICAgICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH07XG4gICAgICAgICAgICBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiAvKiogQHR5cGUge0l0ZW0gfCBHQ30gKi8gKGN1cnJEZWNvZGVyLmN1cnIpLCBvZmZzZXQ6IDAgfTtcbiAgICAgIGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICB9XG4gICAgZm9yIChcbiAgICAgIGxldCBuZXh0ID0gY3VyckRlY29kZXIuY3VycjtcbiAgICAgIG5leHQgIT09IG51bGwgJiYgbmV4dC5pZC5jbGllbnQgPT09IGZpcnN0Q2xpZW50ICYmIG5leHQuaWQuY2xvY2sgPT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAmJiBuZXh0LmNvbnN0cnVjdG9yICE9PSBTa2lwO1xuICAgICAgbmV4dCA9IGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICkge1xuICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IG5leHQsIG9mZnNldDogMCB9O1xuICAgIH1cbiAgfVxuICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgIGN1cnJXcml0ZSA9IG51bGw7XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdEVuY29kZXIpO1xuXG4gIGNvbnN0IGRzcyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IHJlYWREZWxldGVTZXQoZGVjb2RlcikpO1xuICBjb25zdCBkcyA9IG1lcmdlRGVsZXRlU2V0cyhkc3MpO1xuICB3cml0ZURlbGV0ZVNldCh1cGRhdGVFbmNvZGVyLCBkcyk7XG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYyfSBbWUVuY29kZXJdXG4gKi9cbmNvbnN0IGRpZmZVcGRhdGVWMiA9ICh1cGRhdGUsIHN2LCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBkZWNvZGVTdGF0ZVZlY3Rvcihzdik7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgY29uc3QgbGF6eVN0cnVjdFdyaXRlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKGVuY29kZXIpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIGZhbHNlKTtcbiAgd2hpbGUgKHJlYWRlci5jdXJyKSB7XG4gICAgY29uc3QgY3VyciA9IHJlYWRlci5jdXJyO1xuICAgIGNvbnN0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICBjb25zdCBzdkNsb2NrID0gc3RhdGUuZ2V0KGN1cnJDbGllbnQpIHx8IDA7XG4gICAgaWYgKHJlYWRlci5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAvLyB0aGUgZmlyc3Qgd3JpdHRlbiBzdHJ1Y3Qgc2hvdWxkbid0IGJlIGEgc2tpcFxuICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPiBzdkNsb2NrKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0V3JpdGVyLCBjdXJyLCBtYXRoLm1heChzdkNsb2NrIC0gY3Vyci5pZC5jbG9jaywgMCkpO1xuICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIHdoaWxlIChyZWFkZXIuY3VyciAmJiByZWFkZXIuY3Vyci5pZC5jbGllbnQgPT09IGN1cnJDbGllbnQpIHtcbiAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdFdyaXRlciwgcmVhZGVyLmN1cnIsIDApO1xuICAgICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFkIHVudGlsIHNvbWV0aGluZyBuZXcgY29tZXMgdXBcbiAgICAgIHdoaWxlIChyZWFkZXIuY3VyciAmJiByZWFkZXIuY3Vyci5pZC5jbGllbnQgPT09IGN1cnJDbGllbnQgJiYgcmVhZGVyLmN1cnIuaWQuY2xvY2sgKyByZWFkZXIuY3Vyci5sZW5ndGggPD0gc3ZDbG9jaykge1xuICAgICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5U3RydWN0V3JpdGVyKTtcbiAgLy8gd3JpdGUgZHNcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KGRlY29kZXIpO1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKi9cbmNvbnN0IGRpZmZVcGRhdGUgPSAodXBkYXRlLCBzdikgPT4gZGlmZlVwZGF0ZVYyKHVwZGF0ZSwgc3YsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqL1xuY29uc3QgZmx1c2hMYXp5U3RydWN0V3JpdGVyID0gbGF6eVdyaXRlciA9PiB7XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwKSB7XG4gICAgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLnB1c2goeyB3cml0dGVuOiBsYXp5V3JpdGVyLndyaXR0ZW4sIHJlc3RFbmNvZGVyOiBlbmNvZGluZy50b1VpbnQ4QXJyYXkobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyKSB9KTtcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gICAgbGF6eVdyaXRlci53cml0dGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqIEBwYXJhbSB7SXRlbSB8IEdDfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuY29uc3Qgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIgPSAobGF6eVdyaXRlciwgc3RydWN0LCBvZmZzZXQpID0+IHtcbiAgLy8gZmx1c2ggY3VyciBpZiB3ZSBzdGFydCBhbm90aGVyIGNsaWVudFxuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCAmJiBsYXp5V3JpdGVyLmN1cnJDbGllbnQgIT09IHN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICBmbHVzaExhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlcik7XG4gIH1cbiAgaWYgKGxhenlXcml0ZXIud3JpdHRlbiA9PT0gMCkge1xuICAgIGxhenlXcml0ZXIuY3VyckNsaWVudCA9IHN0cnVjdC5pZC5jbGllbnQ7XG4gICAgLy8gd3JpdGUgbmV4dCBjbGllbnRcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIud3JpdGVDbGllbnQoc3RydWN0LmlkLmNsaWVudCk7XG4gICAgLy8gd3JpdGUgc3RhcnRDbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdC5pZC5jbG9jayArIG9mZnNldCk7XG4gIH1cbiAgc3RydWN0LndyaXRlKGxhenlXcml0ZXIuZW5jb2Rlciwgb2Zmc2V0KTtcbiAgbGF6eVdyaXRlci53cml0dGVuKys7XG59O1xuLyoqXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gd2hlbiB3ZSBjb2xsZWN0ZWQgYWxsIHBhcnRzIGFuZCB3YW50IHRvXG4gKiBwdXQgYWxsIHRoZSBwYXJ0cyB0b2dldGhlci4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAqIHlvdSBjYW4gY29udGludWUgdXNpbmcgdGhlIFVwZGF0ZUVuY29kZXIuXG4gKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKi9cbmNvbnN0IGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nID0gKGxhenlXcml0ZXIpID0+IHtcbiAgZmx1c2hMYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIpO1xuXG4gIC8vIHRoaXMgaXMgYSBmcmVzaCBlbmNvZGVyIGJlY2F1c2Ugd2UgY2FsbGVkIGZsdXNoQ3VyclxuICBjb25zdCByZXN0RW5jb2RlciA9IGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlcjtcblxuICAvKipcbiAgICogTm93IHdlIHB1dCBhbGwgdGhlIGZyYWdtZW50cyB0b2dldGhlci5cbiAgICogVGhpcyB3b3JrcyBzaW1pbGFybHkgdG8gYHdyaXRlQ2xpZW50c1N0cnVjdHNgXG4gICAqL1xuXG4gIC8vIHdyaXRlICMgc3RhdGVzIHRoYXQgd2VyZSB1cGRhdGVkIC0gaS5lLiB0aGUgY2xpZW50c1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFydFN0cnVjdHMgPSBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHNbaV07XG4gICAgLyoqXG4gICAgICogV29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZVN0cnVjdHNgXG4gICAgICovXG4gICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLndyaXR0ZW4pO1xuICAgIC8vIHdyaXRlIHRoZSByZXN0IG9mIHRoZSBmcmFnbWVudFxuICAgIGVuY29kaW5nLndyaXRlVWludDhBcnJheShyZXN0RW5jb2RlciwgcGFydFN0cnVjdHMucmVzdEVuY29kZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW18R0N8U2tpcCk6SXRlbXxHQ3xTa2lwfSBibG9ja1RyYW5zZm9ybWVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBZRGVjb2RlclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYyIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB9IFlFbmNvZGVyXG4gKi9cbmNvbnN0IGNvbnZlcnRVcGRhdGVGb3JtYXQgPSAodXBkYXRlLCBibG9ja1RyYW5zZm9ybWVyLCBZRGVjb2RlciwgWUVuY29kZXIpID0+IHtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpO1xuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKTtcbiAgY29uc3QgdXBkYXRlRW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICBjb25zdCBsYXp5V3JpdGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIodXBkYXRlRW5jb2Rlcik7XG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlciwgYmxvY2tUcmFuc2Zvcm1lcihjdXJyKSwgMCk7XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVdyaXRlcik7XG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKTtcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpO1xuICByZXR1cm4gdXBkYXRlRW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPYmZ1c2NhdG9yT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbT2JmdXNjYXRvck9wdGlvbnMuZm9ybWF0dGluZz10cnVlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbT2JmdXNjYXRvck9wdGlvbnMuc3ViZG9jcz10cnVlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbT2JmdXNjYXRvck9wdGlvbnMueXhtbD10cnVlXSBXaGV0aGVyIHRvIG9iZnVzY2F0ZSBub2RlTmFtZSAvIGhvb2tOYW1lXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge09iZnVzY2F0b3JPcHRpb25zfSBvYmZ1c2NhdG9yXG4gKi9cbmNvbnN0IGNyZWF0ZU9iZnVzY2F0b3IgPSAoeyBmb3JtYXR0aW5nID0gdHJ1ZSwgc3ViZG9jcyA9IHRydWUsIHl4bWwgPSB0cnVlIH0gPSB7fSkgPT4ge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IG1hcEtleUNhY2hlID0gbWFwLmNyZWF0ZSgpO1xuICBjb25zdCBub2RlTmFtZUNhY2hlID0gbWFwLmNyZWF0ZSgpO1xuICBjb25zdCBmb3JtYXR0aW5nS2V5Q2FjaGUgPSBtYXAuY3JlYXRlKCk7XG4gIGNvbnN0IGZvcm1hdHRpbmdWYWx1ZUNhY2hlID0gbWFwLmNyZWF0ZSgpO1xuICBmb3JtYXR0aW5nVmFsdWVDYWNoZS5zZXQobnVsbCwgbnVsbCk7IC8vIGVuZCBvZiBhIGZvcm1hdHRpbmcgcmFuZ2Ugc2hvdWxkIGFsd2F5cyBiZSB0aGUgZW5kIG9mIGEgZm9ybWF0dGluZyByYW5nZVxuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfEdDfFNraXB9IGJsb2NrXG4gICAqIEByZXR1cm4ge0l0ZW18R0N8U2tpcH1cbiAgICovXG4gIHJldHVybiBibG9jayA9PiB7XG4gICAgc3dpdGNoIChibG9jay5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBHQzpcbiAgICAgIGNhc2UgU2tpcDpcbiAgICAgICAgcmV0dXJuIGJsb2NrXG4gICAgICBjYXNlIEl0ZW06IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKGJsb2NrKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGl0ZW0uY29udGVudDtcbiAgICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBDb250ZW50RGVsZXRlZDpcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBDb250ZW50VHlwZToge1xuICAgICAgICAgICAgaWYgKHl4bWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChjb250ZW50KS50eXBlO1xuICAgICAgICAgICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFlYbWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHlwZS5ub2RlTmFtZSA9IG1hcC5zZXRJZlVuZGVmaW5lZChub2RlTmFtZUNhY2hlLCB0eXBlLm5vZGVOYW1lLCAoKSA9PiAnbm9kZS0nICsgaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBZWG1sSG9vaykge1xuICAgICAgICAgICAgICAgIHR5cGUuaG9va05hbWUgPSBtYXAuc2V0SWZVbmRlZmluZWQobm9kZU5hbWVDYWNoZSwgdHlwZS5ob29rTmFtZSwgKCkgPT4gJ2hvb2stJyArIGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRBbnk6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRBbnl9ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGMuYXJyID0gYy5hcnIubWFwKCgpID0+IGkpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50QmluYXJ5OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50QmluYXJ5fSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBjLmNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbaV0pO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50RG9jOiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50RG9jfSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoc3ViZG9jcykge1xuICAgICAgICAgICAgICBjLm9wdHMgPSB7fTtcbiAgICAgICAgICAgICAgYy5kb2MuZ3VpZCA9IGkgKyAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50RW1iZWR9ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGMuZW1iZWQgPSB7fTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgYy5rZXkgPSBtYXAuc2V0SWZVbmRlZmluZWQoZm9ybWF0dGluZ0tleUNhY2hlLCBjLmtleSwgKCkgPT4gaSArICcnKTtcbiAgICAgICAgICAgICAgYy52YWx1ZSA9IG1hcC5zZXRJZlVuZGVmaW5lZChmb3JtYXR0aW5nVmFsdWVDYWNoZSwgYy52YWx1ZSwgKCkgPT4gKHsgaSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRKU09OOiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50SlNPTn0gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgYy5hcnIgPSBjLmFyci5tYXAoKCkgPT4gaSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGMuc3RyID0gc3RyaW5nLnJlcGVhdCgoaSAlIDEwKSArICcnLCBjLnN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIHVua25vd24gY29udGVudCB0eXBlXG4gICAgICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnBhcmVudFN1Yikge1xuICAgICAgICAgIGl0ZW0ucGFyZW50U3ViID0gbWFwLnNldElmVW5kZWZpbmVkKG1hcEtleUNhY2hlLCBpdGVtLnBhcmVudFN1YiwgKCkgPT4gaSArICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiBibG9ja1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gdW5rbm93biBibG9jay10eXBlXG4gICAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gb2JmdXNjYXRlcyB0aGUgY29udGVudCBvZiBhIFlqcyB1cGRhdGUuIFRoaXMgaXMgdXNlZnVsIHRvIHNoYXJlXG4gKiBidWdneSBZanMgZG9jdW1lbnRzIHdoaWxlIHNpZ25pZmljYW50bHkgbGltaXRpbmcgdGhlIHBvc3NpYmlsaXR5IHRoYXQgYVxuICogZGV2ZWxvcGVyIGNhbiBvbiB0aGUgdXNlci4gTm90ZSB0aGF0IGl0IG1pZ2h0IHN0aWxsIGJlIHBvc3NpYmxlIHRvIGRlZHVjZVxuICogc29tZSBpbmZvcm1hdGlvbiBieSBhbmFseXppbmcgdGhlIFwic3RydWN0dXJlXCIgb2YgdGhlIGRvY3VtZW50IG9yIGJ5IGFuYWx5emluZ1xuICogdGhlIHR5cGluZyBiZWhhdmlvciB1c2luZyB0aGUgQ1JEVC1yZWxhdGVkIG1ldGFkYXRhIHRoYXQgaXMgc3RpbGwga2VwdCBmdWxseVxuICogaW50YWN0LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iZnVzY2F0b3JPcHRpb25zfSBbb3B0c11cbiAqL1xuY29uc3Qgb2JmdXNjYXRlVXBkYXRlID0gKHVwZGF0ZSwgb3B0cykgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGNyZWF0ZU9iZnVzY2F0b3Iob3B0cyksIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtPYmZ1c2NhdG9yT3B0aW9uc30gW29wdHNdXG4gKi9cbmNvbnN0IG9iZnVzY2F0ZVVwZGF0ZVYyID0gKHVwZGF0ZSwgb3B0cykgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGNyZWF0ZU9iZnVzY2F0b3Iob3B0cyksIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYyKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5jb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyID0gdXBkYXRlID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBmLmlkLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMik7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSA9IHVwZGF0ZSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgZi5pZCwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEpO1xuXG5jb25zdCBlcnJvckNvbXB1dGVDaGFuZ2VzID0gJ1lvdSBtdXN0IG5vdCBjb21wdXRlIGNoYW5nZXMgYWZ0ZXIgdGhlIGV2ZW50LWhhbmRsZXIgZmlyZWQuJztcblxuLyoqXG4gKiBAdGVtcGxhdGUge0Fic3RyYWN0VHlwZTxhbnk+fSBUXG4gKiBZRXZlbnQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVR5cGUuXG4gKi9cbmNsYXNzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IHRhcmdldCBUaGUgY2hhbmdlZCB0eXBlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgdHJhbnNhY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvbiB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkIG9uLlxuICAgICAqIEB0eXBlIHtUfVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHRhcmdldCBvbiB3aGljaCB0aGUgb2JzZXJ2ZSBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNhY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9jaGFuZ2VzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IE1hcDxzdHJpbmcsIHsgYWN0aW9uOiAnYWRkJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIG9sZFZhbHVlOiBhbnksIG5ld1ZhbHVlOiBhbnkgfT59XG4gICAgICovXG4gICAgdGhpcy5fa2V5cyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBBcnJheTx7IGluc2VydD86IHN0cmluZyB8IEFycmF5PGFueT4gfCBvYmplY3QgfCBBYnN0cmFjdFR5cGU8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2RlbHRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nfG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wYXRoID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgcGF0aCBmcm9tIGB5YCB0byB0aGUgY2hhbmdlZCB0eXBlLlxuICAgKlxuICAgKiBAdG9kbyB2MTQgc2hvdWxkIHN0YW5kYXJkaXplIG9uIHBhdGg6IEFycmF5PHtwYXJlbnQsIGluZGV4fT4gYmVjYXVzZSB0aGF0IGlzIGVhc2llciB0byB3b3JrIHdpdGguXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydHkgaG9sZHM6XG4gICAqIEBleGFtcGxlXG4gICAqICAgbGV0IHR5cGUgPSB5XG4gICAqICAgZXZlbnQucGF0aC5mb3JFYWNoKGRpciA9PiB7XG4gICAqICAgICB0eXBlID0gdHlwZS5nZXQoZGlyKVxuICAgKiAgIH0pXG4gICAqICAgdHlwZSA9PT0gZXZlbnQudGFyZ2V0IC8vID0+IHRydWVcbiAgICovXG4gIGdldCBwYXRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aCB8fCAodGhpcy5fcGF0aCA9IGdldFBhdGhUbyh0aGlzLmN1cnJlbnRUYXJnZXQsIHRoaXMudGFyZ2V0KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBkZWxldGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGRlbGV0ZXMgKHN0cnVjdCkge1xuICAgIHJldHVybiBpc0RlbGV0ZWQodGhpcy50cmFuc2FjdGlvbi5kZWxldGVTZXQsIHN0cnVjdC5pZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICovXG4gIGdldCBrZXlzICgpIHtcbiAgICBpZiAodGhpcy5fa2V5cyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBlcnJvci5jcmVhdGUoZXJyb3JDb21wdXRlQ2hhbmdlcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5nZWQgPSAvKiogQHR5cGUgU2V0PHN0cmluZ3xudWxsPiAqLyAodGhpcy50cmFuc2FjdGlvbi5jaGFuZ2VkLmdldCh0YXJnZXQpKTtcbiAgICAgIGNoYW5nZWQuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHRhcmdldC5fbWFwLmdldChrZXkpKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7J2RlbGV0ZScgfCAnYWRkJyB8ICd1cGRhdGUnfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCBhY3Rpb247XG4gICAgICAgICAgbGV0IG9sZFZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gaXRlbS5sZWZ0O1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgIT09IG51bGwgJiYgdGhpcy5hZGRzKHByZXYpKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwcmV2LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHRoaXMuZGVsZXRlcyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdChwcmV2LmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ3VwZGF0ZSc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdhZGQnO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdCgvKiogQHR5cGUge0l0ZW19ICovIGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC8vIG5vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzLnNldChrZXksIHsgYWN0aW9uLCBvbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29tcHV0ZWQgcHJvcGVydHkuIE5vdGUgdGhhdCB0aGlzIGNhbiBvbmx5IGJlIHNhZmVseSBjb21wdXRlZCBkdXJpbmcgdGhlXG4gICAqIGV2ZW50IGNhbGwuIENvbXB1dGluZyB0aGlzIHByb3BlcnR5IGFmdGVyIG90aGVyIGNoYW5nZXMgaGFwcGVuZWQgbWlnaHQgcmVzdWx0IGluXG4gICAqIHVuZXhwZWN0ZWQgYmVoYXZpb3IgKGluY29ycmVjdCBjb21wdXRhdGlvbiBvZiBkZWx0YXMpLiBBIHNhZmUgd2F5IHRvIGNvbGxlY3QgY2hhbmdlc1xuICAgKiBpcyB0byBzdG9yZSB0aGUgYGNoYW5nZXNgIG9yIHRoZSBgZGVsdGFgIG9iamVjdC4gQXZvaWQgc3RvcmluZyB0aGUgYHRyYW5zYWN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiB8IG9iamVjdCB8IEFic3RyYWN0VHlwZTxhbnk+LCByZXRhaW4/OiBudW1iZXIsIGRlbGV0ZT86IG51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsIGFueT59Pn1cbiAgICovXG4gIGdldCBkZWx0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5kZWx0YVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RydWN0IGlzIGFkZGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFkZHMgKHN0cnVjdCkge1xuICAgIHJldHVybiBzdHJ1Y3QuaWQuY2xvY2sgPj0gKHRoaXMudHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KHN0cnVjdC5pZC5jbGllbnQpIHx8IDApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBOb3RlIHRoYXQgdGhpcyBjYW4gb25seSBiZSBzYWZlbHkgY29tcHV0ZWQgZHVyaW5nIHRoZVxuICAgKiBldmVudCBjYWxsLiBDb21wdXRpbmcgdGhpcyBwcm9wZXJ0eSBhZnRlciBvdGhlciBjaGFuZ2VzIGhhcHBlbmVkIG1pZ2h0IHJlc3VsdCBpblxuICAgKiB1bmV4cGVjdGVkIGJlaGF2aW9yIChpbmNvcnJlY3QgY29tcHV0YXRpb24gb2YgZGVsdGFzKS4gQSBzYWZlIHdheSB0byBjb2xsZWN0IGNoYW5nZXNcbiAgICogaXMgdG8gc3RvcmUgdGhlIGBjaGFuZ2VzYCBvciB0aGUgYGRlbHRhYCBvYmplY3QuIEF2b2lkIHN0b3JpbmcgdGhlIGB0cmFuc2FjdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgKi9cbiAgZ2V0IGNoYW5nZXMgKCkge1xuICAgIGxldCBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlcztcbiAgICBpZiAoY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBlcnJvci5jcmVhdGUoZXJyb3JDb21wdXRlQ2hhbmdlcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgY29uc3QgYWRkZWQgPSBzZXQuY3JlYXRlKCk7XG4gICAgICBjb25zdCBkZWxldGVkID0gc2V0LmNyZWF0ZSgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydDpBcnJheTxhbnk+fXx7ZGVsZXRlOm51bWJlcn18e3JldGFpbjpudW1iZXJ9Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICAgIGNoYW5nZXMgPSB7XG4gICAgICAgIGFkZGVkLFxuICAgICAgICBkZWxldGVkLFxuICAgICAgICBkZWx0YSxcbiAgICAgICAga2V5czogdGhpcy5rZXlzXG4gICAgICB9O1xuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpO1xuICAgICAgaWYgKGNoYW5nZWQuaGFzKG51bGwpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxhc3RPcCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhY2tPcCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAobGFzdE9wKSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKGxhc3RPcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpdGVtID0gdGFyZ2V0Ll9zdGFydDsgaXRlbSAhPT0gbnVsbDsgaXRlbSA9IGl0ZW0ucmlnaHQpIHtcbiAgICAgICAgICBpZiAoaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pICYmICF0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuZGVsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGRlbGV0ZTogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5kZWxldGUgKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIGRlbGV0ZWQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfSAvLyBlbHNlIG5vcFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBpbnNlcnQ6IFtdIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmluc2VydCA9IGxhc3RPcC5pbnNlcnQuY29uY2F0KGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICBhZGRlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgcmV0YWluOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLnJldGFpbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RPcCAhPT0gbnVsbCAmJiBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNoYW5nZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwYXRoIGZyb20gdGhpcyB0eXBlIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIGBjaGlsZGAgc2hvdWxkIGJlIGFjY2Vzc2libGUgdmlhIGB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSkuLmBcbiAqICAgY29uc3QgcGF0aCA9IHR5cGUuZ2V0UGF0aFRvKGNoaWxkKVxuICogICAvLyBhc3N1bWluZyBgdHlwZSBpbnN0YW5jZW9mIFlBcnJheWBcbiAqICAgY29uc29sZS5sb2cocGF0aCkgLy8gbWlnaHQgbG9vayBsaWtlID0+IFsyLCAna2V5MSddXG4gKiAgIGNoaWxkID09PSB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSlcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IGNoaWxkIHRhcmdldFxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG51bWJlcj59IFBhdGggdG8gdGhlIHRhcmdldFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0UGF0aFRvID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICB3aGlsZSAoY2hpbGQuX2l0ZW0gIT09IG51bGwgJiYgY2hpbGQgIT09IHBhcmVudCkge1xuICAgIGlmIChjaGlsZC5faXRlbS5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBtYXAtaXNoXG4gICAgICBwYXRoLnVuc2hpZnQoY2hpbGQuX2l0ZW0ucGFyZW50U3ViKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIGFycmF5LWlzaFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGMgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQuX2l0ZW0ucGFyZW50KS5fc3RhcnQ7XG4gICAgICB3aGlsZSAoYyAhPT0gY2hpbGQuX2l0ZW0gJiYgYyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWMuZGVsZXRlZCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBjID0gYy5yaWdodDtcbiAgICAgIH1cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQuX2l0ZW0ucGFyZW50KTtcbiAgfVxuICByZXR1cm4gcGF0aFxufTtcblxuY29uc3QgbWF4U2VhcmNoTWFya2VyID0gODA7XG5cbi8qKlxuICogQSB1bmlxdWUgdGltZXN0YW1wIHRoYXQgaWRlbnRpZmllcyBlYWNoIG1hcmtlci5cbiAqXG4gKiBUaW1lIGlzIHJlbGF0aXZlLC4uIHRoaXMgaXMgbW9yZSBsaWtlIGFuIGV2ZXItaW5jcmVhc2luZyBjbG9jay5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wID0gMDtcblxuY2xhc3MgQXJyYXlTZWFyY2hNYXJrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfSBwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHAsIGluZGV4KSB7XG4gICAgcC5tYXJrZXIgPSB0cnVlO1xuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqL1xuY29uc3QgcmVmcmVzaE1hcmtlclRpbWVzdGFtcCA9IG1hcmtlciA9PiB7IG1hcmtlci50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKzsgfTtcblxuLyoqXG4gKiBUaGlzIGlzIHJhdGhlciBjb21wbGV4IHNvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9ubHkgdGhpbmcgdGhhdCBzaG91bGQgb3ZlcndyaXRlIGEgbWFya2VyXG4gKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKiBAcGFyYW0ge0l0ZW19IHBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBvdmVyd3JpdGVNYXJrZXIgPSAobWFya2VyLCBwLCBpbmRleCkgPT4ge1xuICBtYXJrZXIucC5tYXJrZXIgPSBmYWxzZTtcbiAgbWFya2VyLnAgPSBwO1xuICBwLm1hcmtlciA9IHRydWU7XG4gIG1hcmtlci5pbmRleCA9IGluZGV4O1xuICBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG1hcmtQb3NpdGlvbiA9IChzZWFyY2hNYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIGlmIChzZWFyY2hNYXJrZXIubGVuZ3RoID49IG1heFNlYXJjaE1hcmtlcikge1xuICAgIC8vIG92ZXJyaWRlIG9sZGVzdCBtYXJrZXIgKHdlIGRvbid0IHdhbnQgdG8gY3JlYXRlIG1vcmUgb2JqZWN0cylcbiAgICBjb25zdCBtYXJrZXIgPSBzZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBhLnRpbWVzdGFtcCA8IGIudGltZXN0YW1wID8gYSA6IGIpO1xuICAgIG92ZXJ3cml0ZU1hcmtlcihtYXJrZXIsIHAsIGluZGV4KTtcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICBjb25zdCBwbSA9IG5ldyBBcnJheVNlYXJjaE1hcmtlcihwLCBpbmRleCk7XG4gICAgc2VhcmNoTWFya2VyLnB1c2gocG0pO1xuICAgIHJldHVybiBwbVxuICB9XG59O1xuXG4vKipcbiAqIFNlYXJjaCBtYXJrZXIgaGVscCB1cyB0byBmaW5kIHBvc2l0aW9ucyBpbiB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgZmFzdGVyLlxuICpcbiAqIFRoZXkgc3BlZWQgdXAgdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHBvc2l0aW9uIHdpdGhvdXQgbXVjaCBib29ra2VlcGluZy5cbiAqXG4gKiBBIG1heGltdW0gb2YgYG1heFNlYXJjaE1hcmtlcmAgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgcmVmcmVzaGVkIG1hcmtlciAodXBkYXRlZCB0aW1lc3RhbXApXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0geWFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgZmluZE1hcmtlciA9ICh5YXJyYXksIGluZGV4KSA9PiB7XG4gIGlmICh5YXJyYXkuX3N0YXJ0ID09PSBudWxsIHx8IGluZGV4ID09PSAwIHx8IHlhcnJheS5fc2VhcmNoTWFya2VyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBtYXJrZXIgPSB5YXJyYXkuX3NlYXJjaE1hcmtlci5sZW5ndGggPT09IDAgPyBudWxsIDogeWFycmF5Ll9zZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBtYXRoLmFicyhpbmRleCAtIGEuaW5kZXgpIDwgbWF0aC5hYnMoaW5kZXggLSBiLmluZGV4KSA/IGEgOiBiKTtcbiAgbGV0IHAgPSB5YXJyYXkuX3N0YXJ0O1xuICBsZXQgcGluZGV4ID0gMDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIHAgPSBtYXJrZXIucDtcbiAgICBwaW5kZXggPSBtYXJrZXIuaW5kZXg7XG4gICAgcmVmcmVzaE1hcmtlclRpbWVzdGFtcChtYXJrZXIpOyAvLyB3ZSB1c2VkIGl0LCB3ZSBtaWdodCBuZWVkIHRvIHVzZSBpdCBhZ2FpblxuICB9XG4gIC8vIGl0ZXJhdGUgdG8gcmlnaHQgaWYgcG9zc2libGVcbiAgd2hpbGUgKHAucmlnaHQgIT09IG51bGwgJiYgcGluZGV4IDwgaW5kZXgpIHtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgcGluZGV4ICsgcC5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBpbmRleCArPSBwLmxlbmd0aDtcbiAgICB9XG4gICAgcCA9IHAucmlnaHQ7XG4gIH1cbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IGlmIG5lY2Vzc2FyeSAobWlnaHQgYmUgdGhhdCBwaW5kZXggPiBpbmRleClcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwaW5kZXggPiBpbmRleCkge1xuICAgIHAgPSBwLmxlZnQ7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnQsIGJlY2F1c2UgdGhhdCB3b3VsZCBzY3JldyB1cCBldmVyeXRoaW5nXG4gIC8vIGluIHRoYXQgY2FzIGp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZSAoaXQgaXMgbW9zdCBsaWtlbHkgdGhlIGJlc3QgbWFya2VyIGFueXdheSlcbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IHVudGlsIHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdFxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHAubGVmdC5pZC5jbGllbnQgPT09IHAuaWQuY2xpZW50ICYmIHAubGVmdC5pZC5jbG9jayArIHAubGVmdC5sZW5ndGggPT09IHAuaWQuY2xvY2spIHtcbiAgICBwID0gcC5sZWZ0O1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLy8gQHRvZG8gcmVtb3ZlIVxuICAvLyBhc3N1cmUgcG9zaXRpb25cbiAgLy8ge1xuICAvLyAgIGxldCBzdGFydCA9IHlhcnJheS5fc3RhcnRcbiAgLy8gICBsZXQgcG9zID0gMFxuICAvLyAgIHdoaWxlIChzdGFydCAhPT0gcCkge1xuICAvLyAgICAgaWYgKCFzdGFydC5kZWxldGVkICYmIHN0YXJ0LmNvdW50YWJsZSkge1xuICAvLyAgICAgICBwb3MgKz0gc3RhcnQubGVuZ3RoXG4gIC8vICAgICB9XG4gIC8vICAgICBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0YXJ0LnJpZ2h0KVxuICAvLyAgIH1cbiAgLy8gICBpZiAocG9zICE9PSBwaW5kZXgpIHtcbiAgLy8gICAgIGRlYnVnZ2VyXG4gIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvdGNoYSBwb3NpdGlvbiBmYWlsIScpXG4gIC8vICAgfVxuICAvLyB9XG4gIC8vIGlmIChtYXJrZXIpIHtcbiAgLy8gICBpZiAod2luZG93Lmxlbmd0aGVzID09IG51bGwpIHtcbiAgLy8gICAgIHdpbmRvdy5sZW5ndGhlcyA9IFtdXG4gIC8vICAgICB3aW5kb3cuZ2V0TGVuZ3RoZXMgPSAoKSA9PiB3aW5kb3cubGVuZ3RoZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIC8vICAgfVxuICAvLyAgIHdpbmRvdy5sZW5ndGhlcy5wdXNoKG1hcmtlci5pbmRleCAtIHBpbmRleClcbiAgLy8gICBjb25zb2xlLmxvZygnZGlzdGFuY2UnLCBtYXJrZXIuaW5kZXggLSBwaW5kZXgsICdsZW4nLCBwICYmIHAucGFyZW50Lmxlbmd0aClcbiAgLy8gfVxuICBpZiAobWFya2VyICE9PSBudWxsICYmIG1hdGguYWJzKG1hcmtlci5pbmRleCAtIHBpbmRleCkgPCAvKiogQHR5cGUge1lUZXh0fFlBcnJheTxhbnk+fSAqLyAocC5wYXJlbnQpLmxlbmd0aCAvIG1heFNlYXJjaE1hcmtlcikge1xuICAgIC8vIGFkanVzdCBleGlzdGluZyBtYXJrZXJcbiAgICBvdmVyd3JpdGVNYXJrZXIobWFya2VyLCBwLCBwaW5kZXgpO1xuICAgIHJldHVybiBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgbmV3IG1hcmtlclxuICAgIHJldHVybiBtYXJrUG9zaXRpb24oeWFycmF5Ll9zZWFyY2hNYXJrZXIsIHAsIHBpbmRleClcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgbWFya2VycyB3aGVuIGEgY2hhbmdlIGhhcHBlbmVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgZG9pbmcgYSBkZWxldGlvbiFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn0gc2VhcmNoTWFya2VyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gSWYgaW5zZXJ0aW9uLCBsZW4gaXMgcG9zaXRpdmUuIElmIGRlbGV0aW9uLCBsZW4gaXMgbmVnYXRpdmUuXG4gKi9cbmNvbnN0IHVwZGF0ZU1hcmtlckNoYW5nZXMgPSAoc2VhcmNoTWFya2VyLCBpbmRleCwgbGVuKSA9PiB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hNYXJrZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBtID0gc2VhcmNoTWFya2VyW2ldO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCBwID0gbS5wO1xuICAgICAgcC5tYXJrZXIgPSBmYWxzZTtcbiAgICAgIC8vIElkZWFsbHkgd2UganVzdCB3YW50IHRvIGRvIGEgc2ltcGxlIHBvc2l0aW9uIGNvbXBhcmlzb24sIGJ1dCB0aGlzIHdpbGwgb25seSB3b3JrIGlmXG4gICAgICAvLyBzZWFyY2ggbWFya2VycyBkb24ndCBwb2ludCB0byBkZWxldGVkIGl0ZW1zIGZvciBmb3JtYXRzLlxuICAgICAgLy8gSXRlcmF0ZSBtYXJrZXIgdG8gcHJldiB1bmRlbGV0ZWQgY291bnRhYmxlIHBvc2l0aW9uIHNvIHdlIGtub3cgd2hhdCB0byBkbyB3aGVuIHVwZGF0aW5nIGEgcG9zaXRpb25cbiAgICAgIHdoaWxlIChwICYmIChwLmRlbGV0ZWQgfHwgIXAuY291bnRhYmxlKSkge1xuICAgICAgICBwID0gcC5sZWZ0O1xuICAgICAgICBpZiAocCAmJiAhcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICAgICAgLy8gYWRqdXN0IHBvc2l0aW9uLiB0aGUgbG9vcCBzaG91bGQgYnJlYWsgbm93XG4gICAgICAgICAgbS5pbmRleCAtPSBwLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHAgPT09IG51bGwgfHwgcC5tYXJrZXIgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHNlYXJjaCBtYXJrZXIgaWYgdXBkYXRlZCBwb3NpdGlvbiBpcyBudWxsIG9yIGlmIHBvc2l0aW9uIGlzIGFscmVhZHkgbWFya2VkXG4gICAgICAgIHNlYXJjaE1hcmtlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBtLnAgPSBwO1xuICAgICAgcC5tYXJrZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCBtLmluZGV4IHx8IChsZW4gPiAwICYmIGluZGV4ID09PSBtLmluZGV4KSkgeyAvLyBhIHNpbXBsZSBpbmRleCA8PSBtLmluZGV4IGNoZWNrIHdvdWxkIGFjdHVhbGx5IHN1ZmZpY2VcbiAgICAgIG0uaW5kZXggPSBtYXRoLm1heChpbmRleCwgbS5pbmRleCArIGxlbik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFjY3VtdWxhdGUgYWxsIChsaXN0KSBjaGlsZHJlbiBvZiBhIHR5cGUgYW5kIHJldHVybiB0aGVtIGFzIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHRcbiAqIEByZXR1cm4ge0FycmF5PEl0ZW0+fVxuICovXG5jb25zdCBnZXRUeXBlQ2hpbGRyZW4gPSB0ID0+IHtcbiAgbGV0IHMgPSB0Ll9zdGFydDtcbiAgY29uc3QgYXJyID0gW107XG4gIHdoaWxlIChzKSB7XG4gICAgYXJyLnB1c2gocyk7XG4gICAgcyA9IHMucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGFyclxufTtcblxuLyoqXG4gKiBDYWxsIGV2ZW50IGxpc3RlbmVycyB3aXRoIGFuIGV2ZW50LiBUaGlzIHdpbGwgYWxzbyBhZGQgYW4gZXZlbnQgdG8gYWxsXG4gKiBwYXJlbnRzIChmb3IgYC5vYnNlcnZlRGVlcGAgaGFuZGxlcnMpLlxuICpcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59IHR5cGVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0V2ZW50VHlwZX0gZXZlbnRcbiAqL1xuY29uc3QgY2FsbFR5cGVPYnNlcnZlcnMgPSAodHlwZSwgdHJhbnNhY3Rpb24sIGV2ZW50KSA9PiB7XG4gIGNvbnN0IGNoYW5nZWRUeXBlID0gdHlwZTtcbiAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbmdlZFBhcmVudFR5cGVzLCB0eXBlLCAoKSA9PiBbXSkucHVzaChldmVudCk7XG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodHlwZS5faXRlbS5wYXJlbnQpO1xuICB9XG4gIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMoY2hhbmdlZFR5cGUuX2VILCBldmVudCwgdHJhbnNhY3Rpb24pO1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBBYnN0cmFjdCBZanMgVHlwZSBjbGFzc1xuICovXG5jbGFzcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXJzXG4gICAgICogQHR5cGUge0V2ZW50SGFuZGxlcjxFdmVudFR5cGUsVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX2VIID0gY3JlYXRlRXZlbnRIYW5kbGVyKCk7XG4gICAgLyoqXG4gICAgICogRGVlcCBldmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8QXJyYXk8WUV2ZW50PGFueT4+LFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9kRUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxhbnk+fG51bGx9XG4gICAqL1xuICBnZXQgcGFyZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbSA/IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLl9pdGVtLnBhcmVudCkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICB0aGlzLmRvYyA9IHk7XG4gICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IF9lbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKF9lbmNvZGVyKSB7IH1cblxuICAvKipcbiAgICogVGhlIGZpcnN0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBfZmlyc3QgKCkge1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlFdmVudCBhbmQgY2FsbHMgYWxsIHR5cGUgb2JzZXJ2ZXJzLlxuICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBfcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgX3BhcmVudFN1YnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdGhpcy5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsIFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIGJ5IHRoaXMgdHlwZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudDxhbnk+PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgb2JzZXJ2ZURlZXAgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICB1bm9ic2VydmUgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ8YW55Pj4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZURlZXAgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICB0b0pTT04gKCkge31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFNsaWNlID0gKHR5cGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdHlwZS5fbGVuZ3RoICsgc3RhcnQ7XG4gIH1cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSB0eXBlLl9sZW5ndGggKyBlbmQ7XG4gIH1cbiAgbGV0IGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCAmJiBsZW4gPiAwKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgaWYgKGMubGVuZ3RoIDw9IHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0IC09IGMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgYy5sZW5ndGggJiYgbGVuID4gMDsgaSsrKSB7XG4gICAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RUb0FycmF5ID0gdHlwZSA9PiB7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0VG9BcnJheVNuYXBzaG90ID0gKHR5cGUsIHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmIGlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gb3ZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxudW1iZXIsYW55KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RGb3JFYWNoID0gKHR5cGUsIGYpID0+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZihjW2ldLCBpbmRleCsrLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIEMsUlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihDLG51bWJlcixBYnN0cmFjdFR5cGU8YW55Pik6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdE1hcCA9ICh0eXBlLCBmKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0eXBlTGlzdEZvckVhY2godHlwZSwgKGMsIGkpID0+IHtcbiAgICByZXN1bHQucHVzaChmKGMsIGksIHR5cGUpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RDcmVhdGVJdGVyYXRvciA9IHR5cGUgPT4ge1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICovXG4gIGxldCBjdXJyZW50Q29udGVudCA9IG51bGw7XG4gIGxldCBjdXJyZW50Q29udGVudEluZGV4ID0gMDtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgLy8gZmluZCBzb21lIGNvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSByZWFjaGVkIHRoZSBlbmQsIG5vIG5lZWQgdG8gY2hlY2sgY3VycmVudENvbnRlbnQsIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZm91bmQgbiwgc28gd2UgY2FuIHNldCBjdXJyZW50Q29udGVudFxuICAgICAgICBjdXJyZW50Q29udGVudCA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICAgIGN1cnJlbnRDb250ZW50SW5kZXggPSAwO1xuICAgICAgICBuID0gbi5yaWdodDsgLy8gd2UgdXNlZCB0aGUgY29udGVudCBvZiBuLCBub3cgaXRlcmF0ZSB0byBuZXh0XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRDb250ZW50W2N1cnJlbnRDb250ZW50SW5kZXgrK107XG4gICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGVtcHR5IGN1cnJlbnRDb250ZW50XG4gICAgICBpZiAoY3VycmVudENvbnRlbnQubGVuZ3RoIDw9IGN1cnJlbnRDb250ZW50SW5kZXgpIHtcbiAgICAgICAgY3VycmVudENvbnRlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7YW55fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RHZXQgPSAodHlwZSwgaW5kZXgpID0+IHtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcih0eXBlLCBpbmRleCk7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnA7XG4gICAgaW5kZXggLT0gbWFya2VyLmluZGV4O1xuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbi5jb250ZW50LmdldENvbnRlbnQoKVtpbmRleF1cbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW0/fSByZWZlcmVuY2VJdGVtXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fGJvb2xlYW58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgcmVmZXJlbmNlSXRlbSwgY29udGVudCkgPT4ge1xuICBsZXQgbGVmdCA9IHJlZmVyZW5jZUl0ZW07XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCByaWdodCA9IHJlZmVyZW5jZUl0ZW0gPT09IG51bGwgPyBwYXJlbnQuX3N0YXJ0IDogcmVmZXJlbmNlSXRlbS5yaWdodDtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3R8QXJyYXk8YW55PnxudW1iZXJ8bnVsbD59XG4gICAqL1xuICBsZXQganNvbkNvbnRlbnQgPSBbXTtcbiAgY29uc3QgcGFja0pzb25Db250ZW50ID0gKCkgPT4ge1xuICAgIGlmIChqc29uQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRBbnkoanNvbkNvbnRlbnQpKTtcbiAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIGpzb25Db250ZW50ID0gW107XG4gICAgfVxuICB9O1xuICBjb250ZW50LmZvckVhY2goYyA9PiB7XG4gICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgIGpzb25Db250ZW50LnB1c2goYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAganNvbkNvbnRlbnQucHVzaChjKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBhY2tKc29uQ29udGVudCgpO1xuICAgICAgICAgIHN3aXRjaCAoYy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICAgICAgY2FzZSBBcnJheUJ1ZmZlcjpcbiAgICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50QmluYXJ5KG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi8gKGMpKSkpO1xuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIERvYzpcbiAgICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50RG9jKC8qKiBAdHlwZSB7RG9jfSAqLyAoYykpKTtcbiAgICAgICAgICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRUeXBlKGMpKTtcbiAgICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZSBpbiBpbnNlcnQgb3BlcmF0aW9uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBwYWNrSnNvbkNvbnRlbnQoKTtcbn07XG5cbmNvbnN0IGxlbmd0aEV4Y2VlZGVkID0gKCkgPT4gZXJyb3IuY3JlYXRlKCdMZW5ndGggZXhjZWVkZWQhJyk7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgY29udGVudCkgPT4ge1xuICBpZiAoaW5kZXggPiBwYXJlbnQuX2xlbmd0aCkge1xuICAgIHRocm93IGxlbmd0aEV4Y2VlZGVkKClcbiAgfVxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGluZGV4LCBjb250ZW50Lmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbnVsbCwgY29udGVudClcbiAgfVxuICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gICAgLy8gd2UgbmVlZCB0byBpdGVyYXRlIG9uZSB0byB0aGUgbGVmdCBzbyB0aGF0IHRoZSBhbGdvcml0aG0gd29ya3NcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIEB0b2RvIHJlZmFjdG9yIHRoaXMgYXMgaXQgYWN0dWFsbHkgZG9lc24ndCBjb25zaWRlciBmb3JtYXRzXG4gICAgICBuID0gbi5wcmV2OyAvLyBpbXBvcnRhbnQhIGdldCB0aGUgbGVmdCB1bmRlbGV0ZWQgaXRlbSBzbyB0aGF0IHdlIGNhbiBhY3R1YWxseSBkZWNyZWFzZSBpbmRleFxuICAgICAgaW5kZXggKz0gKG4gJiYgbi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkgPyBuLmxlbmd0aCA6IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPD0gbi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgaW4tYmV0d2VlblxuICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCBjb250ZW50Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBuLCBjb250ZW50KVxufTtcblxuLyoqXG4gKiBQdXNoaW5nIGNvbnRlbnQgaXMgc3BlY2lhbCBhcyB3ZSBnZW5lcmFsbHkgd2FudCB0byBwdXNoIGFmdGVyIHRoZSBsYXN0IGl0ZW0uIFNvIHdlIGRvbid0IGhhdmUgdG8gdXBkYXRlXG4gKiB0aGUgc2VyYWNoIG1hcmtlci5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RQdXNoR2VuZXJpY3MgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY29udGVudCkgPT4ge1xuICAvLyBVc2UgdGhlIG1hcmtlciB3aXRoIHRoZSBoaWdoZXN0IGluZGV4IGFuZCBpdGVyYXRlIHRvIHRoZSByaWdodC5cbiAgY29uc3QgbWFya2VyID0gKHBhcmVudC5fc2VhcmNoTWFya2VyIHx8IFtdKS5yZWR1Y2UoKG1heE1hcmtlciwgY3Vyck1hcmtlcikgPT4gY3Vyck1hcmtlci5pbmRleCA+IG1heE1hcmtlci5pbmRleCA/IGN1cnJNYXJrZXIgOiBtYXhNYXJrZXIsIHsgaW5kZXg6IDAsIHA6IHBhcmVudC5fc3RhcnQgfSk7XG4gIGxldCBuID0gbWFya2VyLnA7XG4gIGlmIChuKSB7XG4gICAgd2hpbGUgKG4ucmlnaHQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3REZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICBpZiAobGVuZ3RoID09PSAwKSB7IHJldHVybiB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgLy8gY29tcHV0ZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBkZWxldGVkXG4gIGZvciAoOyBuICE9PSBudWxsICYmIGluZGV4ID4gMDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyBkZWxldGUgYWxsIGl0ZW1zIHVudGlsIGRvbmVcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgbiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBuLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICBsZW5ndGggLT0gbi5sZW5ndGg7XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbGVuZ3RoRXhjZWVkZWQoKVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIC1zdGFydExlbmd0aCArIGxlbmd0aCAvKiBpbiBjYXNlIHdlIHJlbW92ZSB0aGUgYWJvdmUgZXhjZXB0aW9uICovKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwRGVsZXRlID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCBjID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICBjLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pn0gdmFsdWVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBTZXQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwga2V5LCB2YWx1ZSkgPT4ge1xuICBjb25zdCBsZWZ0ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgY29udGVudCA9IG5ldyBDb250ZW50QW55KFt2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50QmluYXJ5KC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi8gKHZhbHVlKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIERvYzpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50RG9jKC8qKiBAdHlwZSB7RG9jfSAqLyAodmFsdWUpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudFR5cGUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIG51bGwsIG51bGwsIHBhcmVudCwga2V5LCBjb250ZW50KS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXQgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWQgPyB2YWwuY29udGVudC5nZXRDb250ZW50KClbdmFsLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWQ+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldEFsbCA9IChwYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fTtcbiAgcGFyZW50Ll9tYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICghdmFsdWUuZGVsZXRlZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWx1ZS5jb250ZW50LmdldENvbnRlbnQoKVt2YWx1ZS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBIYXMgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldFNuYXBzaG90ID0gKHBhcmVudCwga2V5LCBzbmFwc2hvdCkgPT4ge1xuICBsZXQgdiA9IHBhcmVudC5fbWFwLmdldChrZXkpIHx8IG51bGw7XG4gIHdoaWxlICh2ICE9PSBudWxsICYmICghc25hcHNob3Quc3YuaGFzKHYuaWQuY2xpZW50KSB8fCB2LmlkLmNsb2NrID49IChzbmFwc2hvdC5zdi5nZXQodi5pZC5jbGllbnQpIHx8IDApKSkge1xuICAgIHYgPSB2LmxlZnQ7XG4gIH1cbiAgcmV0dXJuIHYgIT09IG51bGwgJiYgaXNWaXNpYmxlKHYsIHNuYXBzaG90KSA/IHYuY29udGVudC5nZXRDb250ZW50KClbdi5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLE9iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZD59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwR2V0QWxsU25hcHNob3QgPSAocGFyZW50LCBzbmFwc2hvdCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIGNvbnN0IHJlcyA9IHt9O1xuICBwYXJlbnQuX21hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgdiA9IHZhbHVlO1xuICAgIHdoaWxlICh2ICE9PSBudWxsICYmICghc25hcHNob3Quc3YuaGFzKHYuaWQuY2xpZW50KSB8fCB2LmlkLmNsb2NrID49IChzbmFwc2hvdC5zdi5nZXQodi5pZC5jbGllbnQpIHx8IDApKSkge1xuICAgICAgdiA9IHYubGVmdDtcbiAgICB9XG4gICAgaWYgKHYgIT09IG51bGwgJiYgaXNWaXNpYmxlKHYsIHNuYXBzaG90KSkge1xuICAgICAgcmVzW2tleV0gPSB2LmNvbnRlbnQuZ2V0Q29udGVudCgpW3YubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsSXRlbT59IG1hcFxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxBcnJheTxhbnk+Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZU1hcEl0ZXJhdG9yID0gbWFwID0+IGl0ZXJhdG9yLml0ZXJhdG9yRmlsdGVyKG1hcC5lbnRyaWVzKCksIC8qKiBAcGFyYW0ge2FueX0gZW50cnkgKi8gZW50cnkgPT4gIWVudHJ5WzFdLmRlbGV0ZWQpO1xuXG4vKipcbiAqIEBtb2R1bGUgWUFycmF5XG4gKi9cblxuXG4vKipcbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWUFycmF5XG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgWUV2ZW50PFlBcnJheTxUPj5cbiAqL1xuY2xhc3MgWUFycmF5RXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZQXJyYXk8VD59IHlhcnJheSBUaGUgY2hhbmdlZCB0eXBlXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5YXJyYXksIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIoeWFycmF5LCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEEgc2hhcmVkIEFycmF5IGltcGxlbWVudGF0aW9uLlxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZQXJyYXlFdmVudDxUPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxUPn1cbiAqL1xuY2xhc3MgWUFycmF5IGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT4/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59XG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoTWFya2VyID0gW107XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IFlBcnJheSBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgaXRlbXMuXG4gICAqIEB0ZW1wbGF0ZSB7T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXl9IFRcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gaXRlbXNcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgc3RhdGljIGZyb20gKGl0ZW1zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lBcnJheTxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBhID0gbmV3IFlBcnJheSgpO1xuICAgIGEucHVzaChpdGVtcyk7XG4gICAgcmV0dXJuIGFcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZQXJyYXkoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WUFycmF5PFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGFyciA9IG5ldyBZQXJyYXkoKTtcbiAgICBhcnIuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChlbCA9PlxuICAgICAgZWwgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyAvKiogQHR5cGUge3R5cGVvZiBlbH0gKi8gKGVsLmNsb25lKCkpIDogZWxcbiAgICApKTtcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlbGltQ29udGVudCA9PT0gbnVsbCA/IHRoaXMuX2xlbmd0aCA6IHRoaXMuX3ByZWxpbUNvbnRlbnQubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZQXJyYXlFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKTtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlBcnJheUV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29udGVudC4gTm90IGp1c3QgYSBjb250ZW50XG4gICAqIG9iamVjdC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBcIndlaXJkbmVzc1wiIGlzIHRoYXQgaW5zZXJ0aW5nIHNldmVyYWwgZWxlbWVudHNcbiAgICogaXMgdmVyeSBlZmZpY2llbnQgd2hlbiBpdCBpcyBkb25lIGFzIGEgc2luZ2xlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHlhcnJheS5pbnNlcnQoMCwgWydhJ10pXG4gICAqICAvLyBJbnNlcnQgbnVtYmVycyAxLCAyIGF0IHBvc2l0aW9uIDFcbiAgICogIHlhcnJheS5pbnNlcnQoMSwgWzEsIDJdKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0LlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgLyoqIEB0eXBlIHthbnl9ICovIChjb250ZW50KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKlxuICAgKiBAdG9kbyBVc2UgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpbiBhbGwgdHlwZXMuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdFB1c2hHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgLyoqIEB0eXBlIHthbnl9ICovIChjb250ZW50KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkucHVzaCguLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBwcmVwcGVuZC5cbiAgICovXG4gIHVuc2hpZnQgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCgwLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoID0gMSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3REZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNwbGljZShpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtUfVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0eXBlTGlzdEdldCh0aGlzLCBpbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RUb0FycmF5KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAgICovXG4gIHNsaWNlIChzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgU2hhcmVkIFR5cGUgdG8gYSBKU09OIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGMgPT4gYyBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGMudG9KU09OKCkgOiBjKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgd2l0aCB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeVxuICAgKiBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAdGVtcGxhdGUgTVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsbnVtYmVyLFlBcnJheTxUPik6TX0gZiBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGVsZW1lbnQgb2YgdGhlIG5ldyBBcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheTxNPn0gQSBuZXcgYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBtYXAgKGYpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgLyoqIEB0eXBlIHthbnl9ICovIChmKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2Ugb24gb3ZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihULG51bWJlcixZQXJyYXk8VD4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWUFycmF5UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWUFycmF5ID0gX2RlY29kZXIgPT4gbmV3IFlBcnJheSgpO1xuXG4vKipcbiAqIEBtb2R1bGUgWU1hcFxuICovXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgWUV2ZW50PFlNYXA8VD4+XG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlNYXAuXG4gKi9cbmNsYXNzIFlNYXBFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lNYXA8VD59IHltYXAgVGhlIFlBcnJheSB0aGF0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHltYXAsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeW1hcCwgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBzdWJzO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIE1hcFR5cGVcbiAqIEEgc2hhcmVkIE1hcCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WU1hcEV2ZW50PE1hcFR5cGU+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFtzdHJpbmcsIE1hcFR5cGVdPn1cbiAqL1xuY2xhc3MgWU1hcCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlPHJlYWRvbmx5IFtzdHJpbmcsIGFueV0+PX0gZW50cmllcyAtIGFuIG9wdGlvbmFsIGl0ZXJhYmxlIHRvIGluaXRpYWxpemUgdGhlIFlNYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbnRyaWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuXG4gICAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoZW50cmllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7LyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WU1hcDxNYXBUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lNYXA8TWFwVHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lNYXA8TWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0gbmV3IFlNYXAoKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIHZhbHVlfSAqLyAodmFsdWUuY2xvbmUoKSkgOiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWU1hcEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWU1hcEV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsTWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge307XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdiA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXTtcbiAgICAgICAgbWFwW2tleV0gPSB2IGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gdi50b0pTT04oKSA6IHY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIFlNYXAgKGNvdW50IG9mIGtleS92YWx1ZSBwYWlycylcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiBbLi4uY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKV0ubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBZTWFwIFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8c3RyaW5nPn1cbiAgICovXG4gIGtleXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvci5pdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiB2WzBdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBZTWFwIFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8TWFwVHlwZT59XG4gICAqL1xuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvci5pdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiB2WzFdLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZbMV0ubGVuZ3RoIC0gMV0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxbc3RyaW5nLCBNYXBUeXBlXT59XG4gICAqL1xuICBlbnRyaWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gLyoqIEB0eXBlIHthbnl9ICovIChbdlswXSwgdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdXSkpXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGtleS12YWx1ZSBwYWlyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE1hcFR5cGUsc3RyaW5nLFlNYXA8TWFwVHlwZT4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgZihpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpW2l0ZW0ubGVuZ3RoIC0gMV0sIGtleSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxbc3RyaW5nLCBNYXBUeXBlXT59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqL1xuICBkZWxldGUgKGtleSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywga2V5KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUge01hcFR5cGV9IFZBTFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoaXMgWU1hcFxuICAgKiBAcGFyYW0ge1ZBTH0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKiBAcmV0dXJuIHtWQUx9XG4gICAqL1xuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGtleSwgLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge01hcFR5cGV8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGtleSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzIChrZXkpIHtcbiAgICByZXR1cm4gdHlwZU1hcEhhcyh0aGlzLCBrZXkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGlzIFlNYXAuXG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZSwga2V5LCBtYXApIHtcbiAgICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCBtYXAsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZTWFwUmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWU1hcCA9IF9kZWNvZGVyID0+IG5ldyBZTWFwKCk7XG5cbi8qKlxuICogQG1vZHVsZSBZVGV4dFxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsQXR0cnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSk7XG5cbmNsYXNzIEl0ZW1UZXh0TGlzdFBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSByaWdodFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJlbnRBdHRyaWJ1dGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVmdCwgcmlnaHQsIGluZGV4LCBjdXJyZW50QXR0cmlidXRlcykge1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzID0gY3VycmVudEF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogT25seSBjYWxsIHRoaXMgaWYgeW91IGtub3cgdGhhdCB0aGlzLnJpZ2h0IGlzIGRlZmluZWRcbiAgICovXG4gIGZvcndhcmQgKCkge1xuICAgIGlmICh0aGlzLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHRoaXMuY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKHRoaXMucmlnaHQuY29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gdGhpcy5yaWdodC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5yaWdodDtcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC5yaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBwb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBzdGVwcyB0byBtb3ZlIGZvcndhcmRcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZE5leHRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcG9zLCBjb3VudCkgPT4ge1xuICB3aGlsZSAocG9zLnJpZ2h0ICE9PSBudWxsICYmIGNvdW50ID4gMCkge1xuICAgIHN3aXRjaCAocG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCFwb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHBvcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAocG9zLnJpZ2h0LmNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCFwb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIGlmIChjb3VudCA8IHBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJpZ2h0XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQocG9zLnJpZ2h0LmlkLmNsaWVudCwgcG9zLnJpZ2h0LmlkLmNsb2NrICsgY291bnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zLmluZGV4ICs9IHBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgY291bnQgLT0gcG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBwb3MubGVmdCA9IHBvcy5yaWdodDtcbiAgICBwb3MucmlnaHQgPSBwb3MucmlnaHQucmlnaHQ7XG4gICAgLy8gcG9zLmZvcndhcmQoKSAtIHdlIGRvbid0IGZvcndhcmQgYmVjYXVzZSB0aGF0IHdvdWxkIGhhbHZlIHRoZSBwZXJmb3JtYW5jZSBiZWNhdXNlIHdlIGFscmVhZHkgZG8gdGhlIGNoZWNrcyBhYm92ZVxuICB9XG4gIHJldHVybiBwb3Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZVNlYXJjaE1hcmtlclxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kUG9zaXRpb24gPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIHVzZVNlYXJjaE1hcmtlcikgPT4ge1xuICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWFya2VyID0gdXNlU2VhcmNoTWFya2VyID8gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KSA6IG51bGw7XG4gIGlmIChtYXJrZXIpIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obWFya2VyLnAubGVmdCwgbWFya2VyLnAsIG1hcmtlci5pbmRleCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKHRyYW5zYWN0aW9uLCBwb3MsIGluZGV4IC0gbWFya2VyLmluZGV4KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihudWxsLCBwYXJlbnQuX3N0YXJ0LCAwLCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXgpXG4gIH1cbn07XG5cbi8qKlxuICogTmVnYXRlIGFwcGxpZWQgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBuZWdhdGVkQXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gY2hlY2sgaWYgd2UgcmVhbGx5IG5lZWQgdG8gcmVtb3ZlIGF0dHJpYnV0ZXNcbiAgd2hpbGUgKFxuICAgIGN1cnJQb3MucmlnaHQgIT09IG51bGwgJiYgKFxuICAgICAgY3VyclBvcy5yaWdodC5kZWxldGVkID09PSB0cnVlIHx8IChcbiAgICAgICAgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmXG4gICAgICAgIGVxdWFsQXR0cnMobmVnYXRlZEF0dHJpYnV0ZXMuZ2V0KC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkua2V5KSwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSlcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpO1xuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBuZWdhdGVkQXR0cmlidXRlcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgIGNvbnN0IGxlZnQgPSBjdXJyUG9zLmxlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSBjdXJyUG9zLnJpZ2h0O1xuICAgIGNvbnN0IG5leHRGb3JtYXQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKTtcbiAgICBuZXh0Rm9ybWF0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgY3VyclBvcy5yaWdodCA9IG5leHRGb3JtYXQ7XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7Q29udGVudEZvcm1hdH0gZm9ybWF0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyA9IChjdXJyZW50QXR0cmlidXRlcywgZm9ybWF0KSA9PiB7XG4gIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZm9ybWF0O1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyA9IChjdXJyUG9zLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIGdvIHJpZ2h0IHdoaWxlIGF0dHJpYnV0ZXNbcmlnaHQua2V5XSA9PT0gcmlnaHQudmFsdWUgKG9yIHJpZ2h0IGlzIGRlbGV0ZWQpXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgfHwgKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCAmJiBlcXVhbEF0dHJzKGF0dHJpYnV0ZXNbKC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkpLmtleV0gfHwgbnVsbCwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSkpKSA7IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge01hcDxzdHJpbmcsYW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiovXG5jb25zdCBpbnNlcnRBdHRyaWJ1dGVzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIC8vIGluc2VydCBmb3JtYXQtc3RhcnQgaXRlbXNcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHZhbCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICBjb25zdCBjdXJyZW50VmFsID0gY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgIGlmICghZXF1YWxBdHRycyhjdXJyZW50VmFsLCB2YWwpKSB7XG4gICAgICAvLyBzYXZlIG5lZ2F0ZWQgYXR0cmlidXRlIChzZXQgbnVsbCBpZiBjdXJyZW50VmFsIHVuZGVmaW5lZClcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIGN1cnJlbnRWYWwpO1xuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gY3VyclBvcztcbiAgICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKTtcbiAgICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVnYXRlZEF0dHJpYnV0ZXNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fEFic3RyYWN0VHlwZTxhbnk+fSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgdGV4dCwgYXR0cmlidXRlcykgPT4ge1xuICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKF92YWwsIGtleSkgPT4ge1xuICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0cmlidXRlc1trZXldID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMoY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IG5lZ2F0ZWRBdHRyaWJ1dGVzID0gaW5zZXJ0QXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgLy8gaW5zZXJ0IGNvbnRlbnRcbiAgY29uc3QgY29udGVudCA9IHRleHQuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IG5ldyBDb250ZW50U3RyaW5nKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGV4dCkpIDogKHRleHQgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBuZXcgQ29udGVudFR5cGUodGV4dCkgOiBuZXcgQ29udGVudEVtYmVkKHRleHQpKTtcbiAgbGV0IHsgbGVmdCwgcmlnaHQsIGluZGV4IH0gPSBjdXJyUG9zO1xuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBjdXJyUG9zLmluZGV4LCBjb250ZW50LmdldExlbmd0aCgpKTtcbiAgfVxuICByaWdodCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBjb250ZW50KTtcbiAgcmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgY3VyclBvcy5yaWdodCA9IHJpZ2h0O1xuICBjdXJyUG9zLmluZGV4ID0gaW5kZXg7XG4gIGN1cnJQb3MuZm9yd2FyZCgpO1xuICBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmb3JtYXRUZXh0ID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGxlbmd0aCwgYXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMoY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IG5lZ2F0ZWRBdHRyaWJ1dGVzID0gaW5zZXJ0QXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgLy8gaXRlcmF0ZSB1bnRpbCBmaXJzdCBub24tZm9ybWF0IG9yIG51bGwgaXMgZm91bmRcbiAgLy8gZGVsZXRlIGFsbCBmb3JtYXRzIHdpdGggYXR0cmlidXRlc1tmb3JtYXQua2V5XSAhPSBudWxsXG4gIC8vIGFsc28gY2hlY2sgdGhlIGF0dHJpYnV0ZXMgYWZ0ZXIgdGhlIGZpcnN0IG5vbi1mb3JtYXQgYXMgd2UgZG8gbm90IHdhbnQgdG8gaW5zZXJ0IHJlZHVuZGFudCBuZWdhdGVkIGF0dHJpYnV0ZXMgdGhlcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICBpdGVyYXRpb25Mb29wOiB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJlxuICAgIChsZW5ndGggPiAwIHx8XG4gICAgICAoXG4gICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNpemUgPiAwICYmXG4gICAgICAgIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgfHwgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KTtcbiAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKGF0dHIsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGZ1cnRoZXIgZXh0ZW5kIG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgIGJyZWFrIGl0ZXJhdGlvbkxvb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIC8vIFF1aWxsIGp1c3QgYXNzdW1lcyB0aGF0IHRoZSBlZGl0b3Igc3RhcnRzIHdpdGggYSBuZXdsaW5lIGFuZCB0aGF0IGl0IGFsd2F5c1xuICAvLyBlbmRzIHdpdGggYSBuZXdsaW5lLiBXZSBvbmx5IGluc2VydCB0aGF0IG5ld2xpbmUgd2hlbiBhIG5ldyBuZXdsaW5lIGlzXG4gIC8vIGluc2VydGVkIC0gaS5lIHdoZW4gbGVuZ3RoIGlzIGJpZ2dlciB0aGFuIHR5cGUubGVuZ3RoXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgbGV0IG5ld2xpbmVzID0gJyc7XG4gICAgZm9yICg7IGxlbmd0aCA+IDA7IGxlbmd0aC0tKSB7XG4gICAgICBuZXdsaW5lcyArPSAnXFxuJztcbiAgICB9XG4gICAgY3VyclBvcy5yaWdodCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGN1cnJQb3MubGVmdCwgY3VyclBvcy5sZWZ0ICYmIGN1cnJQb3MubGVmdC5sYXN0SWQsIGN1cnJQb3MucmlnaHQsIGN1cnJQb3MucmlnaHQgJiYgY3VyclBvcy5yaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudFN0cmluZyhuZXdsaW5lcykpO1xuICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcyk7XG59O1xuXG4vKipcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBzdHJpbmcgY29udGVudCBoYXMgYmVlbiBkZWxldGVkIGluIG9yZGVyIHRvXG4gKiBjbGVhbiB1cCBmb3JtYXR0aW5nIEl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IHN0YXJ0XG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gY3VyciBleGNsdXNpdmUgZW5kLCBhdXRvbWF0aWNhbGx5IGl0ZXJhdGVzIHRvIHRoZSBuZXh0IENvbnRlbnQgSXRlbVxuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IHN0YXJ0QXR0cmlidXRlc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJBdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgZm9ybWF0dGluZyBJdGVtcyBkZWxldGVkLlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjbGVhbnVwRm9ybWF0dGluZ0dhcCA9ICh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnIsIHN0YXJ0QXR0cmlidXRlcywgY3VyckF0dHJpYnV0ZXMpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgZW5kID0gc3RhcnQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPHN0cmluZyxDb250ZW50Rm9ybWF0Pn1cbiAgICovXG4gIGNvbnN0IGVuZEZvcm1hdHMgPSBtYXAuY3JlYXRlKCk7XG4gIHdoaWxlIChlbmQgJiYgKCFlbmQuY291bnRhYmxlIHx8IGVuZC5kZWxldGVkKSkge1xuICAgIGlmICghZW5kLmRlbGV0ZWQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGNmID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpO1xuICAgICAgZW5kRm9ybWF0cy5zZXQoY2Yua2V5LCBjZik7XG4gICAgfVxuICAgIGVuZCA9IGVuZC5yaWdodDtcbiAgfVxuICBsZXQgY2xlYW51cHMgPSAwO1xuICBsZXQgcmVhY2hlZEN1cnIgPSBmYWxzZTtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICBpZiAoY3VyciA9PT0gc3RhcnQpIHtcbiAgICAgIHJlYWNoZWRDdXJyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzdGFydC5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc3RhcnQuY29udGVudDtcbiAgICAgIHN3aXRjaCAoY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0QXR0clZhbHVlID0gc3RhcnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgaWYgKGVuZEZvcm1hdHMuZ2V0KGtleSkgIT09IGNvbnRlbnQgfHwgc3RhcnRBdHRyVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgdGhpcyBmb3JtYXQgaXMgb3ZlcndyaXR0ZW4gb3IgaXQgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdGVkLlxuICAgICAgICAgICAgc3RhcnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNsZWFudXBzKys7XG4gICAgICAgICAgICBpZiAoIXJlYWNoZWRDdXJyICYmIChjdXJyQXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsKSA9PT0gdmFsdWUgJiYgc3RhcnRBdHRyVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChzdGFydEF0dHJWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJBdHRyaWJ1dGVzLnNldChrZXksIHN0YXJ0QXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlYWNoZWRDdXJyICYmICFzdGFydC5kZWxldGVkKSB7XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyQXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RhcnQucmlnaHQpO1xuICB9XG4gIHJldHVybiBjbGVhbnVwc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbVxuICovXG5jb25zdCBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBpdGVtKSA9PiB7XG4gIC8vIGl0ZXJhdGUgdW50aWwgaXRlbS5yaWdodCBpcyBudWxsIG9yIGNvbnRlbnRcbiAgd2hpbGUgKGl0ZW0gJiYgaXRlbS5yaWdodCAmJiAoaXRlbS5yaWdodC5kZWxldGVkIHx8ICFpdGVtLnJpZ2h0LmNvdW50YWJsZSkpIHtcbiAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgfVxuICBjb25zdCBhdHRycyA9IG5ldyBTZXQoKTtcbiAgLy8gaXRlcmF0ZSBiYWNrIHVudGlsIGEgY29udGVudCBpdGVtIGlzIGZvdW5kXG4gIHdoaWxlIChpdGVtICYmIChpdGVtLmRlbGV0ZWQgfHwgIWl0ZW0uY291bnRhYmxlKSkge1xuICAgIGlmICghaXRlbS5kZWxldGVkICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KS5rZXk7XG4gICAgICBpZiAoYXR0cnMuaGFzKGtleSkpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZW0gPSBpdGVtLmxlZnQ7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBleHBlcmltZW50YWwgYW5kIHN1YmplY3QgdG8gY2hhbmdlIC8gYmUgcmVtb3ZlZC5cbiAqXG4gKiBJZGVhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgZnVuY3Rpb24gYXQgYWxsLiBGb3JtYXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGNsZWFuZWQgdXBcbiAqIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZWFjaCBjaGFuZ2UuIFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdHdpY2Ugb3ZlciB0aGUgY29tcGxldGUgWVRleHQgdHlwZVxuICogYW5kIHJlbW92ZXMgdW5uZWNlc3NhcnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzLiBUaGlzIGlzIGFsc28gaGVscGZ1bCBmb3IgdGVzdGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGV4cG9ydGVkIGFueW1vcmUgYXMgc29vbiBhcyB0aGVyZSBpcyBjb25maWRlbmNlIHRoYXQgdGhlIFlUZXh0IHR5cGUgd29ya3MgYXMgaW50ZW5kZWQuXG4gKlxuICogQHBhcmFtIHtZVGV4dH0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfSBIb3cgbWFueSBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNsZWFuZWQgdXAuXG4gKi9cbmNvbnN0IGNsZWFudXBZVGV4dEZvcm1hdHRpbmcgPSB0eXBlID0+IHtcbiAgbGV0IHJlcyA9IDA7XG4gIHRyYW5zYWN0KC8qKiBAdHlwZSB7RG9jfSAqLyAodHlwZS5kb2MpLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodHlwZS5fc3RhcnQpO1xuICAgIGxldCBlbmQgPSB0eXBlLl9zdGFydDtcbiAgICBsZXQgc3RhcnRBdHRyaWJ1dGVzID0gbWFwLmNyZWF0ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbWFwLmNvcHkoc3RhcnRBdHRyaWJ1dGVzKTtcbiAgICB3aGlsZSAoZW5kKSB7XG4gICAgICBpZiAoZW5kLmRlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN3aXRjaCAoZW5kLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlcyArPSBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGVuZCwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBzdGFydEF0dHJpYnV0ZXMgPSBtYXAuY29weShjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZC5yaWdodDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgdGhlIHRyYW5zY3Rpb24gb25jZSB0aGUgZXZlbnQgaGFuZGxlcnMgYXJlIGNhbGxlZCB0byBwb3RlbnRpYWxseSBjbGVhbnVwXG4gKiBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTZXQ8WVRleHQ+fVxuICAgKi9cbiAgY29uc3QgbmVlZEZ1bGxDbGVhbnVwID0gbmV3IFNldCgpO1xuICAvLyBjaGVjayBpZiBhbm90aGVyIGZvcm1hdHRpbmcgaXRlbSB3YXMgaW5zZXJ0ZWRcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBmb3IgKGNvbnN0IFtjbGllbnQsIGFmdGVyQ2xvY2tdIG9mIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZW50cmllcygpKSB7XG4gICAgY29uc3QgY2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgIGlmIChhZnRlckNsb2NrID09PSBjbG9jaykge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QXJyYXk8SXRlbXxHQz59ICovIChkb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSksIGNsb2NrLCBhZnRlckNsb2NrLCBpdGVtID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWl0ZW0uZGVsZXRlZCAmJiAvKiogQHR5cGUge0l0ZW19ICovIChpdGVtKS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGl0ZW0uY29uc3RydWN0b3IgIT09IEdDXG4gICAgICApIHtcbiAgICAgICAgbmVlZEZ1bGxDbGVhbnVwLmFkZCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gY2xlYW51cCBpbiBhIG5ldyB0cmFuc2FjdGlvblxuICB0cmFuc2FjdChkb2MsICh0KSA9PiB7XG4gICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHQyB8fCAhKC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudCkuX2hhc0Zvcm1hdHRpbmcpIHx8IG5lZWRGdWxsQ2xlYW51cC5oYXMoLyoqIEB0eXBlIHtZVGV4dH0gKi8gKGl0ZW0ucGFyZW50KSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpO1xuICAgICAgaWYgKGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICBuZWVkRnVsbENsZWFudXAuYWRkKHBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBmb3JtYXR0aW5nIGF0dHJpYnV0ZSB3YXMgaW5zZXJ0ZWQgb3IgZGVsZXRlZCwgd2UgY2FuIG1ha2UgZHVlIHdpdGggY29udGV4dGxlc3NcbiAgICAgICAgLy8gZm9ybWF0dGluZyBjbGVhbnVwcy5cbiAgICAgICAgLy8gQ29udGV4dGxlc3M6IGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGFmZmVjdGVkIHBvc2l0aW9uLlxuICAgICAgICBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwKHQsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIGEgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZCwgd2Ugc2ltcGx5IGNsZWFuIHRoZSB3aG9sZSB0eXBlLlxuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW55d2F5LlxuICAgIGZvciAoY29uc3QgeVRleHQgb2YgbmVlZEZ1bGxDbGVhbnVwKSB7XG4gICAgICBjbGVhbnVwWVRleHRGb3JtYXR0aW5nKHlUZXh0KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWxldGVUZXh0ID0gKHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBsZW5ndGgpID0+IHtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBtYXAuY29weShjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc3RhcnQgPSBjdXJyUG9zLnJpZ2h0O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBpZiAoc3RhcnQpIHtcbiAgICBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnJQb3MucmlnaHQsIHN0YXJ0QXR0cnMsIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICgvKiogQHR5cGUge0l0ZW19ICovIChjdXJyUG9zLmxlZnQgfHwgY3VyclBvcy5yaWdodCkucGFyZW50KTtcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gY3VyclBvc1xufTtcblxuLyoqXG4gKiBUaGUgUXVpbGwgRGVsdGEgZm9ybWF0IHJlcHJlc2VudHMgY2hhbmdlcyBvbiBhIHRleHQgZG9jdW1lbnQgd2l0aFxuICogZm9ybWF0dGluZyBpbmZvcm1hdGlvbi4gRm9yIG1vciBpbmZvcm1hdGlvbiB2aXNpdCB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX1cbiAqXG4gKiBAZXhhbXBsZVxuICogICB7XG4gKiAgICAgb3BzOiBbXG4gKiAgICAgICB7IGluc2VydDogJ0dhbmRhbGYnLCBhdHRyaWJ1dGVzOiB7IGJvbGQ6IHRydWUgfSB9LFxuICogICAgICAgeyBpbnNlcnQ6ICcgdGhlICcgfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnR3JleScsIGF0dHJpYnV0ZXM6IHsgY29sb3I6ICcjY2NjY2NjJyB9IH1cbiAqICAgICBdXG4gKiAgIH1cbiAqXG4gKi9cblxuLyoqXG4gICogQXR0cmlidXRlcyB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHNlbGVjdGlvbiBvZiB0ZXh0LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAgIHtcbiAgKiAgICAgYm9sZDogdHJ1ZSxcbiAgKiAgICAgZm9udC1zaXplOiAnNDBweCdcbiAgKiAgIH1cbiAgKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRBdHRyaWJ1dGVzXG4gICovXG5cbi8qKlxuICogQGV4dGVuZHMgWUV2ZW50PFlUZXh0PlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVGV4dCB0eXBlLlxuICovXG5jbGFzcyBZVGV4dEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVRleHR9IHl0ZXh0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeXRleHQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5c0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZ3xBYnN0cmFjdFR5cGU8YW55PnxvYmplY3QsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHtcbiAgICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgYWRkZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgZGVsZXRlZDogbmV3IFNldCgpXG4gICAgICB9O1xuICAgICAgdGhpcy5fY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2NoYW5nZXMpXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgKiBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIGlmICh0aGlzLl9kZWx0YSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgeSA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy50YXJnZXQuZG9jKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy50YXJnZXQuX3N0YXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZz99XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307IC8vIGNvdW50cyBhZGRlZCBvciByZW1vdmVkIG5ldyBhdHRyaWJ1dGVzIGZvciByZXRhaW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGluc2VydCA9ICcnO1xuICAgICAgICBsZXQgcmV0YWluID0gMDtcbiAgICAgICAgbGV0IGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgIGNvbnN0IGFkZE9wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IG9wID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wID0geyBkZWxldGU6IGRlbGV0ZUxlbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnNlcnQgPT09ICdvYmplY3QnIHx8IGluc2VydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgaW5zZXJ0IH07XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnNlcnQgPSAnJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdyZXRhaW4nOlxuICAgICAgICAgICAgICAgIGlmIChyZXRhaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgcmV0YWluIH07XG4gICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdC5pc0VtcHR5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBvYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluID0gMDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wKSBkZWx0YS5wdXNoKG9wKTtcbiAgICAgICAgICAgIGFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVswXTtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5zZXJ0ICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKGl0ZW0uY29udGVudCkuc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWxBdHRycyh2YWx1ZSwgKG9sZEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gY3VyVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgIT09IG51bGwpIHsgLy8gdGhpcyB3aWxsIGJlIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseSBieSB0aGUgY29udGV4dGxlc3MgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBhZGRPcCgpO1xuICAgICAgICB3aGlsZSAoZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcCA9IGRlbHRhW2RlbHRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0T3AucmV0YWluICE9PSB1bmRlZmluZWQgJiYgbGFzdE9wLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0YWluIGRlbHRhJ3MgaWYgdGhleSBkb24ndCBhc3NpZ24gYXR0cmlidXRlc1xuICAgICAgICAgICAgZGVsdGEucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2RlbHRhKVxuICB9XG59XG5cbi8qKlxuICogVHlwZSB0aGF0IHJlcHJlc2VudHMgdGV4dCB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyB0eXBlIHJlcGxhY2VzIHktcmljaHRleHQgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhYmxlIHRvIGhhbmRsZVxuICogYmxvY2sgZm9ybWF0cyAoZm9ybWF0IGluZm9ybWF0aW9uIG9uIGEgcGFyYWdyYXBoKSwgZW1iZWRzIChjb21wbGV4IGVsZW1lbnRzXG4gKiBsaWtlIHBpY3R1cmVzIGFuZCB2aWRlb3MpLCBhbmQgdGV4dCBmb3JtYXRzICgqKmJvbGQqKiwgKml0YWxpYyopLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZVGV4dEV2ZW50PlxuICovXG5jbGFzcyBZVGV4dCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ10gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIFlUZXh0LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGVuZGluZyBvcGVyYXRpb25zIG9uIHRoaXMgdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbigpOnZvaWQ+P31cbiAgICAgKi9cbiAgICB0aGlzLl9wZW5kaW5nID0gc3RyaW5nICE9PSB1bmRlZmluZWQgPyBbKCkgPT4gdGhpcy5pbnNlcnQoMCwgc3RyaW5nKV0gOiBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoTWFya2VyID0gW107XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIFlUZXh0IGNvbnRhaW5zIGZvcm1hdHRpbmcgYXR0cmlidXRlcy5cbiAgICAgKiBUaGlzIGZsYWcgaXMgdXBkYXRlZCB3aGVuIGEgZm9ybWF0dGluZyBpdGVtIGlzIGludGVncmF0ZWQgKHNlZSBDb250ZW50Rm9ybWF0LmludGVncmF0ZSlcbiAgICAgKi9cbiAgICB0aGlzLl9oYXNGb3JtYXR0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGNoYXJhY3RlcnMgb2YgdGhpcyB0ZXh0IHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHlcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKTtcbiAgICB0cnkge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5mb3JFYWNoKGYgPT4gZigpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlUZXh0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZVGV4dH1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFlUZXh0KCk7XG4gICAgdGV4dC5hcHBseURlbHRhKHRoaXMudG9EZWx0YSgpKTtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVRleHRFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBZVGV4dEV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKTtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgZXZlbnQpO1xuICAgIC8vIElmIGEgcmVtb3RlIGNoYW5nZSBoYXBwZW5lZCwgd2UgdHJ5IHRvIGNsZWFudXAgcG90ZW50aWFsIGZvcm1hdHRpbmcgZHVwbGljYXRlcy5cbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX2hhc0Zvcm1hdHRpbmcpIHtcbiAgICAgIHRyYW5zYWN0aW9uLl9uZWVkRm9ybWF0dGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUgJiYgbi5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgIH1cbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHtAbGluayBEZWx0YX0gb24gdGhpcyBzaGFyZWQgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRlbHRhIFRoZSBjaGFuZ2VzIHRvIGFwcGx5IG9uIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2FuaXRpemVdIFNhbml0aXplIGlucHV0IGRlbHRhLiBSZW1vdmVzIGVuZGluZyBuZXdsaW5lcyBpZiBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXBwbHlEZWx0YSAoZGVsdGEsIHsgc2FuaXRpemUgPSB0cnVlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VyclBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihudWxsLCB0aGlzLl9zdGFydCwgMCwgbmV3IE1hcCgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG9wID0gZGVsdGFbaV07XG4gICAgICAgICAgaWYgKG9wLmluc2VydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBRdWlsbCBhc3N1bWVzIHRoYXQgdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggYW4gZW1wdHkgcGFyYWdyYXBoLlxuICAgICAgICAgICAgLy8gWWpzL1kuVGV4dCBhc3N1bWVzIHRoYXQgaXQgc3RhcnRzIGVtcHR5LiBXZSBhbHdheXMgaGlkZSB0aGF0XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIG5ld2xpbmUgYXQgdGhlIGVuZCBvZiB0aGUgY29udGVudC5cbiAgICAgICAgICAgIC8vIElmIHdlIG9taXQgdGhpcyBzdGVwLCBjbGllbnRzIHdpbGwgc2VlIGEgZGlmZmVyZW50IG51bWJlciBvZlxuICAgICAgICAgICAgLy8gcGFyYWdyYXBocywgYnV0IG5vdGhpbmcgYmFkIHdpbGwgaGFwcGVuLlxuICAgICAgICAgICAgY29uc3QgaW5zID0gKCFzYW5pdGl6ZSAmJiB0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJyAmJiBpID09PSBkZWx0YS5sZW5ndGggLSAxICYmIGN1cnJQb3MucmlnaHQgPT09IG51bGwgJiYgb3AuaW5zZXJ0LnNsaWNlKC0xKSA9PT0gJ1xcbicpID8gb3AuaW5zZXJ0LnNsaWNlKDAsIC0xKSA6IG9wLmluc2VydDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zICE9PSAnc3RyaW5nJyB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBjdXJyUG9zLCBpbnMsIG9wLmF0dHJpYnV0ZXMgfHwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAob3AucmV0YWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIGN1cnJQb3MsIG9wLnJldGFpbiwgb3AuYXR0cmlidXRlcyB8fCB7fSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5kZWxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlVGV4dCh0cmFuc2FjdGlvbiwgY3VyclBvcywgb3AuZGVsZXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5hcHBseURlbHRhKGRlbHRhKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCdyZW1vdmVkJyB8ICdhZGRlZCcsIElEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAgICogQHJldHVybiB7YW55fSBUaGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RlbHRhIChzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBle0FycmF5PGFueT59XG4gICAgICovXG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZG9jID0gLyoqIEB0eXBlIHtEb2N9ICovICh0aGlzLmRvYyk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnQ7XG4gICAgZnVuY3Rpb24gcGFja1N0ciAoKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGFjayBzdHIgd2l0aCBhdHRyaWJ1dGVzIHRvIG9wc1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgbGV0IGFkZEF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGFkZEF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvcCA9IHsgaW5zZXJ0OiBzdHIgfTtcbiAgICAgICAgaWYgKGFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgfVxuICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgIHN0ciA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb21wdXRlRGVsdGEgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSB8fCAocHJldlNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpKSB7XG4gICAgICAgICAgc3dpdGNoIChuLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzoge1xuICAgICAgICAgICAgICBjb25zdCBjdXIgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoJ3ljaGFuZ2UnKTtcbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgIWlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci50eXBlICE9PSAncmVtb3ZlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCBuLmlkKSA6IHsgdHlwZTogJ3JlbW92ZWQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci50eXBlICE9PSAnYWRkZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoJ3ljaGFuZ2UnLCBjb21wdXRlWUNoYW5nZSA/IGNvbXB1dGVZQ2hhbmdlKCdhZGRlZCcsIG4uaWQpIDogeyB0eXBlOiAnYWRkZWQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5kZWxldGUoJ3ljaGFuZ2UnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHIgKz0gLyoqIEB0eXBlIHtDb250ZW50U3RyaW5nfSAqLyAobi5jb250ZW50KS5zdHI7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAgICAgIGluc2VydDogbi5jb250ZW50LmdldENvbnRlbnQoKVswXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fSAqLyAoe30pO1xuICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAobi5jb250ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICB9XG4gICAgICBwYWNrU3RyKCk7XG4gICAgfTtcbiAgICBpZiAoc25hcHNob3QgfHwgcHJldlNuYXBzaG90KSB7XG4gICAgICAvLyBzbmFwc2hvdHMgYXJlIG1lcmdlZCBhZ2FpbiBhZnRlciB0aGUgdHJhbnNhY3Rpb24sIHNvIHdlIG5lZWQgdG8ga2VlcCB0aGVcbiAgICAgIC8vIHRyYW5zYWN0aW9uIGFsaXZlIHVudGlsIHdlIGFyZSBkb25lXG4gICAgICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U25hcHNob3QpIHtcbiAgICAgICAgICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBwcmV2U25hcHNob3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVEZWx0YSgpO1xuICAgICAgfSwgJ2NsZWFudXAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZURlbHRhKCk7XG4gICAgfVxuICAgIHJldHVybiBvcHNcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGV4dCBhdCBhIGdpdmVuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGluc2VydGluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gaW5zZXJ0IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IFthdHRyaWJ1dGVzXSBPcHRpb25hbGx5IGRlZmluZSBzb21lIGZvcm1hdHRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiB0byBhcHBseSBvbiB0aGUgaW5zZXJ0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXh0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCB0ZXh0LCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgIWF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHBvcy5jdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7IGF0dHJpYnV0ZXNba10gPSB2OyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIHRleHQsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGVtYmVkIGF0IGEgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBlbWJlZCBhdC5cbiAgICogQHBhcmFtIHtPYmplY3QgfCBBYnN0cmFjdFR5cGU8YW55Pn0gZW1iZWQgVGhlIE9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGVtYmVkLlxuICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBbYXR0cmlidXRlc10gQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYmVkXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydEVtYmVkIChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgIWF0dHJpYnV0ZXMpO1xuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGVtYmVkLCBhdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMgfHwge30pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0ZXh0IHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIHRydWUpLCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmRlbGV0ZShpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgcHJvcGVydGllcyB0byBhIHJhbmdlIG9mIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvcm1hdCAoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICBpZiAocG9zLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmZvcm1hdChpbmRleCwgbGVuZ3RoLCBhdHRyaWJ1dGVzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlVmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllZCB2YWx1ZS5cbiAgICogQHJldHVybiB7YW55fSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKiBAcmV0dXJuIHtZVGV4dH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZVGV4dCA9IF9kZWNvZGVyID0+IG5ldyBZVGV4dCgpO1xuXG4vKipcbiAqIEBtb2R1bGUgWVhtbFxuICovXG5cblxuLyoqXG4gKiBEZWZpbmUgdGhlIGVsZW1lbnRzIHRvIHdoaWNoIGEgc2V0IG9mIENTUyBxdWVyaWVzIGFwcGx5LlxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfU2VsZWN0b3JzfENTU19TZWxlY3RvcnN9XG4gKlxuICogQGV4YW1wbGVcbiAqICAgcXVlcnkgPSAnLmNsYXNzU2VsZWN0b3InXG4gKiAgIHF1ZXJ5ID0gJ25vZGVTZWxlY3RvcidcbiAqICAgcXVlcnkgPSAnI2lkU2VsZWN0b3InXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ30gQ1NTX1NlbGVjdG9yXG4gKi9cblxuLyoqXG4gKiBEb20gZmlsdGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBjYWxsYmFjayBkb21GaWx0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBUaGUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7TWFwfSBhdHRyaWJ1dGVzIFRoZSBtYXAgb2YgYXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgRG9tIG5vZGUgaW4gdGhlIFlYbWxFbGVtZW50LlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN1YnNldCBvZiB0aGUgbm9kZXMgb2YgYSBZWG1sRWxlbWVudCAvIFlYbWxGcmFnbWVudCBhbmQgYVxuICogcG9zaXRpb24gd2l0aGluIHRoZW0uXG4gKlxuICogQ2FuIGJlIGNyZWF0ZWQgd2l0aCB7QGxpbmsgWVhtbEZyYWdtZW50I2NyZWF0ZVRyZWVXYWxrZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxFbGVtZW50fFlYbWxIb29rPn1cbiAqL1xuY2xhc3MgWVhtbFRyZWVXYWxrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtZWG1sRnJhZ21lbnQgfCBZWG1sRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFic3RyYWN0VHlwZTxhbnk+KTpib29sZWFufSBbZl1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyb290LCBmID0gKCkgPT4gdHJ1ZSkge1xuICAgIHRoaXMuX2ZpbHRlciA9IGY7XG4gICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW19XG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSAvKiogQHR5cGUge0l0ZW19ICovIChyb290Ll9zdGFydCk7XG4gICAgdGhpcy5fZmlyc3RDYWxsID0gdHJ1ZTtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvclJlc3VsdDxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9vaz59IFRoZSBuZXh0IG5vZGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG5leHQgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICBsZXQgdHlwZSA9IG4gJiYgbi5jb250ZW50ICYmIC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlO1xuICAgIGlmIChuICE9PSBudWxsICYmICghdGhpcy5fZmlyc3RDYWxsIHx8IG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKHR5cGUpKSkgeyAvLyBpZiBmaXJzdCBjYWxsLCB3ZSBjaGVjayBpZiB3ZSBjYW4gdXNlIHRoZSBmaXJzdCBpdGVtXG4gICAgICBkbyB7XG4gICAgICAgIHR5cGUgPSAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZTtcbiAgICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgKHR5cGUuY29uc3RydWN0b3IgPT09IFlYbWxFbGVtZW50IHx8IHR5cGUuY29uc3RydWN0b3IgPT09IFlYbWxGcmFnbWVudCkgJiYgdHlwZS5fc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB3YWxrIGRvd24gaW4gdGhlIHRyZWVcbiAgICAgICAgICBuID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2FsayByaWdodCBvciB1cCBpbiB0aGUgdHJlZVxuICAgICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobi5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobi5wYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKG4ucGFyZW50KS5faXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4gIT09IG51bGwgJiYgKG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpKSlcbiAgICB9XG4gICAgdGhpcy5fZmlyc3RDYWxsID0gZmFsc2U7XG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfVxuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IG47XG4gICAgcmV0dXJuIHsgdmFsdWU6IC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlLCBkb25lOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbGlzdCBvZiB7QGxpbmsgWVhtbEVsZW1lbnR9LmFuZCB7QGxpbmsgWVhtbFRleHR9IHR5cGVzLlxuICogQSBZeG1sRnJhZ21lbnQgaXMgc2ltaWxhciB0byBhIHtAbGluayBZWG1sRWxlbWVudH0sIGJ1dCBpdCBkb2VzIG5vdCBoYXZlIGFcbiAqIG5vZGVOYW1lIGFuZCBpdCBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZXMuIFRob3VnaCBpdCBjYW4gYmUgYm91bmQgdG8gYSBET01cbiAqIGVsZW1lbnQgLSBpbiB0aGlzIGNhc2UgdGhlIGF0dHJpYnV0ZXMgYW5kIHRoZSBub2RlTmFtZSBhcmUgbm90IHNoYXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WVhtbEV2ZW50PlxuICovXG5jbGFzcyBZWG1sRnJhZ21lbnQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBmaXJzdENoaWxkICgpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuX2ZpcnN0O1xuICAgIHJldHVybiBmaXJzdCA/IGZpcnN0LmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdGhpcy5pbnNlcnQoMCwgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkpO1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEZyYWdtZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEZyYWdtZW50KCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsLmluc2VydCgwLCB0aGlzLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSk7XG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gYXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gcXVlcnkpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVhtbEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIFlYbWxGcmFnbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZHJlbi5cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgeG1sID0+IHhtbC50b1N0cmluZygpKS5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcyk7XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB4bWxUeXBlID0+IHtcbiAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZSh4bWxUeXBlLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpLCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZjtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCB0aGlzLCByZWZJdGVtLCBjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpO1xuICAgICAgY29uc3QgaW5kZXggPSByZWYgPT09IG51bGwgPyAwIDogcGMuZmluZEluZGV4KGVsID0+IGVsID09PSByZWYpICsgMTtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiByZWYgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKCdSZWZlcmVuY2UgaXRlbSBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgcGMuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZSBfcHJlbGltQ29udGVudCBpcyBkZWZpbmVkIGJlY2F1c2UgdGhpcyBpcyBub3QgeWV0IGludGVncmF0ZWRcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQuc3BsaWNlKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5sZW5ndGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR8WVhtbFRleHR9XG4gICAqL1xuICBnZXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0R2V0KHRoaXMsIGluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBvdmVyeSBjaGlsZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFlYbWxFbGVtZW50fFlYbWxUZXh0LG51bWJlciwgdHlwZW9mIHNlbGYpOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRnJhZ21lbnRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sRnJhZ21lbnQgPSBfZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KCk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdHxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fSBWYWx1ZVR5cGVzXG4gKi9cblxuLyoqXG4gKiBBbiBZWG1sRWxlbWVudCBpbWl0YXRlcyB0aGUgYmVoYXZpb3Igb2YgYVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnRcbiAqXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBhdHRyaWJ1dGVzIChrZXkgdmFsdWUgcGFpcnMpXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBjaGlsZEVsZW1lbnRzIHRoYXQgbXVzdCBpbmhlcml0IGZyb20gWVhtbEVsZW1lbnRcbiAqXG4gKiBAdGVtcGxhdGUge3sgW2tleTogc3RyaW5nXTogVmFsdWVUeXBlcyB9fSBbS1Y9eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfV1cbiAqL1xuY2xhc3MgWVhtbEVsZW1lbnQgZXh0ZW5kcyBZWG1sRnJhZ21lbnQge1xuICBjb25zdHJ1Y3RvciAobm9kZU5hbWUgPSAnVU5ERUZJTkVEJykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7KC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKSkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnQ8S1Y+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZWG1sRWxlbWVudDxLVj59XG4gICAgICovXG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBvYmplY3QuZm9yRWFjaChhdHRycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgWE1MIHNlcmlhbGl6YXRpb24gb2YgdGhpcyBZWG1sRWxlbWVudC5cbiAgICogVGhlIGF0dHJpYnV0ZXMgYXJlIG9yZGVyZWQgYnkgYXR0cmlidXRlLW5hbWUsIHNvIHlvdSBjYW4gZWFzaWx5IHVzZSB0aGlzXG4gICAqIG1ldGhvZCB0byBjb21wYXJlIFlYbWxFbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBjb25zdCBzdHJpbmdCdWlsZGVyID0gW107XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5zb3J0KCk7XG4gICAgY29uc3Qga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKGtleSArICc9XCInICsgYXR0cnNba2V5XSArICdcIicpO1xuICAgIH1cbiAgICBjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBjb25zdCBhdHRyc1N0cmluZyA9IHN0cmluZ0J1aWxkZXIubGVuZ3RoID4gMCA/ICcgJyArIHN0cmluZ0J1aWxkZXIuam9pbignICcpIDogJyc7XG4gICAgcmV0dXJuIGA8JHtub2RlTmFtZX0ke2F0dHJzU3RyaW5nfT4ke3N1cGVyLnRvU3RyaW5nKCl9PC8ke25vZGVOYW1lfT5gXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBLViAmIHN0cmluZ30gS0VZXG4gICAqXG4gICAqIEBwYXJhbSB7S0VZfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtLVltLRVldfSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLnNldChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgS1YgJiBzdHJpbmd9IEtFWVxuICAgKlxuICAgKiBAcGFyYW0ge0tFWX0gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtLVltLRVldfHVuZGVmaW5lZH0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhdHRyaWJ1dGUgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBjaGVjayBmb3IgZXhpc3RlbmNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBoYXNBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwSGFzKHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHJldHVybiB7eyBbS2V5IGluIEV4dHJhY3Q8a2V5b2YgS1Ysc3RyaW5nPl0/OiBLVltLZXldfX0gQSBKU09OIE9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcyAoc25hcHNob3QpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChzbmFwc2hvdCA/IHR5cGVNYXBHZXRBbGxTbmFwc2hvdCh0aGlzLCBzbmFwc2hvdCkgOiB0eXBlTWFwR2V0QWxsKHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubm9kZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB5eG1sID0+IHtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZCh5eG1sLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpKTtcbiAgICB9KTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihkb20sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxFbGVtZW50UmVmSUQpO1xuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5ub2RlTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sRWxlbWVudCA9IGRlY29kZXIgPT4gbmV3IFlYbWxFbGVtZW50KGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEZyYWdtZW50PlxuICogQW4gRXZlbnQgdGhhdCBkZXNjcmliZXMgY2hhbmdlcyBvbiBhIFlYbWwgRWxlbWVudCBvciBZeG1sIEZyYWdtZW50XG4gKi9cbmNsYXNzIFlYbWxFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxGcmFnbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U2V0PHN0cmluZ3xudWxsPn0gc3VicyBUaGUgc2V0IG9mIGNoYW5nZWQgYXR0cmlidXRlcy4gYG51bGxgIGlzIGluY2x1ZGVkIGlmIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICBjaGlsZCBsaXN0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoIHdpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHN1YnMsIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIodGFyZ2V0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogWW91IGNhbiBtYW5hZ2UgYmluZGluZyB0byBhIGN1c3RvbSB0eXBlIHdpdGggWVhtbEhvb2suXG4gKlxuICogQGV4dGVuZHMge1lNYXA8YW55Pn1cbiAqL1xuY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5ob29rTmFtZSA9IGhvb2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZWG1sSG9va31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV07XG4gICAgbGV0IGRvbTtcbiAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb20gPSBob29rLmNyZWF0ZURvbSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKTtcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEhvb2tSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sSG9va31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmNsYXNzIFlYbWxUZXh0IGV4dGVuZHMgWVRleHQge1xuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbFRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVhtbFRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMudG9EZWx0YSgpLm1hcChkZWx0YSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWROb2RlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7IGtleSwgdmFsdWU6IGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdW2tleV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBhdHRyaWJ1dGVzIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgICBhdHRycy5zb3J0KChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiAxKTtcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbm9kZSBvcmRlciB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgIG5lc3RlZE5vZGVzLnNvcnQoKGEsIGIpID0+IGEubm9kZU5hbWUgPCBiLm5vZGVOYW1lID8gLTEgOiAxKTtcbiAgICAgIC8vIG5vdyBjb252ZXJ0IHRvIGRvbSBzdHJpbmdcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldO1xuICAgICAgICBzdHIgKz0gYDwke25vZGUubm9kZU5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IG5vZGUuYXR0cnNbal07XG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnPic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gZGVsdGEuaW5zZXJ0O1xuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVhtbFRleHQoKTtcblxuY2xhc3MgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhpcyBzdHJ1Y3Qgd2l0aCB0aGUgaXRlbSB0byB0aGUgcmlnaHQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFscmVhZHkgYXNzdW1pbmcgdGhhdCBgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSB0aGlzLmlkLmNsb2NrYC5cbiAgICogQWxzbyB0aGlzIG1ldGhvZCBkb2VzICpub3QqIHJlbW92ZSByaWdodCBmcm9tIFN0cnVjdFN0b3JlIVxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgdGhpcyBtZXJnZWQgd2l0aCByaWdodFxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuY29kaW5nUmVmXG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0LCBlbmNvZGluZ1JlZikge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG59XG5cbmNvbnN0IHN0cnVjdEdDUmVmTnVtYmVyID0gMDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBHQyBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtHQ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXQ7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXQ7XG4gICAgfVxuICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RHQ1JlZk51bWJlcik7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbmd0aCAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgQ29udGVudEJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5jb250ZW50XVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QmluYXJ5KHRoaXMuY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEJpbmFyeX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUJ1Zih0aGlzLmNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRCaW5hcnkgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50QmluYXJ5KGRlY29kZXIucmVhZEJ1ZigpKTtcblxuY2xhc3MgQ29udGVudERlbGV0ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlbikge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuIC0gb2Zmc2V0KTtcbiAgICB0aGlzLmxlbiA9IG9mZnNldDtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREZWxldGVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMubGVuICs9IHJpZ2h0LmxlbjtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIGFkZFRvRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaXRlbS5pZC5jbGllbnQsIGl0ZW0uaWQuY2xvY2ssIHRoaXMubGVuKTtcbiAgICBpdGVtLm1hcmtEZWxldGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVMZW4odGhpcy5sZW4gLSBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIgfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnREZWxldGVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERlbGV0ZWQoZGVjb2Rlci5yZWFkTGVuKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBndWlkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdHNcbiAqL1xuY29uc3QgY3JlYXRlRG9jRnJvbU9wdHMgPSAoZ3VpZCwgb3B0cykgPT4gbmV3IERvYyh7IGd1aWQsIC4uLm9wdHMsIHNob3VsZExvYWQ6IG9wdHMuc2hvdWxkTG9hZCB8fCBvcHRzLmF1dG9Mb2FkIHx8IGZhbHNlIH0pO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnREb2Mge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIGlmIChkb2MuX2l0ZW0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoaXMgZG9jdW1lbnQgd2FzIGFscmVhZHkgaW50ZWdyYXRlZCBhcyBhIHN1Yi1kb2N1bWVudC4gWW91IHNob3VsZCBjcmVhdGUgYSBzZWNvbmQgaW5zdGFuY2UgaW5zdGVhZCB3aXRoIHRoZSBzYW1lIGd1aWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICBpZiAoIWRvYy5nYykge1xuICAgICAgb3B0cy5nYyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZG9jLmF1dG9Mb2FkKSB7XG4gICAgICBvcHRzLmF1dG9Mb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRvYy5tZXRhICE9PSBudWxsKSB7XG4gICAgICBvcHRzLm1ldGEgPSBkb2MubWV0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZG9jXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RG9jKGNyZWF0ZURvY0Zyb21PcHRzKHRoaXMuZG9jLmd1aWQsIHRoaXMub3B0cykpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREb2N9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgLy8gdGhpcyBuZWVkcyB0byBiZSByZWZsZWN0ZWQgaW4gZG9jLmRlc3Ryb3kgYXMgd2VsbFxuICAgIHRoaXMuZG9jLl9pdGVtID0gaXRlbTtcbiAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuYWRkKHRoaXMuZG9jKTtcbiAgICBpZiAodGhpcy5kb2Muc2hvdWxkTG9hZCkge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZC5hZGQodGhpcy5kb2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuaGFzKHRoaXMuZG9jKSkge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmRlbGV0ZSh0aGlzLmRvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzLmRvYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHsgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyh0aGlzLmRvYy5ndWlkKTtcbiAgICBlbmNvZGVyLndyaXRlQW55KHRoaXMub3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gOVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERvY31cbiAqL1xuY29uc3QgcmVhZENvbnRlbnREb2MgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RG9jKGNyZWF0ZURvY0Zyb21PcHRzKGRlY29kZXIucmVhZFN0cmluZygpLCBkZWNvZGVyLnJlYWRBbnkoKSkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRFbWJlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW1iZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbWJlZCkge1xuICAgIHRoaXMuZW1iZWQgPSBlbWJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5lbWJlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RW1iZWQodGhpcy5lbWJlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RW1iZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVKU09OKHRoaXMuZW1iZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDVcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRFbWJlZCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRFbWJlZChkZWNvZGVyLnJlYWRKU09OKCkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRGb3JtYXQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50Rm9ybWF0KHRoaXMua2V5LCB0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBzcGxpY2UgKF9vZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRGb3JtYXR9IF9yaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChfcmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBfdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKF90cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIEB0b2RvIHNlYXJjaG1hcmtlciBhcmUgY3VycmVudGx5IHVuc3VwcG9ydGVkIGZvciByaWNoIHRleHQgZG9jdW1lbnRzXG4gICAgY29uc3QgcCA9IC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudCk7XG4gICAgcC5fc2VhcmNoTWFya2VyID0gbnVsbDtcbiAgICBwLl9oYXNGb3JtYXR0aW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmtleSk7XG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy52YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNlxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50Rm9ybWF0ID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEZvcm1hdChkZWNvZGVyLnJlYWRLZXkoKSwgZGVjb2Rlci5yZWFkSlNPTigpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50SlNPTiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGFycikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEpTT059XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRKU09OKHRoaXMuYXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEpTT059XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRKU09OKHRoaXMuYXJyLnNsaWNlKG9mZnNldCkpO1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRKU09OfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycik7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5hcnIubGVuZ3RoO1xuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXTtcbiAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoYyA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICovXG5jb25zdCByZWFkQ29udGVudEpTT04gPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gIGNvbnN0IGNzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjID0gZGVjb2Rlci5yZWFkU3RyaW5nKCk7XG4gICAgaWYgKGMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzLnB1c2goSlNPTi5wYXJzZShjKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQ29udGVudEpTT04oY3MpXG59O1xuXG5jbGFzcyBDb250ZW50QW55IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QW55KHRoaXMuYXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudEFueSh0aGlzLmFyci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QW55fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycik7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5hcnIubGVuZ3RoO1xuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXTtcbiAgICAgIGVuY29kZXIud3JpdGVBbnkoYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICovXG5jb25zdCByZWFkQ29udGVudEFueSA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgY29uc3QgY3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNzLnB1c2goZGVjb2Rlci5yZWFkQW55KCkpO1xuICB9XG4gIHJldHVybiBuZXcgQ29udGVudEFueShjcylcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudFN0cmluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0ciA9IHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLnNwbGl0KCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0ci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAvLyBQcmV2ZW50IGVuY29kaW5nIGludmFsaWQgZG9jdW1lbnRzIGJlY2F1c2Ugb2Ygc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlyczogaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzI0OFxuICAgIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSB0aGlzLnN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDEpO1xuICAgIGlmIChmaXJzdENoYXJDb2RlID49IDB4RDgwMCAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxlZnQgc3BsaXQgaXMgdGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHV0ZjE2L3VjczIgcGFpci5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlycyBiZWNhdXNlIHRoaXMgbWF5IGxlYWQgdG8gaW52YWxpZCBkb2N1bWVudHMuXG4gICAgICAvLyBSZXBsYWNlIHRoZSBpbnZhbGlkIGNoYXJhY3RlciB3aXRoIGEgdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKO+/vSAvIFUrRkZGRClcbiAgICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0IC0gMSkgKyAn77+9JztcbiAgICAgIC8vIHJlcGxhY2UgcmlnaHQgYXMgd2VsbFxuICAgICAgcmlnaHQuc3RyID0gJ++/vScgKyByaWdodC5zdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudFN0cmluZ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLnN0ciArPSByaWdodC5zdHI7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyhvZmZzZXQgPT09IDAgPyB0aGlzLnN0ciA6IHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50U3RyaW5nID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFN0cmluZyhkZWNvZGVyLnJlYWRTdHJpbmcoKSk7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKFVwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMik6QWJzdHJhY3RUeXBlPGFueT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdHlwZVJlZnMgPSBbXG4gIHJlYWRZQXJyYXksXG4gIHJlYWRZTWFwLFxuICByZWFkWVRleHQsXG4gIHJlYWRZWG1sRWxlbWVudCxcbiAgcmVhZFlYbWxGcmFnbWVudCxcbiAgcmVhZFlYbWxIb29rLFxuICByZWFkWVhtbFRleHRcbl07XG5cbmNvbnN0IFlBcnJheVJlZklEID0gMDtcbmNvbnN0IFlNYXBSZWZJRCA9IDE7XG5jb25zdCBZVGV4dFJlZklEID0gMjtcbmNvbnN0IFlYbWxFbGVtZW50UmVmSUQgPSAzO1xuY29uc3QgWVhtbEZyYWdtZW50UmVmSUQgPSA0O1xuY29uc3QgWVhtbEhvb2tSZWZJRCA9IDU7XG5jb25zdCBZWG1sVGV4dFJlZklEID0gNjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnR5cGVdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50VHlwZSh0aGlzLnR5cGUuX2NvcHkoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRUeXBlfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIHRoaXMudHlwZS5faW50ZWdyYXRlKHRyYW5zYWN0aW9uLmRvYywgaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnQ7XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBnYydkIGxhdGVyIGFuZCB3ZSB3YW50IHRvIG1lcmdlIGl0IGlmIHBvc3NpYmxlXG4gICAgICAgIC8vIFdlIHRyeSB0byBtZXJnZSBhbGwgZGVsZXRlZCBpdGVtcyBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLFxuICAgICAgICAvLyBidXQgd2UgaGF2ZSBubyBrbm93bGVkZ2UgYWJvdXQgdGhhdCB0aGlzIG5lZWRzIHRvIGJlIG1lcmdlZFxuICAgICAgICAvLyBzaW5jZSBpdCBpcyBub3QgaW4gdHJhbnNhY3Rpb24uZHMuIEhlbmNlIHdlIGFkZCBpdCB0byB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmlkLmNsb2NrIDwgKHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkpIHtcbiAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5kZWxldGUodGhpcy50eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0O1xuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKTtcbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnR5cGUuX3N0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKC8qKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtICovIChpdGVtKSA9PiB7XG4gICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKTtcbiAgICAgICAgaXRlbSA9IGl0ZW0ubGVmdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnR5cGUuX21hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgdGhpcy50eXBlLl93cml0ZShlbmNvZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA3XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRUeXBlID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFR5cGUodHlwZVJlZnNbZGVjb2Rlci5yZWFkVHlwZVJlZigpXShkZWNvZGVyKSk7XG5cbi8qKlxuICogQHRvZG8gVGhpcyBzaG91bGQgcmV0dXJuIHNldmVyYWwgaXRlbXNcbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge3tpdGVtOkl0ZW0sIGRpZmY6bnVtYmVyfX1cbiAqL1xuY29uc3QgZm9sbG93UmVkb25lID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0lEfG51bGx9XG4gICAqL1xuICBsZXQgbmV4dElEID0gaWQ7XG4gIGxldCBkaWZmID0gMDtcbiAgbGV0IGl0ZW07XG4gIGRvIHtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIG5leHRJRCA9IGNyZWF0ZUlEKG5leHRJRC5jbGllbnQsIG5leHRJRC5jbG9jayArIGRpZmYpO1xuICAgIH1cbiAgICBpdGVtID0gZ2V0SXRlbShzdG9yZSwgbmV4dElEKTtcbiAgICBkaWZmID0gbmV4dElELmNsb2NrIC0gaXRlbS5pZC5jbG9jaztcbiAgICBuZXh0SUQgPSBpdGVtLnJlZG9uZTtcbiAgfSB3aGlsZSAobmV4dElEICE9PSBudWxsICYmIGl0ZW0gaW5zdGFuY2VvZiBJdGVtKVxuICByZXR1cm4ge1xuICAgIGl0ZW0sIGRpZmZcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCBuZWl0aGVyIGl0ZW0gbm9yIGFueSBvZiBpdHMgcGFyZW50cyBpcyBldmVyIGRlbGV0ZWQuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCBwZXJzaXN0IHdoZW4gc3RvcmluZyBpdCBpbnRvIGEgZGF0YWJhc2Ugb3Igd2hlblxuICogc2VuZGluZyBpdCB0byBvdGhlciBwZWVyc1xuICpcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBcbiAqL1xuY29uc3Qga2VlcEl0ZW0gPSAoaXRlbSwga2VlcCkgPT4ge1xuICB3aGlsZSAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtLmtlZXAgIT09IGtlZXApIHtcbiAgICBpdGVtLmtlZXAgPSBrZWVwO1xuICAgIGl0ZW0gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9pdGVtO1xuICB9XG59O1xuXG4vKipcbiAqIFNwbGl0IGxlZnRJdGVtIGludG8gdHdvIGl0ZW1zXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtfSBsZWZ0SXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzcGxpdEl0ZW0gPSAodHJhbnNhY3Rpb24sIGxlZnRJdGVtLCBkaWZmKSA9PiB7XG4gIC8vIGNyZWF0ZSByaWdodEl0ZW1cbiAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZDtcbiAgY29uc3QgcmlnaHRJdGVtID0gbmV3IEl0ZW0oXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLFxuICAgIGxlZnRJdGVtLFxuICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmIC0gMSksXG4gICAgbGVmdEl0ZW0ucmlnaHQsXG4gICAgbGVmdEl0ZW0ucmlnaHRPcmlnaW4sXG4gICAgbGVmdEl0ZW0ucGFyZW50LFxuICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICBsZWZ0SXRlbS5jb250ZW50LnNwbGljZShkaWZmKVxuICApO1xuICBpZiAobGVmdEl0ZW0uZGVsZXRlZCkge1xuICAgIHJpZ2h0SXRlbS5tYXJrRGVsZXRlZCgpO1xuICB9XG4gIGlmIChsZWZ0SXRlbS5rZWVwKSB7XG4gICAgcmlnaHRJdGVtLmtlZXAgPSB0cnVlO1xuICB9XG4gIGlmIChsZWZ0SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICByaWdodEl0ZW0ucmVkb25lID0gY3JlYXRlSUQobGVmdEl0ZW0ucmVkb25lLmNsaWVudCwgbGVmdEl0ZW0ucmVkb25lLmNsb2NrICsgZGlmZik7XG4gIH1cbiAgLy8gdXBkYXRlIGxlZnQgKGRvIG5vdCBzZXQgbGVmdEl0ZW0ucmlnaHRPcmlnaW4gYXMgaXQgd2lsbCBsZWFkIHRvIHByb2JsZW1zIHdoZW4gc3luY2luZylcbiAgbGVmdEl0ZW0ucmlnaHQgPSByaWdodEl0ZW07XG4gIC8vIHVwZGF0ZSByaWdodFxuICBpZiAocmlnaHRJdGVtLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJpZ2h0LmxlZnQgPSByaWdodEl0ZW07XG4gIH1cbiAgLy8gcmlnaHQgaXMgbW9yZSBzcGVjaWZpYy5cbiAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKHJpZ2h0SXRlbSk7XG4gIC8vIHVwZGF0ZSBwYXJlbnQuX21hcFxuICBpZiAocmlnaHRJdGVtLnBhcmVudFN1YiAhPT0gbnVsbCAmJiByaWdodEl0ZW0ucmlnaHQgPT09IG51bGwpIHtcbiAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRJdGVtLnBhcmVudCkuX21hcC5zZXQocmlnaHRJdGVtLnBhcmVudFN1YiwgcmlnaHRJdGVtKTtcbiAgfVxuICBsZWZ0SXRlbS5sZW5ndGggPSBkaWZmO1xuICByZXR1cm4gcmlnaHRJdGVtXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKi9cbmNvbnN0IGlzRGVsZXRlZEJ5VW5kb1N0YWNrID0gKHN0YWNrLCBpZCkgPT4gYXJyYXkuc29tZShzdGFjaywgLyoqIEBwYXJhbSB7U3RhY2tJdGVtfSBzICovIHMgPT4gaXNEZWxldGVkKHMuZGVsZXRpb25zLCBpZCkpO1xuXG4vKipcbiAqIFJlZG9lcyB0aGUgZWZmZWN0IG9mIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSBZanMgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U2V0PEl0ZW0+fSByZWRvaXRlbXNcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBpdGVtc1RvRGVsZXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVJlbW90ZU1hcENoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi91dGlscy9VbmRvTWFuYWdlci5qcycpLlVuZG9NYW5hZ2VyfSB1bVxuICpcbiAqIEByZXR1cm4ge0l0ZW18bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCByZWRvSXRlbSA9ICh0cmFuc2FjdGlvbiwgaXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCBvd25DbGllbnRJRCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3QgcmVkb25lID0gaXRlbS5yZWRvbmU7XG4gIGlmIChyZWRvbmUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHJlZG9uZSlcbiAgfVxuICBsZXQgcGFyZW50SXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW07XG4gIC8qKlxuICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgKi9cbiAgbGV0IGxlZnQgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCByaWdodDtcbiAgLy8gbWFrZSBzdXJlIHRoYXQgcGFyZW50IGlzIHJlZG9uZVxuICBpZiAocGFyZW50SXRlbSAhPT0gbnVsbCAmJiBwYXJlbnRJdGVtLmRlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAvLyB0cnkgdG8gdW5kbyBwYXJlbnQgaWYgaXQgd2lsbCBiZSB1bmRvbmUgYW55d2F5XG4gICAgaWYgKHBhcmVudEl0ZW0ucmVkb25lID09PSBudWxsICYmICghcmVkb2l0ZW1zLmhhcyhwYXJlbnRJdGVtKSB8fCByZWRvSXRlbSh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB3aGlsZSAocGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbS5yZWRvbmUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50SXRlbSA9PT0gbnVsbCA/IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkgOiAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAocGFyZW50SXRlbS5jb250ZW50KS50eXBlO1xuXG4gIGlmIChpdGVtLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgIC8vIElzIGFuIGFycmF5IGl0ZW0uIEluc2VydCBhdCB0aGUgb2xkIHBvc2l0aW9uXG4gICAgbGVmdCA9IGl0ZW0ubGVmdDtcbiAgICByaWdodCA9IGl0ZW07XG4gICAgLy8gZmluZCBuZXh0IGNsb25lZF9yZWRvIGl0ZW1zXG4gICAgd2hpbGUgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IGxlZnRUcmFjZSA9IGxlZnQ7XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChsZWZ0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGxlZnRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIGxlZnRUcmFjZSA9IGxlZnRUcmFjZS5yZWRvbmUgPT09IG51bGwgPyBudWxsIDogZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnRUcmFjZS5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdCA9IGxlZnRUcmFjZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBsZWZ0LmxlZnQ7XG4gICAgfVxuICAgIHdoaWxlIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcmlnaHRUcmFjZSA9IHJpZ2h0O1xuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0VHJhY2UgPSByaWdodFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmlnaHRUcmFjZS5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICByaWdodCA9IHJpZ2h0VHJhY2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICByaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByaWdodCA9IG51bGw7XG4gICAgaWYgKGl0ZW0ucmlnaHQgJiYgIWlnbm9yZVJlbW90ZU1hcENoYW5nZXMpIHtcbiAgICAgIGxlZnQgPSBpdGVtO1xuICAgICAgLy8gSXRlcmF0ZSByaWdodCB3aGlsZSByaWdodCBpcyBpbiBpdGVtc1RvRGVsZXRlXG4gICAgICAvLyBJZiBpdCBpcyBpbnRlbmRlZCB0byBkZWxldGUgcmlnaHQgd2hpbGUgaXRlbSBpcyByZWRvbmUsIHdlIGNhbiBleHBlY3QgdGhhdCBpdGVtIHNob3VsZCByZXBsYWNlIHJpZ2h0LlxuICAgICAgd2hpbGUgKGxlZnQgIT09IG51bGwgJiYgbGVmdC5yaWdodCAhPT0gbnVsbCAmJiAobGVmdC5yaWdodC5yZWRvbmUgfHwgaXNEZWxldGVkKGl0ZW1zVG9EZWxldGUsIGxlZnQucmlnaHQuaWQpIHx8IGlzRGVsZXRlZEJ5VW5kb1N0YWNrKHVtLnVuZG9TdGFjaywgbGVmdC5yaWdodC5pZCkgfHwgaXNEZWxldGVkQnlVbmRvU3RhY2sodW0ucmVkb1N0YWNrLCBsZWZ0LnJpZ2h0LmlkKSkpIHtcbiAgICAgICAgbGVmdCA9IGxlZnQucmlnaHQ7XG4gICAgICAgIC8vIGZvbGxvdyByZWRvbmVcbiAgICAgICAgd2hpbGUgKGxlZnQucmVkb25lKSBsZWZ0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnQucmVkb25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICYmIGxlZnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZG8gdGhpcyBpdGVtIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggYVxuICAgICAgICAvLyBjaGFuZ2UgZnJvbSBhbm90aGVyIGNsaWVudFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gcGFyZW50VHlwZS5fbWFwLmdldChpdGVtLnBhcmVudFN1YikgfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV4dENsb2NrID0gZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElEKTtcbiAgY29uc3QgbmV4dElkID0gY3JlYXRlSUQob3duQ2xpZW50SUQsIG5leHRDbG9jayk7XG4gIGNvbnN0IHJlZG9uZUl0ZW0gPSBuZXcgSXRlbShcbiAgICBuZXh0SWQsXG4gICAgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCxcbiAgICByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsXG4gICAgcGFyZW50VHlwZSxcbiAgICBpdGVtLnBhcmVudFN1YixcbiAgICBpdGVtLmNvbnRlbnQuY29weSgpXG4gICk7XG4gIGl0ZW0ucmVkb25lID0gbmV4dElkO1xuICBrZWVwSXRlbShyZWRvbmVJdGVtLCB0cnVlKTtcbiAgcmVkb25lSXRlbS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICByZXR1cm4gcmVkb25lSXRlbVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gKi9cbmNsYXNzIEl0ZW0gZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSBvcmlnaW5cbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gcmlnaHRcbiAgICogQHBhcmFtIHtJRCB8IG51bGx9IHJpZ2h0T3JpZ2luXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH0gcGFyZW50IElzIGEgdHlwZSBpZiBpbnRlZ3JhdGVkLCBpcyBudWxsIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGNvcHkgcGFyZW50IGZyb20gbGVmdCBvciByaWdodCwgaXMgSUQgYmVmb3JlIGludGVncmF0aW9uIHRvIHNlYXJjaCBmb3IgaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGFyZW50U3ViXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250ZW50fSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlZnQsIG9yaWdpbiwgcmlnaHQsIHJpZ2h0T3JpZ2luLCBwYXJlbnQsIHBhcmVudFN1YiwgY29udGVudCkge1xuICAgIHN1cGVyKGlkLCBjb250ZW50LmdldExlbmd0aCgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgaXMgY3VycmVudGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodE9yaWdpbiA9IHJpZ2h0T3JpZ2luO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55PnxJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwYXJlbnQgcmVmZXJzIHRvIHRoaXMgaXRlbSB3aXRoIHNvbWUga2luZCBvZiBrZXkgKGUuZy4gWU1hcCwgdGhlXG4gICAgICoga2V5IGlzIHNwZWNpZmllZCBoZXJlLiBUaGUga2V5IGlzIHRoZW4gdXNlZCB0byByZWZlciB0byB0aGUgbGlzdCBpbiB3aGljaFxuICAgICAqIHRvIGluc2VydCB0aGlzIGl0ZW0uIElmIGBwYXJlbnRTdWIgPSBudWxsYCB0eXBlLl9zdGFydCBpcyB0aGUgbGlzdCBpblxuICAgICAqIHdoaWNoIHRvIGluc2VydCB0by4gT3RoZXJ3aXNlIGl0IGlzIGBwYXJlbnQuX21hcGAuXG4gICAgICogQHR5cGUge1N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB0eXBlJ3MgZWZmZWN0IGlzIHJlZG9uZSB0aGlzIHR5cGUgcmVmZXJzIHRvIHRoZSB0eXBlIHRoYXQgdW5kaWRcbiAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVkb25lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RDb250ZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogYml0MToga2VlcFxuICAgICAqIGJpdDI6IGNvdW50YWJsZVxuICAgICAqIGJpdDM6IGRlbGV0ZWRcbiAgICAgKiBiaXQ0OiBtYXJrIC0gbWFyayBub2RlIGFzIGZhc3Qtc2VhcmNoLW1hcmtlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IGJ5dGVcbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB0aGlzLmNvbnRlbnQuaXNDb3VudGFibGUoKSA/IGJpbmFyeS5CSVQyIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gbWFyayB0aGUgaXRlbSBhcyBhbiBpbmRleGVkIGZhc3Qtc2VhcmNoIG1hcmtlclxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBtYXJrZXIgKGlzTWFya2VkKSB7XG4gICAgaWYgKCgodGhpcy5pbmZvICYgYmluYXJ5LkJJVDQpID4gMCkgIT09IGlzTWFya2VkKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1hcmtlciAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUNCkgPiAwXG4gIH1cblxuICAvKipcbiAgICogSWYgdHJ1ZSwgZG8gbm90IGdhcmJhZ2UgY29sbGVjdCB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQga2VlcCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMSkgPiAwXG4gIH1cblxuICBzZXQga2VlcCAoZG9LZWVwKSB7XG4gICAgaWYgKHRoaXMua2VlcCAhPT0gZG9LZWVwKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDE7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMikgPiAwXG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGl0ZW0gd2FzIGRlbGV0ZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQzKSA+IDBcbiAgfVxuXG4gIHNldCBkZWxldGVkIChkb0RlbGV0ZSkge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQgIT09IGRvRGVsZXRlKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDM7XG4gICAgfVxuICB9XG5cbiAgbWFya0RlbGV0ZWQgKCkge1xuICAgIHRoaXMuaW5mbyB8PSBiaW5hcnkuQklUMztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNyZWF0b3IgY2xpZW50SUQgb2YgdGhlIG1pc3Npbmcgb3Agb3IgZGVmaW5lIG1pc3NpbmcgaXRlbXMgYW5kIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luICYmIHRoaXMub3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5vcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMub3JpZ2luLmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucmlnaHRPcmlnaW4gJiYgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQgIT09IHRoaXMuaWQuY2xpZW50ICYmIHRoaXMucmlnaHRPcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQgJiYgdGhpcy5pZC5jbGllbnQgIT09IHRoaXMucGFyZW50LmNsaWVudCAmJiB0aGlzLnBhcmVudC5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5wYXJlbnQuY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNsaWVudFxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYWxsIG1pc3NpbmcgaWRzLCBub3cgZmluZCB0aGUgaXRlbXNcblxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCBzdG9yZSwgdGhpcy5vcmlnaW4pO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbikge1xuICAgICAgdGhpcy5yaWdodCA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCB0aGlzLnJpZ2h0T3JpZ2luKTtcbiAgICAgIHRoaXMucmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0LmlkO1xuICAgIH1cbiAgICBpZiAoKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB8fCAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBHQykpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgLy8gb25seSBzZXQgcGFyZW50IGlmIHRoaXMgc2hvdWxkbid0IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMubGVmdC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5sZWZ0LnBhcmVudFN1YjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuY29uc3RydWN0b3IgPT09IEl0ZW0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnJpZ2h0LnBhcmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLnJpZ2h0LnBhcmVudFN1YjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgY29uc3QgcGFyZW50SXRlbSA9IGdldEl0ZW0oc3RvcmUsIHRoaXMucGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnRJdGVtLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIHRoaXMuaWQuY2xvY2sgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrIC0gMSkpO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50LnNwbGljZShvZmZzZXQpO1xuICAgICAgdGhpcy5sZW5ndGggLT0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKCghdGhpcy5sZWZ0ICYmICghdGhpcy5yaWdodCB8fCB0aGlzLnJpZ2h0LmxlZnQgIT09IG51bGwpKSB8fCAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5yaWdodCAhPT0gdGhpcy5yaWdodCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBvO1xuICAgICAgICAvLyBzZXQgbyB0byB0aGUgZmlyc3QgY29uZmxpY3RpbmcgaXRlbVxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSBsZWZ0LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5nZXQodGhpcy5wYXJlbnRTdWIpIHx8IG51bGw7XG4gICAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgby5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXNlIHNvbWV0aGluZyBsaWtlIERlbGV0ZVNldCBoZXJlIChhIHRyZWUgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYmVzdClcbiAgICAgICAgLy8gQHRvZG8gdXNlIGdsb2JhbCBzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGl0ZW1zQmVmb3JlT3JpZ2luID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBMZXQgYyBpbiBjb25mbGljdGluZ0l0ZW1zLCBiIGluIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIC8vICoqKntvcmlnaW59YmJiYnt0aGlzfXtjLGJ9e2MsYn17b30qKipcbiAgICAgICAgLy8gTm90ZSB0aGF0IGNvbmZsaWN0aW5nSXRlbXMgaXMgYSBzdWJzZXQgb2YgaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgbyAhPT0gdGhpcy5yaWdodCkge1xuICAgICAgICAgIGl0ZW1zQmVmb3JlT3JpZ2luLmFkZChvKTtcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKTtcbiAgICAgICAgICBpZiAoY29tcGFyZUlEcyh0aGlzLm9yaWdpbiwgby5vcmlnaW4pKSB7XG4gICAgICAgICAgICAvLyBjYXNlIDFcbiAgICAgICAgICAgIGlmIChvLmlkLmNsaWVudCA8IHRoaXMuaWQuY2xpZW50KSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgby5yaWdodE9yaWdpbikpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBhbmQgbyBhcmUgY29uZmxpY3RpbmcgYW5kIHBvaW50IHRvIHRoZSBzYW1lIGludGVncmF0aW9uIHBvaW50cy4gVGhlIGlkIGRlY2lkZXMgd2hpY2ggaXRlbSBjb21lcyBmaXJzdC5cbiAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyB0byB0aGUgbGVmdCBvZiBvLCB3ZSBjYW4gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSAvLyBlbHNlLCBvIG1pZ2h0IGJlIGludGVncmF0ZWQgYmVmb3JlIGFuIGl0ZW0gdGhhdCB0aGlzIGNvbmZsaWN0cyB3aXRoLiBJZiBzbywgd2Ugd2lsbCBmaW5kIGl0IGluIHRoZSBuZXh0IGl0ZXJhdGlvbnNcbiAgICAgICAgICB9IGVsc2UgaWYgKG8ub3JpZ2luICE9PSBudWxsICYmIGl0ZW1zQmVmb3JlT3JpZ2luLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkgeyAvLyB1c2UgZ2V0SXRlbSBpbnN0ZWFkIG9mIGdldEl0ZW1DbGVhbkVuZCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgLyBuZWVkIHRvIHNwbGl0IGl0ZW1zLlxuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICB9XG4gICAgICAvLyByZWNvbm5lY3QgbGVmdC9yaWdodCArIHVwZGF0ZSBwYXJlbnQgbWFwL3N0YXJ0IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMubGVmdC5yaWdodDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHI7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgIHdoaWxlIChyICE9PSBudWxsICYmIHIubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IHIubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgciA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0XG4gICAgICAgICAgOy8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJpZ2h0ID0gcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHNldCBhcyBjdXJyZW50IHBhcmVudCB2YWx1ZSBpZiByaWdodCA9PT0gbnVsbCBhbmQgdGhpcyBpcyBwYXJlbnRTdWJcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLnNldCh0aGlzLnBhcmVudFN1YiwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnQuIGRlbGV0ZSByaWdodFxuICAgICAgICAgIHRoaXMubGVmdC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMucGFyZW50U3ViID09PSBudWxsICYmIHRoaXMuY291bnRhYmxlICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbGVuZ3RoICs9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcyk7XG4gICAgICB0aGlzLmNvbnRlbnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCB0aGlzKTtcbiAgICAgIC8vIGFkZCBwYXJlbnQgdG8gdHJhbnNhY3Rpb24uY2hhbmdlZFxuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLCB0aGlzLnBhcmVudFN1Yik7XG4gICAgICBpZiAoKC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0gIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5faXRlbS5kZWxldGVkKSB8fCAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwgJiYgdGhpcy5yaWdodCAhPT0gbnVsbCkpIHtcbiAgICAgICAgLy8gZGVsZXRlIGlmIHBhcmVudCBpcyBkZWxldGVkIG9yIGlmIHRoaXMgaXMgbm90IHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnRcbiAgICAgICAgdGhpcy5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGRlZmluZWQuIEludGVncmF0ZSBHQyBzdHJ1Y3QgaW5zdGVhZFxuICAgICAgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBuZXh0ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMucmlnaHQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgcHJldiAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxlZnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gblxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBsYXN0IGNvbnRlbnQgYWRkcmVzcyBvZiB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQgbGFzdElkICgpIHtcbiAgICAvLyBhbGxvY2F0aW5nIGlkcyBpcyBwcmV0dHkgY29zdGx5IGJlY2F1c2Ugb2YgdGhlIGFtb3VudCBvZiBpZHMgY3JlYXRlZCwgc28gd2UgdHJ5IHRvIHJldXNlIHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxID8gdGhpcy5pZCA6IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggLSAxKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBtZXJnZSB0d28gaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHtJdGVtfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yICYmXG4gICAgICBjb21wYXJlSURzKHJpZ2h0Lm9yaWdpbiwgdGhpcy5sYXN0SWQpICYmXG4gICAgICB0aGlzLnJpZ2h0ID09PSByaWdodCAmJlxuICAgICAgY29tcGFyZUlEcyh0aGlzLnJpZ2h0T3JpZ2luLCByaWdodC5yaWdodE9yaWdpbikgJiZcbiAgICAgIHRoaXMuaWQuY2xpZW50ID09PSByaWdodC5pZC5jbGllbnQgJiZcbiAgICAgIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCA9PT0gcmlnaHQuaWQuY2xvY2sgJiZcbiAgICAgIHRoaXMuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJlxuICAgICAgdGhpcy5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHJpZ2h0LnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgdGhpcy5jb250ZW50LmNvbnN0cnVjdG9yID09PSByaWdodC5jb250ZW50LmNvbnN0cnVjdG9yICYmXG4gICAgICB0aGlzLmNvbnRlbnQubWVyZ2VXaXRoKHJpZ2h0LmNvbnRlbnQpXG4gICAgKSB7XG4gICAgICBjb25zdCBzZWFyY2hNYXJrZXIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zZWFyY2hNYXJrZXI7XG4gICAgICBpZiAoc2VhcmNoTWFya2VyKSB7XG4gICAgICAgIHNlYXJjaE1hcmtlci5mb3JFYWNoKG1hcmtlciA9PiB7XG4gICAgICAgICAgaWYgKG1hcmtlci5wID09PSByaWdodCkge1xuICAgICAgICAgICAgLy8gcmlnaHQgaXMgZ29pbmcgdG8gYmUgXCJmb3Jnb3R0ZW5cIiBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFya2VyXG4gICAgICAgICAgICBtYXJrZXIucCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBhZGp1c3QgbWFya2VyIGluZGV4XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlZCAmJiB0aGlzLmNvdW50YWJsZSkge1xuICAgICAgICAgICAgICBtYXJrZXIuaW5kZXggLT0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodC5rZWVwKSB7XG4gICAgICAgIHRoaXMua2VlcCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KTtcbiAgICAgIC8vIGFkanVzdCB0aGUgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMuY291bnRhYmxlICYmIHRoaXMucGFyZW50U3ViID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5fbGVuZ3RoIC09IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXJrRGVsZXRlZCgpO1xuICAgICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCB0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jaywgdGhpcy5sZW5ndGgpO1xuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBwYXJlbnQsIHRoaXMucGFyZW50U3ViKTtcbiAgICAgIHRoaXMuY29udGVudC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmVudEdDZFxuICAgKi9cbiAgZ2MgKHN0b3JlLCBwYXJlbnRHQ2QpIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQuZ2Moc3RvcmUpO1xuICAgIGlmIChwYXJlbnRHQ2QpIHtcbiAgICAgIHJlcGxhY2VTdHJ1Y3Qoc3RvcmUsIHRoaXMsIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb2Zmc2V0ID4gMCA/IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgb2Zmc2V0IC0gMSkgOiB0aGlzLm9yaWdpbjtcbiAgICBjb25zdCByaWdodE9yaWdpbiA9IHRoaXMucmlnaHRPcmlnaW47XG4gICAgY29uc3QgcGFyZW50U3ViID0gdGhpcy5wYXJlbnRTdWI7XG4gICAgY29uc3QgaW5mbyA9ICh0aGlzLmNvbnRlbnQuZ2V0UmVmKCkgJiBiaW5hcnkuQklUUzUpIHxcbiAgICAgIChvcmlnaW4gPT09IG51bGwgPyAwIDogYmluYXJ5LkJJVDgpIHwgLy8gb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChyaWdodE9yaWdpbiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNykgfCAvLyByaWdodCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHBhcmVudFN1YiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNik7IC8vIHBhcmVudFN1YiBpcyBub24tbnVsbFxuICAgIGVuY29kZXIud3JpdGVJbmZvKGluZm8pO1xuICAgIGlmIChvcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQob3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0T3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlUmlnaHRJRChyaWdodE9yaWdpbik7XG4gICAgfVxuICAgIGlmIChvcmlnaW4gPT09IG51bGwgJiYgcmlnaHRPcmlnaW4gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICBpZiAocGFyZW50Ll9pdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50SXRlbSA9IHBhcmVudC5faXRlbTtcbiAgICAgICAgaWYgKHBhcmVudEl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBwYXJlbnQgdHlwZSBvbiB5Ll9tYXBcbiAgICAgICAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IGtleVxuICAgICAgICAgIGNvbnN0IHlrZXkgPSBmaW5kUm9vdFR5cGVLZXkocGFyZW50KTtcbiAgICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKTsgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoeWtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpOyAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgICBlbmNvZGVyLndyaXRlTGVmdElEKHBhcmVudEl0ZW0uaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7IC8vIHRoaXMgZWRnZSBjYXNlIHdhcyBhZGRlZCBieSBkaWZmZXJlbnRpYWwgdXBkYXRlc1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKTsgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpOyAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChwYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhwYXJlbnRTdWIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQud3JpdGUoZW5jb2Rlciwgb2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5mb1xuICovXG5jb25zdCByZWFkSXRlbUNvbnRlbnQgPSAoZGVjb2RlciwgaW5mbykgPT4gY29udGVudFJlZnNbaW5mbyAmIGJpbmFyeS5CSVRTNV0oZGVjb2Rlcik7XG5cbi8qKlxuICogQSBsb29rdXAgbWFwIGZvciByZWFkaW5nIEl0ZW0gY29udGVudC5cbiAqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oVXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyKTpBYnN0cmFjdENvbnRlbnQ+fVxuICovXG5jb25zdCBjb250ZW50UmVmcyA9IFtcbiAgKCkgPT4geyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpOyB9LCAvLyBHQyBpcyBub3QgSXRlbUNvbnRlbnRcbiAgcmVhZENvbnRlbnREZWxldGVkLCAvLyAxXG4gIHJlYWRDb250ZW50SlNPTiwgLy8gMlxuICByZWFkQ29udGVudEJpbmFyeSwgLy8gM1xuICByZWFkQ29udGVudFN0cmluZywgLy8gNFxuICByZWFkQ29udGVudEVtYmVkLCAvLyA1XG4gIHJlYWRDb250ZW50Rm9ybWF0LCAvLyA2XG4gIHJlYWRDb250ZW50VHlwZSwgLy8gN1xuICByZWFkQ29udGVudEFueSwgLy8gOFxuICByZWFkQ29udGVudERvYywgLy8gOVxuICAoKSA9PiB7IGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7IH0gLy8gMTAgLSBTa2lwIGlzIG5vdCBJdGVtQ29udGVudFxuXTtcblxuY29uc3Qgc3RydWN0U2tpcFJlZk51bWJlciA9IDEwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFNraXAgZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZGVsZXRlICgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2tpcH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICAvLyBza2lwIHN0cnVjdHMgY2Fubm90IGJlIGludGVncmF0ZWRcbiAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RTa2lwUmVmTnVtYmVyKTtcbiAgICAvLyB3cml0ZSBhcyBWYXJVaW50IGJlY2F1c2UgU2tpcHMgY2FuJ3QgbWFrZSB1c2Ugb2YgcHJlZGljdGFibGUgbGVuZ3RoLWVuY29kaW5nXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHRoaXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKiogZXNsaW50LWVudiBicm93c2VyICovXG5cblxuY29uc3QgZ2xvID0gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBnbG9iYWxUaGlzXG4gIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge30pO1xuXG5jb25zdCBpbXBvcnRJZGVudGlmaWVyID0gJ19fICRZSlMkIF9fJztcblxuaWYgKGdsb1tpbXBvcnRJZGVudGlmaWVyXSA9PT0gdHJ1ZSkge1xuICAvKipcbiAgICogRGVhciByZWFkZXIgb2YgdGhpcyBtZXNzYWdlLiBQbGVhc2UgdGFrZSB0aGlzIHNlcmlvdXNseS5cbiAgICpcbiAgICogSWYgeW91IHNlZSB0aGlzIG1lc3NhZ2UsIG1ha2Ugc3VyZSB0aGF0IHlvdSBvbmx5IGltcG9ydCBvbmUgdmVyc2lvbiBvZiBZanMuIEluIG1hbnkgY2FzZXMsXG4gICAqIHlvdXIgcGFja2FnZSBtYW5hZ2VyIGluc3RhbGxzIHR3byB2ZXJzaW9ucyBvZiBZanMgdGhhdCBhcmUgdXNlZCBieSBkaWZmZXJlbnQgcGFja2FnZXMgd2l0aGluIHlvdXIgcHJvamVjdC5cbiAgICogQW5vdGhlciByZWFzb24gZm9yIHRoaXMgbWVzc2FnZSBpcyB0aGF0IHNvbWUgcGFydHMgb2YgeW91ciBwcm9qZWN0IHVzZSB0aGUgY29tbW9uanMgdmVyc2lvbiBvZiBZanNcbiAgICogYW5kIG90aGVycyB1c2UgdGhlIEVjbWFTY3JpcHQgdmVyc2lvbiBvZiBZanMuXG4gICAqXG4gICAqIFRoaXMgb2Z0ZW4gbGVhZHMgdG8gaXNzdWVzIHRoYXQgYXJlIGhhcmQgdG8gZGVidWcuIFdlIG9mdGVuIG5lZWQgdG8gcGVyZm9ybSBjb25zdHJ1Y3RvciBjaGVja3MsXG4gICAqIGUuZy4gYHN0cnVjdCBpbnN0YW5jZW9mIEdDYC4gSWYgeW91IGltcG9ydGVkIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBZanMsIGl0IGlzIGltcG9zc2libGUgZm9yIHVzIHRvXG4gICAqIGRvIHRoZSBjb25zdHJ1Y3RvciBjaGVja3MgYW55bW9yZSAtIHdoaWNoIG1pZ2h0IGJyZWFrIHRoZSBDUkRUIGFsZ29yaXRobS5cbiAgICpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzQzOFxuICAgKi9cbiAgY29uc29sZS5lcnJvcignWWpzIHdhcyBhbHJlYWR5IGltcG9ydGVkLiBUaGlzIGJyZWFrcyBjb25zdHJ1Y3RvciBjaGVja3MgYW5kIHdpbGwgbGVhZCB0byBpc3N1ZXMhIC0gaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzQzOCcpO1xufVxuZ2xvW2ltcG9ydElkZW50aWZpZXJdID0gdHJ1ZTtcblxuZXhwb3J0IHsgQWJzb2x1dGVQb3NpdGlvbiwgQWJzdHJhY3RDb25uZWN0b3IsIEFic3RyYWN0U3RydWN0LCBBYnN0cmFjdFR5cGUsIFlBcnJheSBhcyBBcnJheSwgQ29udGVudEFueSwgQ29udGVudEJpbmFyeSwgQ29udGVudERlbGV0ZWQsIENvbnRlbnREb2MsIENvbnRlbnRFbWJlZCwgQ29udGVudEZvcm1hdCwgQ29udGVudEpTT04sIENvbnRlbnRTdHJpbmcsIENvbnRlbnRUeXBlLCBEb2MsIEdDLCBJRCwgSXRlbSwgWU1hcCBhcyBNYXAsIFBlcm1hbmVudFVzZXJEYXRhLCBSZWxhdGl2ZVBvc2l0aW9uLCBTa2lwLCBTbmFwc2hvdCwgWVRleHQgYXMgVGV4dCwgVHJhbnNhY3Rpb24sIFVuZG9NYW5hZ2VyLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIFlYbWxFbGVtZW50IGFzIFhtbEVsZW1lbnQsIFlYbWxGcmFnbWVudCBhcyBYbWxGcmFnbWVudCwgWVhtbEhvb2sgYXMgWG1sSG9vaywgWVhtbFRleHQgYXMgWG1sVGV4dCwgWUFycmF5RXZlbnQsIFlFdmVudCwgWU1hcEV2ZW50LCBZVGV4dEV2ZW50LCBZWG1sRXZlbnQsIGFwcGx5VXBkYXRlLCBhcHBseVVwZGF0ZVYyLCBjbGVhbnVwWVRleHRGb3JtYXR0aW5nLCBjb21wYXJlSURzLCBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMsIGNvbnZlcnRVcGRhdGVGb3JtYXRWMVRvVjIsIGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEsIGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbiwgY3JlYXRlRGVsZXRlU2V0LCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUsIGNyZWF0ZURvY0Zyb21TbmFwc2hvdCwgY3JlYXRlSUQsIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiwgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgsIGNyZWF0ZVNuYXBzaG90LCBkZWNvZGVSZWxhdGl2ZVBvc2l0aW9uLCBkZWNvZGVTbmFwc2hvdCwgZGVjb2RlU25hcHNob3RWMiwgZGVjb2RlU3RhdGVWZWN0b3IsIGRlY29kZVVwZGF0ZSwgZGVjb2RlVXBkYXRlVjIsIGRpZmZVcGRhdGUsIGRpZmZVcGRhdGVWMiwgZW1wdHlTbmFwc2hvdCwgZW5jb2RlUmVsYXRpdmVQb3NpdGlvbiwgZW5jb2RlU25hcHNob3QsIGVuY29kZVNuYXBzaG90VjIsIGVuY29kZVN0YXRlQXNVcGRhdGUsIGVuY29kZVN0YXRlQXNVcGRhdGVWMiwgZW5jb2RlU3RhdGVWZWN0b3IsIGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZSwgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIsIGVxdWFsRGVsZXRlU2V0cywgZXF1YWxTbmFwc2hvdHMsIGZpbmRJbmRleFNTLCBmaW5kUm9vdFR5cGVLZXksIGdldEl0ZW0sIGdldFN0YXRlLCBnZXRUeXBlQ2hpbGRyZW4sIGlzRGVsZXRlZCwgaXNQYXJlbnRPZiwgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLCBsb2dUeXBlLCBsb2dVcGRhdGUsIGxvZ1VwZGF0ZVYyLCBtZXJnZVVwZGF0ZXMsIG1lcmdlVXBkYXRlc1YyLCBvYmZ1c2NhdGVVcGRhdGUsIG9iZnVzY2F0ZVVwZGF0ZVYyLCBwYXJzZVVwZGF0ZU1ldGEsIHBhcnNlVXBkYXRlTWV0YVYyLCByZWFkVXBkYXRlLCByZWFkVXBkYXRlVjIsIHJlbGF0aXZlUG9zaXRpb25Ub0pTT04sIHNuYXBzaG90LCBzbmFwc2hvdENvbnRhaW5zVXBkYXRlLCB0cmFuc2FjdCwgdHJ5R2MsIHR5cGVMaXN0VG9BcnJheVNuYXBzaG90LCB0eXBlTWFwR2V0QWxsU25hcHNob3QsIHR5cGVNYXBHZXRTbmFwc2hvdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eWpzLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlIiwiYXJyYXkiLCJtYXRoIiwibWFwIiwiZW5jb2RpbmciLCJkZWNvZGluZyIsInJhbmRvbSIsInByb21pc2UiLCJidWZmZXIiLCJlcnJvciIsImJpbmFyeSIsImYiLCJjYWxsQWxsIiwic2V0IiwibG9nZ2luZyIsInRpbWUiLCJzdHJpbmciLCJpdGVyYXRvciIsIm9iamVjdCIsIkFic3RyYWN0Q29ubmVjdG9yIiwiY29uc3RydWN0b3IiLCJ5ZG9jIiwiYXdhcmVuZXNzIiwiZG9jIiwiRGVsZXRlSXRlbSIsImNsb2NrIiwibGVuIiwiRGVsZXRlU2V0IiwiY2xpZW50cyIsIk1hcCIsIml0ZXJhdGVEZWxldGVkU3RydWN0cyIsInRyYW5zYWN0aW9uIiwiZHMiLCJmb3JFYWNoIiwiZGVsZXRlcyIsImNsaWVudGlkIiwic3RydWN0cyIsInN0b3JlIiwiZ2V0IiwiaSIsImxlbmd0aCIsImRlbCIsIml0ZXJhdGVTdHJ1Y3RzIiwiZmluZEluZGV4RFMiLCJkaXMiLCJsZWZ0IiwicmlnaHQiLCJtaWRpbmRleCIsImZsb29yIiwibWlkIiwibWlkY2xvY2siLCJpc0RlbGV0ZWQiLCJpZCIsImNsaWVudCIsInVuZGVmaW5lZCIsInNvcnRBbmRNZXJnZURlbGV0ZVNldCIsImRlbHMiLCJzb3J0IiwiYSIsImIiLCJqIiwibWF4IiwibWVyZ2VEZWxldGVTZXRzIiwiZHNzIiwibWVyZ2VkIiwiZHNzSSIsImRlbHNMZWZ0IiwiaGFzIiwic2xpY2UiLCJhcHBlbmRUbyIsImFkZFRvRGVsZXRlU2V0Iiwic2V0SWZVbmRlZmluZWQiLCJwdXNoIiwiY3JlYXRlRGVsZXRlU2V0IiwiY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlIiwic3MiLCJkc2l0ZW1zIiwic3RydWN0IiwiZGVsZXRlZCIsIm5leHQiLCJ3cml0ZURlbGV0ZVNldCIsImVuY29kZXIiLCJ3cml0ZVZhclVpbnQiLCJyZXN0RW5jb2RlciIsInNpemUiLCJmcm9tIiwiZW50cmllcyIsInJlc2V0RHNDdXJWYWwiLCJpdGVtIiwid3JpdGVEc0Nsb2NrIiwid3JpdGVEc0xlbiIsInJlYWREZWxldGVTZXQiLCJkZWNvZGVyIiwibnVtQ2xpZW50cyIsInJlYWRWYXJVaW50IiwicmVzdERlY29kZXIiLCJudW1iZXJPZkRlbGV0ZXMiLCJkc0ZpZWxkIiwicmVhZERzQ2xvY2siLCJyZWFkRHNMZW4iLCJyZWFkQW5kQXBwbHlEZWxldGVTZXQiLCJ1bmFwcGxpZWREUyIsInN0YXRlIiwiZ2V0U3RhdGUiLCJjbG9ja0VuZCIsImluZGV4IiwiZmluZEluZGV4U1MiLCJzcGxpY2UiLCJzcGxpdEl0ZW0iLCJkZWxldGUiLCJVcGRhdGVFbmNvZGVyVjIiLCJ0b1VpbnQ4QXJyYXkiLCJlcXVhbERlbGV0ZVNldHMiLCJkczEiLCJkczIiLCJkZWxldGVJdGVtczEiLCJkZWxldGVJdGVtczIiLCJkaTEiLCJkaTIiLCJnZW5lcmF0ZU5ld0NsaWVudElkIiwidWludDMyIiwiRG9jIiwiZ3VpZCIsInV1aWR2NCIsImNvbGxlY3Rpb25pZCIsImdjIiwiZ2NGaWx0ZXIiLCJtZXRhIiwiYXV0b0xvYWQiLCJzaG91bGRMb2FkIiwiY2xpZW50SUQiLCJzaGFyZSIsIlN0cnVjdFN0b3JlIiwiX3RyYW5zYWN0aW9uIiwiX3RyYW5zYWN0aW9uQ2xlYW51cHMiLCJzdWJkb2NzIiwiU2V0IiwiX2l0ZW0iLCJpc0xvYWRlZCIsImlzU3luY2VkIiwid2hlbkxvYWRlZCIsImNyZWF0ZSIsInJlc29sdmUiLCJvbiIsInByb3ZpZGVTeW5jZWRQcm9taXNlIiwiZXZlbnRIYW5kbGVyIiwib2ZmIiwid2hlblN5bmNlZCIsImVtaXQiLCJsb2FkIiwidHJhbnNhY3QiLCJwYXJlbnQiLCJzdWJkb2NzTG9hZGVkIiwiYWRkIiwiZ2V0U3ViZG9jcyIsImdldFN1YmRvY0d1aWRzIiwib3JpZ2luIiwibmFtZSIsIlR5cGVDb25zdHJ1Y3RvciIsIkFic3RyYWN0VHlwZSIsInR5cGUiLCJ0IiwiX2ludGVncmF0ZSIsIkNvbnN0ciIsIl9tYXAiLCJuIiwiX3N0YXJ0IiwiX2xlbmd0aCIsIkVycm9yIiwiZ2V0QXJyYXkiLCJZQXJyYXkiLCJnZXRUZXh0IiwiWVRleHQiLCJnZXRNYXAiLCJZTWFwIiwiZ2V0WG1sRWxlbWVudCIsIllYbWxFbGVtZW50IiwiZ2V0WG1sRnJhZ21lbnQiLCJZWG1sRnJhZ21lbnQiLCJ0b0pTT04iLCJ2YWx1ZSIsImtleSIsImRlc3Ryb3kiLCJzdWJkb2MiLCJjb250ZW50Iiwib3B0cyIsInN1YmRvY3NBZGRlZCIsInN1YmRvY3NSZW1vdmVkIiwiZXZlbnROYW1lIiwiRFNEZWNvZGVyVjEiLCJVcGRhdGVEZWNvZGVyVjEiLCJyZWFkTGVmdElEIiwiY3JlYXRlSUQiLCJyZWFkUmlnaHRJRCIsInJlYWRDbGllbnQiLCJyZWFkSW5mbyIsInJlYWRVaW50OCIsInJlYWRTdHJpbmciLCJyZWFkVmFyU3RyaW5nIiwicmVhZFBhcmVudEluZm8iLCJyZWFkVHlwZVJlZiIsInJlYWRMZW4iLCJyZWFkQW55IiwicmVhZEJ1ZiIsImNvcHlVaW50OEFycmF5IiwicmVhZFZhclVpbnQ4QXJyYXkiLCJyZWFkSlNPTiIsIkpTT04iLCJwYXJzZSIsInJlYWRLZXkiLCJEU0RlY29kZXJWMiIsImRzQ3VyclZhbCIsImRpZmYiLCJVcGRhdGVEZWNvZGVyVjIiLCJrZXlzIiwia2V5Q2xvY2tEZWNvZGVyIiwiSW50RGlmZk9wdFJsZURlY29kZXIiLCJjbGllbnREZWNvZGVyIiwiVWludE9wdFJsZURlY29kZXIiLCJsZWZ0Q2xvY2tEZWNvZGVyIiwicmlnaHRDbG9ja0RlY29kZXIiLCJpbmZvRGVjb2RlciIsIlJsZURlY29kZXIiLCJzdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlciIsInBhcmVudEluZm9EZWNvZGVyIiwidHlwZVJlZkRlY29kZXIiLCJsZW5EZWNvZGVyIiwiSUQiLCJyZWFkIiwia2V5Q2xvY2siLCJEU0VuY29kZXJWMSIsImNyZWF0ZUVuY29kZXIiLCJVcGRhdGVFbmNvZGVyVjEiLCJ3cml0ZUxlZnRJRCIsIndyaXRlUmlnaHRJRCIsIndyaXRlQ2xpZW50Iiwid3JpdGVJbmZvIiwiaW5mbyIsIndyaXRlVWludDgiLCJ3cml0ZVN0cmluZyIsInMiLCJ3cml0ZVZhclN0cmluZyIsIndyaXRlUGFyZW50SW5mbyIsImlzWUtleSIsIndyaXRlVHlwZVJlZiIsIndyaXRlTGVuIiwid3JpdGVBbnkiLCJhbnkiLCJ3cml0ZUJ1ZiIsImJ1ZiIsIndyaXRlVmFyVWludDhBcnJheSIsIndyaXRlSlNPTiIsImVtYmVkIiwic3RyaW5naWZ5Iiwid3JpdGVLZXkiLCJEU0VuY29kZXJWMiIsInVuZXhwZWN0ZWRDYXNlIiwia2V5TWFwIiwia2V5Q2xvY2tFbmNvZGVyIiwiSW50RGlmZk9wdFJsZUVuY29kZXIiLCJjbGllbnRFbmNvZGVyIiwiVWludE9wdFJsZUVuY29kZXIiLCJsZWZ0Q2xvY2tFbmNvZGVyIiwicmlnaHRDbG9ja0VuY29kZXIiLCJpbmZvRW5jb2RlciIsIlJsZUVuY29kZXIiLCJzdHJpbmdFbmNvZGVyIiwiU3RyaW5nRW5jb2RlciIsInBhcmVudEluZm9FbmNvZGVyIiwidHlwZVJlZkVuY29kZXIiLCJsZW5FbmNvZGVyIiwid3JpdGVVaW50OEFycmF5Iiwid3JpdGUiLCJ3cml0ZVN0cnVjdHMiLCJzdGFydE5ld1N0cnVjdHMiLCJmaXJzdFN0cnVjdCIsIndyaXRlQ2xpZW50c1N0cnVjdHMiLCJfc20iLCJzbSIsImdldFN0YXRlVmVjdG9yIiwiX2Nsb2NrIiwicmVhZENsaWVudHNTdHJ1Y3RSZWZzIiwiY2xpZW50UmVmcyIsIm51bU9mU3RhdGVVcGRhdGVzIiwibnVtYmVyT2ZTdHJ1Y3RzIiwicmVmcyIsIkFycmF5IiwiQklUUzUiLCJHQyIsIlNraXAiLCJjYW50Q29weVBhcmVudEluZm8iLCJCSVQ3IiwiQklUOCIsIkl0ZW0iLCJCSVQ2IiwicmVhZEl0ZW1Db250ZW50IiwiaW50ZWdyYXRlU3RydWN0cyIsImNsaWVudHNTdHJ1Y3RSZWZzIiwic3RhY2siLCJjbGllbnRzU3RydWN0UmVmc0lkcyIsImdldE5leHRTdHJ1Y3RUYXJnZXQiLCJuZXh0U3RydWN0c1RhcmdldCIsInBvcCIsImN1clN0cnVjdHNUYXJnZXQiLCJyZXN0U3RydWN0cyIsIm1pc3NpbmdTViIsInVwZGF0ZU1pc3NpbmdTdiIsIm1jbG9jayIsInN0YWNrSGVhZCIsImFkZFN0YWNrVG9SZXN0U1MiLCJ1bmFwcGxpY2FibGVJdGVtcyIsImZpbHRlciIsImMiLCJsb2NhbENsb2NrIiwib2Zmc2V0IiwibWlzc2luZyIsImdldE1pc3NpbmciLCJzdHJ1Y3RSZWZzIiwiaW50ZWdyYXRlIiwidXBkYXRlIiwid3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uIiwiYmVmb3JlU3RhdGUiLCJyZWFkVXBkYXRlVjIiLCJ0cmFuc2FjdGlvbk9yaWdpbiIsInN0cnVjdERlY29kZXIiLCJsb2NhbCIsInJldHJ5IiwicGVuZGluZyIsInBlbmRpbmdTdHJ1Y3RzIiwibWVyZ2VVcGRhdGVzVjIiLCJkc1Jlc3QiLCJwZW5kaW5nRHMiLCJwZW5kaW5nRFNVcGRhdGUiLCJjcmVhdGVEZWNvZGVyIiwiZHNSZXN0MiIsImFwcGx5VXBkYXRlVjIiLCJyZWFkVXBkYXRlIiwiWURlY29kZXIiLCJhcHBseVVwZGF0ZSIsIndyaXRlU3RhdGVBc1VwZGF0ZSIsInRhcmdldFN0YXRlVmVjdG9yIiwiZW5jb2RlU3RhdGVBc1VwZGF0ZVYyIiwiZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yIiwiVWludDhBcnJheSIsImRlY29kZVN0YXRlVmVjdG9yIiwidXBkYXRlcyIsImRpZmZVcGRhdGVWMiIsIm1lcmdlVXBkYXRlcyIsImNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEiLCJlbmNvZGVTdGF0ZUFzVXBkYXRlIiwicmVhZFN0YXRlVmVjdG9yIiwic3NMZW5ndGgiLCJkZWNvZGVkU3RhdGUiLCJ3cml0ZVN0YXRlVmVjdG9yIiwic3YiLCJ3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IiLCJlbmNvZGVTdGF0ZVZlY3RvclYyIiwiZW5jb2RlU3RhdGVWZWN0b3IiLCJFdmVudEhhbmRsZXIiLCJsIiwiY3JlYXRlRXZlbnRIYW5kbGVyIiwiYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIiLCJyZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lciIsImciLCJjb25zb2xlIiwiY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyIsImFyZzAiLCJhcmcxIiwiY29tcGFyZUlEcyIsIndyaXRlSUQiLCJyZWFkSUQiLCJmaW5kUm9vdFR5cGVLZXkiLCJpc1BhcmVudE9mIiwiY2hpbGQiLCJsb2dUeXBlIiwicmVzIiwibG9nIiwibSIsIlBlcm1hbmVudFVzZXJEYXRhIiwic3RvcmVUeXBlIiwieXVzZXJzIiwiaW5pdFVzZXIiLCJ1c2VyIiwidXNlckRlc2NyaXB0aW9uIiwiaWRzIiwiYWRkQ2xpZW50SWQiLCJvYnNlcnZlIiwiZXZlbnQiLCJjaGFuZ2VzIiwiYWRkZWQiLCJnZXRDb250ZW50IiwiZW5jb2RlZERzIiwia2V5c0NoYW5nZWQiLCJzZXRVc2VyTWFwcGluZyIsInVzZXJzIiwiX2V2ZW50Iiwic2V0VGltZW91dCIsInVzZXJPdmVyd3JpdGUiLCJfdXNlckRlc2NyaXB0aW9uIiwieWRzIiwiZGVsZXRlU2V0IiwiZ2V0VXNlckJ5Q2xpZW50SWQiLCJnZXRVc2VyQnlEZWxldGVkSWQiLCJSZWxhdGl2ZVBvc2l0aW9uIiwidG5hbWUiLCJhc3NvYyIsInJlbGF0aXZlUG9zaXRpb25Ub0pTT04iLCJycG9zIiwianNvbiIsImNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiIsIkFic29sdXRlUG9zaXRpb24iLCJjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiIsInR5cGVpZCIsImNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4IiwiY291bnRhYmxlIiwibGFzdElkIiwid3JpdGVSZWxhdGl2ZVBvc2l0aW9uIiwid3JpdGVWYXJJbnQiLCJlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uIiwicmVhZFJlbGF0aXZlUG9zaXRpb24iLCJpdGVtSUQiLCJoYXNDb250ZW50IiwicmVhZFZhckludCIsImRlY29kZVJlbGF0aXZlUG9zaXRpb24iLCJ1aW50OEFycmF5IiwiY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uIiwicmlnaHRJRCIsInR5cGVJRCIsImZvbGxvd1JlZG9uZSIsIkNvbnRlbnRUeXBlIiwiY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zIiwiU25hcHNob3QiLCJlcXVhbFNuYXBzaG90cyIsInNuYXAxIiwic25hcDIiLCJzdjEiLCJzdjIiLCJkc2l0ZW1zMSIsImRzaXRlbXMyIiwiZHNpdGVtMSIsImRzaXRlbTIiLCJlbmNvZGVTbmFwc2hvdFYyIiwic25hcHNob3QiLCJlbmNvZGVTbmFwc2hvdCIsImRlY29kZVNuYXBzaG90VjIiLCJkZWNvZGVTbmFwc2hvdCIsImNyZWF0ZVNuYXBzaG90IiwiZW1wdHlTbmFwc2hvdCIsImlzVmlzaWJsZSIsInNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMiLCJnZXRJdGVtQ2xlYW5TdGFydCIsImNyZWF0ZURvY0Zyb21TbmFwc2hvdCIsIm9yaWdpbkRvYyIsIm5ld0RvYyIsImxhc3RTdHJ1Y3RJbmRleCIsInNuYXBzaG90Q29udGFpbnNVcGRhdGVWMiIsInVwZGF0ZURlY29kZXIiLCJsYXp5RGVjb2RlciIsIkxhenlTdHJ1Y3RSZWFkZXIiLCJjdXJyIiwibWVyZ2VkRFMiLCJzbmFwc2hvdENvbnRhaW5zVXBkYXRlIiwibGFzdFN0cnVjdCIsImFkZFN0cnVjdCIsImZpbmQiLCJnZXRJdGVtIiwiZmluZEluZGV4Q2xlYW5TdGFydCIsImdldEl0ZW1DbGVhbkVuZCIsInJlcGxhY2VTdHJ1Y3QiLCJuZXdTdHJ1Y3QiLCJjbG9ja1N0YXJ0IiwiVHJhbnNhY3Rpb24iLCJhZnRlclN0YXRlIiwiY2hhbmdlZCIsImNoYW5nZWRQYXJlbnRUeXBlcyIsIl9tZXJnZVN0cnVjdHMiLCJfbmVlZEZvcm1hdHRpbmdDbGVhbnVwIiwid3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uIiwiYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uIiwicGFyZW50U3ViIiwidHJ5VG9NZXJnZVdpdGhMZWZ0cyIsInBvcyIsIm1lcmdlV2l0aCIsInRyeUdjRGVsZXRlU2V0IiwiZGVsZXRlSXRlbXMiLCJkaSIsImRlbGV0ZUl0ZW0iLCJlbmREZWxldGVJdGVtQ2xvY2siLCJzaSIsImtlZXAiLCJ0cnlNZXJnZURlbGV0ZVNldCIsIm1vc3RSaWdodEluZGV4VG9DaGVjayIsIm1pbiIsInRyeUdjIiwiY2xlYW51cFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9uQ2xlYW51cHMiLCJtZXJnZVN0cnVjdHMiLCJmcyIsInN1YnMiLCJpdGVtdHlwZSIsIl9jYWxsT2JzZXJ2ZXIiLCJldmVudHMiLCJfZEVIIiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIl9wYXRoIiwiZXZlbnQxIiwiZXZlbnQyIiwicGF0aCIsImNsZWFudXBZVGV4dEFmdGVyVHJhbnNhY3Rpb24iLCJiZWZvcmVDbG9jayIsImZpcnN0Q2hhbmdlUG9zIiwicmVwbGFjZWRTdHJ1Y3RQb3MiLCJwcmludCIsIk9SQU5HRSIsIkJPTEQiLCJVTkJPTEQiLCJSRUQiLCJfb2JzZXJ2ZXJzIiwibG9hZGVkIiwicmVtb3ZlZCIsImluaXRpYWxDYWxsIiwicmVzdWx0IiwiZmluaXNoQ2xlYW51cCIsIlN0YWNrSXRlbSIsImRlbGV0aW9ucyIsImluc2VydGlvbnMiLCJjbGVhclVuZG9NYW5hZ2VyU3RhY2tJdGVtIiwidHIiLCJ1bSIsInN0YWNrSXRlbSIsInNjb3BlIiwic29tZSIsImtlZXBJdGVtIiwicG9wU3RhY2tJdGVtIiwidW5kb01hbmFnZXIiLCJldmVudFR5cGUiLCJfdHIiLCJpdGVtc1RvUmVkbyIsIml0ZW1zVG9EZWxldGUiLCJwZXJmb3JtZWRDaGFuZ2UiLCJyZWRvbmUiLCJyZWRvSXRlbSIsImlnbm9yZVJlbW90ZU1hcENoYW5nZXMiLCJkZWxldGVGaWx0ZXIiLCJzdWJQcm9wcyIsIl9zZWFyY2hNYXJrZXIiLCJVbmRvTWFuYWdlciIsInR5cGVTY29wZSIsImNhcHR1cmVUaW1lb3V0IiwiY2FwdHVyZVRyYW5zYWN0aW9uIiwidHJhY2tlZE9yaWdpbnMiLCJpc0FycmF5IiwiYWRkVG9TY29wZSIsInVuZG9TdGFjayIsInJlZG9TdGFjayIsInVuZG9pbmciLCJyZWRvaW5nIiwibGFzdENoYW5nZSIsImFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyIiwic3RvcENhcHR1cmluZyIsImNsZWFyIiwiZW5kQ2xvY2siLCJzdGFydENsb2NrIiwibm93IiwiZ2V0VW5peFRpbWUiLCJkaWRBZGQiLCJsYXN0T3AiLCJjaGFuZ2VFdmVudCIsInl0eXBlcyIsInl0eXBlIiwiZXZlcnkiLCJ5dCIsIndhcm4iLCJhZGRUcmFja2VkT3JpZ2luIiwicmVtb3ZlVHJhY2tlZE9yaWdpbiIsImNsZWFyVW5kb1N0YWNrIiwiY2xlYXJSZWRvU3RhY2siLCJjYW5VbmRvIiwiY2FuUmVkbyIsInVuZG9TdGFja0NsZWFyZWQiLCJyZWRvU3RhY2tDbGVhcmVkIiwidW5kbyIsInJlZG8iLCJsYXp5U3RydWN0UmVhZGVyR2VuZXJhdG9yIiwiZmlsdGVyU2tpcHMiLCJnZW4iLCJkb25lIiwibG9nVXBkYXRlIiwibG9nVXBkYXRlVjIiLCJkZWNvZGVVcGRhdGUiLCJkZWNvZGVVcGRhdGVWMiIsIkxhenlTdHJ1Y3RXcml0ZXIiLCJjdXJyQ2xpZW50Iiwid3JpdHRlbiIsImNsaWVudFN0cnVjdHMiLCJlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMiIsIllFbmNvZGVyIiwic3RvcENvdW50aW5nIiwiY3VyckNsb2NrIiwiZW5jIiwid3JpdGVCaW5hcnlFbmNvZGVyIiwiZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlIiwicGFyc2VVcGRhdGVNZXRhVjIiLCJ0byIsInBhcnNlVXBkYXRlTWV0YSIsInNsaWNlU3RydWN0IiwibGVmdEl0ZW0iLCJyaWdodE9yaWdpbiIsInVwZGF0ZURlY29kZXJzIiwibGF6eVN0cnVjdERlY29kZXJzIiwiY3VycldyaXRlIiwidXBkYXRlRW5jb2RlciIsImxhenlTdHJ1Y3RFbmNvZGVyIiwiZGVjIiwiZGVjMSIsImRlYzIiLCJjbG9ja0RpZmYiLCJjdXJyRGVjb2RlciIsImZpcnN0Q2xpZW50IiwiaXRlcmF0ZWQiLCJ3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlciIsImZpbmlzaExhenlTdHJ1Y3RXcml0aW5nIiwibGF6eVN0cnVjdFdyaXRlciIsInJlYWRlciIsInN2Q2xvY2siLCJkaWZmVXBkYXRlIiwiZmx1c2hMYXp5U3RydWN0V3JpdGVyIiwibGF6eVdyaXRlciIsInBhcnRTdHJ1Y3RzIiwiY29udmVydFVwZGF0ZUZvcm1hdCIsImJsb2NrVHJhbnNmb3JtZXIiLCJjcmVhdGVPYmZ1c2NhdG9yIiwiZm9ybWF0dGluZyIsInl4bWwiLCJtYXBLZXlDYWNoZSIsIm5vZGVOYW1lQ2FjaGUiLCJmb3JtYXR0aW5nS2V5Q2FjaGUiLCJmb3JtYXR0aW5nVmFsdWVDYWNoZSIsImJsb2NrIiwiQ29udGVudERlbGV0ZWQiLCJub2RlTmFtZSIsIllYbWxIb29rIiwiaG9va05hbWUiLCJDb250ZW50QW55IiwiYXJyIiwiQ29udGVudEJpbmFyeSIsIkNvbnRlbnREb2MiLCJDb250ZW50RW1iZWQiLCJDb250ZW50Rm9ybWF0IiwiQ29udGVudEpTT04iLCJDb250ZW50U3RyaW5nIiwic3RyIiwicmVwZWF0Iiwib2JmdXNjYXRlVXBkYXRlIiwib2JmdXNjYXRlVXBkYXRlVjIiLCJjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyIiwiZXJyb3JDb21wdXRlQ2hhbmdlcyIsIllFdmVudCIsIl9jaGFuZ2VzIiwiX2tleXMiLCJfZGVsdGEiLCJnZXRQYXRoVG8iLCJhY3Rpb24iLCJvbGRWYWx1ZSIsImFkZHMiLCJwcmV2IiwibGFzdCIsImRlbHRhIiwicGFja09wIiwiaW5zZXJ0IiwiY29uY2F0IiwicmV0YWluIiwidW5zaGlmdCIsIm1heFNlYXJjaE1hcmtlciIsImdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCIsIkFycmF5U2VhcmNoTWFya2VyIiwicCIsIm1hcmtlciIsInRpbWVzdGFtcCIsInJlZnJlc2hNYXJrZXJUaW1lc3RhbXAiLCJvdmVyd3JpdGVNYXJrZXIiLCJtYXJrUG9zaXRpb24iLCJzZWFyY2hNYXJrZXIiLCJyZWR1Y2UiLCJwbSIsImZpbmRNYXJrZXIiLCJ5YXJyYXkiLCJhYnMiLCJwaW5kZXgiLCJ1cGRhdGVNYXJrZXJDaGFuZ2VzIiwiZ2V0VHlwZUNoaWxkcmVuIiwiY2FsbFR5cGVPYnNlcnZlcnMiLCJjaGFuZ2VkVHlwZSIsIl9lSCIsInkiLCJfY29weSIsIm1ldGhvZFVuaW1wbGVtZW50ZWQiLCJjbG9uZSIsIl93cml0ZSIsIl9lbmNvZGVyIiwiX2ZpcnN0IiwiX3BhcmVudFN1YnMiLCJvYnNlcnZlRGVlcCIsInVub2JzZXJ2ZSIsInVub2JzZXJ2ZURlZXAiLCJ0eXBlTGlzdFNsaWNlIiwic3RhcnQiLCJlbmQiLCJjcyIsInR5cGVMaXN0VG9BcnJheSIsInR5cGVMaXN0VG9BcnJheVNuYXBzaG90IiwidHlwZUxpc3RGb3JFYWNoIiwidHlwZUxpc3RNYXAiLCJ0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yIiwiY3VycmVudENvbnRlbnQiLCJjdXJyZW50Q29udGVudEluZGV4IiwiU3ltYm9sIiwidHlwZUxpc3RHZXQiLCJ0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIiLCJyZWZlcmVuY2VJdGVtIiwib3duQ2xpZW50SWQiLCJqc29uQ29udGVudCIsInBhY2tKc29uQ29udGVudCIsIk51bWJlciIsIk9iamVjdCIsIkJvb2xlYW4iLCJTdHJpbmciLCJBcnJheUJ1ZmZlciIsImxlbmd0aEV4Y2VlZGVkIiwidHlwZUxpc3RJbnNlcnRHZW5lcmljcyIsInN0YXJ0SW5kZXgiLCJ0eXBlTGlzdFB1c2hHZW5lcmljcyIsIm1heE1hcmtlciIsImN1cnJNYXJrZXIiLCJ0eXBlTGlzdERlbGV0ZSIsInN0YXJ0TGVuZ3RoIiwidHlwZU1hcERlbGV0ZSIsInR5cGVNYXBTZXQiLCJ0eXBlTWFwR2V0IiwidmFsIiwidHlwZU1hcEdldEFsbCIsInR5cGVNYXBIYXMiLCJ0eXBlTWFwR2V0U25hcHNob3QiLCJ2IiwidHlwZU1hcEdldEFsbFNuYXBzaG90IiwiY3JlYXRlTWFwSXRlcmF0b3IiLCJpdGVyYXRvckZpbHRlciIsImVudHJ5IiwiWUFycmF5RXZlbnQiLCJfcHJlbGltQ29udGVudCIsIml0ZW1zIiwidG9BcnJheSIsImVsIiwicGFyZW50U3VicyIsIllBcnJheVJlZklEIiwicmVhZFlBcnJheSIsIl9kZWNvZGVyIiwiWU1hcEV2ZW50IiwieW1hcCIsIml0ZXJhdG9yTWFwIiwidmFsdWVzIiwiX3ZhbHVlIiwiWU1hcFJlZklEIiwicmVhZFlNYXAiLCJlcXVhbEF0dHJzIiwiZXF1YWxGbGF0IiwiSXRlbVRleHRMaXN0UG9zaXRpb24iLCJjdXJyZW50QXR0cmlidXRlcyIsImZvcndhcmQiLCJ1cGRhdGVDdXJyZW50QXR0cmlidXRlcyIsImZpbmROZXh0UG9zaXRpb24iLCJjb3VudCIsImZpbmRQb3NpdGlvbiIsInVzZVNlYXJjaE1hcmtlciIsImluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzIiwiY3VyclBvcyIsIm5lZ2F0ZWRBdHRyaWJ1dGVzIiwibmV4dEZvcm1hdCIsImZvcm1hdCIsIm1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyIsImF0dHJpYnV0ZXMiLCJpbnNlcnRBdHRyaWJ1dGVzIiwiY3VycmVudFZhbCIsImluc2VydFRleHQiLCJ0ZXh0IiwiX3ZhbCIsImdldExlbmd0aCIsImZvcm1hdFRleHQiLCJpdGVyYXRpb25Mb29wIiwiYXR0ciIsIm5ld2xpbmVzIiwiY2xlYW51cEZvcm1hdHRpbmdHYXAiLCJzdGFydEF0dHJpYnV0ZXMiLCJjdXJyQXR0cmlidXRlcyIsImVuZEZvcm1hdHMiLCJjZiIsImNsZWFudXBzIiwicmVhY2hlZEN1cnIiLCJzdGFydEF0dHJWYWx1ZSIsImNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAiLCJhdHRycyIsImNsZWFudXBZVGV4dEZvcm1hdHRpbmciLCJjb3B5IiwibmVlZEZ1bGxDbGVhbnVwIiwiYWZ0ZXJDbG9jayIsIl9oYXNGb3JtYXR0aW5nIiwieVRleHQiLCJkZWxldGVUZXh0Iiwic3RhcnRBdHRycyIsIllUZXh0RXZlbnQiLCJ5dGV4dCIsImNoaWxkTGlzdENoYW5nZWQiLCJzdWIiLCJvbGRBdHRyaWJ1dGVzIiwiZGVsZXRlTGVuIiwiYWRkT3AiLCJvcCIsImlzRW1wdHkiLCJhc3NpZ24iLCJjdXJWYWwiLCJfcGVuZGluZyIsImUiLCJhcHBseURlbHRhIiwidG9EZWx0YSIsInRvU3RyaW5nIiwic2FuaXRpemUiLCJpbnMiLCJwcmV2U25hcHNob3QiLCJjb21wdXRlWUNoYW5nZSIsIm9wcyIsInBhY2tTdHIiLCJhZGRBdHRyaWJ1dGVzIiwiY29tcHV0ZURlbHRhIiwiY3VyIiwiayIsImluc2VydEVtYmVkIiwicmVtb3ZlQXR0cmlidXRlIiwiYXR0cmlidXRlTmFtZSIsInNldEF0dHJpYnV0ZSIsImF0dHJpYnV0ZVZhbHVlIiwiZ2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlcyIsIllUZXh0UmVmSUQiLCJyZWFkWVRleHQiLCJZWG1sVHJlZVdhbGtlciIsInJvb3QiLCJfZmlsdGVyIiwiX3Jvb3QiLCJfY3VycmVudE5vZGUiLCJfZmlyc3RDYWxsIiwiZmlyc3RDaGlsZCIsImZpcnN0IiwiY3JlYXRlVHJlZVdhbGtlciIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeSIsInRvVXBwZXJDYXNlIiwiZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJZWG1sRXZlbnQiLCJ4bWwiLCJqb2luIiwidG9ET00iLCJfZG9jdW1lbnQiLCJkb2N1bWVudCIsImhvb2tzIiwiYmluZGluZyIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9jcmVhdGVBc3NvY2lhdGlvbiIsInhtbFR5cGUiLCJpbnNlcnRCZWZvcmUiLCJpbnNlcnRBZnRlciIsInJlZiIsInJlZkl0ZW0iLCJwYyIsImZpbmRJbmRleCIsIllYbWxGcmFnbWVudFJlZklEIiwicmVhZFlYbWxGcmFnbWVudCIsIl9wcmVsaW1BdHRycyIsIm5leHRTaWJsaW5nIiwicHJldlNpYmxpbmciLCJzdHJpbmdCdWlsZGVyIiwia2V5c0xlbiIsInRvTG9jYWxlTG93ZXJDYXNlIiwiYXR0cnNTdHJpbmciLCJoYXNBdHRyaWJ1dGUiLCJkb20iLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJZWG1sRWxlbWVudFJlZklEIiwicmVhZFlYbWxFbGVtZW50IiwiYXR0cmlidXRlc0NoYW5nZWQiLCJob29rIiwiY3JlYXRlRG9tIiwiWVhtbEhvb2tSZWZJRCIsInJlYWRZWG1sSG9vayIsIllYbWxUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJuZXN0ZWROb2RlcyIsIm5vZGUiLCJZWG1sVGV4dFJlZklEIiwicmVhZFlYbWxUZXh0IiwiQWJzdHJhY3RTdHJ1Y3QiLCJlbmNvZGluZ1JlZiIsInN0cnVjdEdDUmVmTnVtYmVyIiwiaXNDb3VudGFibGUiLCJnZXRSZWYiLCJyZWFkQ29udGVudEJpbmFyeSIsIm1hcmtEZWxldGVkIiwicmVhZENvbnRlbnREZWxldGVkIiwiY3JlYXRlRG9jRnJvbU9wdHMiLCJyZWFkQ29udGVudERvYyIsInJlYWRDb250ZW50RW1iZWQiLCJfb2Zmc2V0IiwiX3JpZ2h0IiwicmVhZENvbnRlbnRGb3JtYXQiLCJyZWFkQ29udGVudEpTT04iLCJyZWFkQ29udGVudEFueSIsInNwbGl0IiwiZmlyc3RDaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJyZWFkQ29udGVudFN0cmluZyIsInR5cGVSZWZzIiwicmVhZENvbnRlbnRUeXBlIiwibmV4dElEIiwicmlnaHRJdGVtIiwiaXNEZWxldGVkQnlVbmRvU3RhY2siLCJyZWRvaXRlbXMiLCJvd25DbGllbnRJRCIsInBhcmVudEl0ZW0iLCJwYXJlbnRUeXBlIiwibGVmdFRyYWNlIiwicmlnaHRUcmFjZSIsIm5leHRDbG9jayIsIm5leHRJZCIsInJlZG9uZUl0ZW0iLCJCSVQyIiwiaXNNYXJrZWQiLCJCSVQ0IiwiQklUMSIsImRvS2VlcCIsIkJJVDMiLCJkb0RlbGV0ZSIsIm8iLCJjb25mbGljdGluZ0l0ZW1zIiwiaXRlbXNCZWZvcmVPcmlnaW4iLCJyIiwicGFyZW50R0NkIiwieWtleSIsImNvbnRlbnRSZWZzIiwic3RydWN0U2tpcFJlZk51bWJlciIsImdsbyIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJpbXBvcnRJZGVudGlmaWVyIiwiVGV4dCIsIlhtbEVsZW1lbnQiLCJYbWxGcmFnbWVudCIsIlhtbEhvb2siLCJYbWxUZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/yjs/dist/yjs.mjs\n");

/***/ })

};
;